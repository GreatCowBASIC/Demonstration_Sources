;
; MEGA4809_USART_RX_TX _ECHO.asm
;
; Created: 8/17/2024 12:37:17 PM
; Author : cribcat
;
; * have not tested the ISR(commented out) on hardware or software in this program
; * This handles serial by polling
; * tested with Realterm Putty terminal programs 
;--------------------------------
; This code recieves a byte/character @ 9600 baud
; and sends the byte back to the terminal program
;--------------------------------


.include"m4809def.inc"

.def zero = r2

.def tmp = r16          ; gp reg
.def tmp2 = r17         ; gp reg

;.equ fclk =   3333333 
.equ fclk =   20000000 
.equ BAUD = 9600
.equ fBAUD = ((64 * fclk)/(16 * BAUD)+0.5)  ; truncated ;   can set  fbaud = 1388 for 3.333MHz  
                                            ;                        fbaud = 8333 for 20 MHz                                                      
.org 0x00 
          jmp start
;.org 0x34  
;           jmp rs232RXint   ;recieive complete interrupt usart_1
      
 start:
         clr r2                       ; for zero reg (not used)
         call usartSETUP

   
chgPrescaler:                         ; no prescaler and 20 MHz).
		ldi tmp, CPU_CCP_IOREG_gc
		clr tmp2          
		out CPU_CCP, tmp              ; Change Protection 
		sts CLKCTRL_MCLKCTRLB, tmp2   ; no Prescaler
		sts CLKCTRL_MCLKCTRLA, tmp2   ; 20MHz
		
main:   
         call getByte           ; RX     
		 
		 call sendbyte          ; TX
		; call delay25ms        ; not used
		 rjmp main              ; loop

 ; SendByte	  
 ; ----------------------------------
sendByte:                       ; polling for Bit 5 – DREIF?USART Data Register Empty Flag. 1 when empty
 	lds tmp,USART1_STATUS		; copy USART status register to r18	
	sbrs tmp,5			        ; skip next instruction if bit 5 is 1 means flag set for data transmit buffer 
	rjmp sendbyte			    ; if DREIF = 0 ,bit 5 in r18 is 0 then loop back to sendbyte until DREIF = 1
		
	sts USART1_TXDATAL,tmp2		; store r19 in TXDATAL transmit data low register for tx
	ret
;-------------------------------------
getbyte:                        ; a polling routine like sendbyte 
	lds tmp, USART1_STATUS
	sbrs tmp, USART_RXCIF_bp	; while (!(USART0.STATUS & USART_RXCIF_bm))
	rjmp getbyte

    lds tmp2, USART1_RXDATAL	; get rx'd byte;return USART0.RXDATAL in tmp2
	ret  


;USART Initialization
;-----------------------------------
usartSETUP:

	ldi tmp,low(fBAUD)		    ; load low value of fBAUD as calculated in the formula provided above
	ldi tmp2,high(fBAUD)		;  
	sts USART1_BAUD,tmp		    ; store low fBAUD in BAUD register
	sts USART1_BAUD + 1,tmp2	; store high fBAUD in BAUD register

;	ldi tmp,  USART_RXCIE_bm    ; enable recv complete int enable 
;	sts  USART1_CTRLA,tmp  

	ldi tmp,USART_NORMAL_PMODE_DISABLED_gc|USART_NORMAL_SBMODE_1BIT_gc|USART_NORMAL_CHSIZE_8BIT_gc    ; async 8bit no parity with one stop bit 
	sts USART1_CTRLC,tmp   
	ldi tmp, USART_RXEN_bm|USART_TXEN_bm    ; bit 6,7 resp   EN TX/RX
	sts USART1_CTRLB,tmp

	ldi tmp, 1 	                ; usually use sbi for single pin
	sts PORTC_DIR, tmp          ; sbi  VPORTC_DIR,0	;  (virtual register)             
	
	ret 
                                    
; Generated by delay loop calculator 
; Delay 499 993 cycles
; 24ms 999us 650 ns at 20 MHz
;------------------------------
/* 
delay25ms: 
    push r18
	push r19


    ldi  r18, 3
    ldi  r19, 138
    ldi  r20, 84
L1: dec  r20
    brne L1
    dec  r19
    brne L1
    dec  r18
    brne L1
    nop

	pop r19
	pop r18
	ret 
 
 */
/*
; ISR Interrupt Routine
;----------------------------------------
rs232RXint:	
	   push r16              
	   in r16, CPU_SREG
	   push R16
	   ;^^-----context-----^^ 
 
        
	    lds gpr, USART1_RXDATAL		; get rx'd byte;return USART0.RXDATAL;			 
		                            ; gpr needs to be a reg that isn't restored it's 'volatile'  
 		
   
	   ;-VV----context-----VV-
	   pop r16
	   out CPU_SREG, r16	 
	   pop  r16   
	    
	   reti
*/