'''A program  for GCGB and GCB.
'''--------------------------------------------------------------------------------------------------------------------------------
'''This program demonstrated how to set a bit of a variable.  This program shows the results on the serial terminal.
'''
'''@author     Bill Roth
'''@licence    GPL
'''@version    1.00
'''@date       10.04.2020
'''********************************************************************************




#Chip 18F25K42
#Option Explicit

    #define USART_BAUD_RATE 9600
    #define USART_BLOCKING
    #define USART_TX_BLOCKING

    'Generated by PIC PPS Tool for GCBASIC
    'PPS Tool version: 0.0.6.0
    'PinManager data: v1.78.1
    'Generated for 18f25k42
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85
    #define PPSToolPart 18f25k42

    Sub InitPPS

            'Module: UART pin directions
            Dir PORTB.0 Out    ' Make TX1 pin an output
            'Module: UART1
            RB0PPS = 0x0013    'TX1 > RB0

    End Sub
    'Template comment at the end of the config file


    ; ----- Main body of program commences here.


    Test1: ' Aliased LONG
    Dim _A4_ExtByte, _A3_UpperByte, _A2_HighByte, _A1_LowByte
    Dim BitNumber as Byte
    Dim MyLong As Long Alias _A4_ExtByte, _A3_UpperByte, _A2_HighByte, _A1_LowByte

    Test2: ' Non_Aliased LONG (Control)
    DIM TestLong as Long

    Test3: ' Aliased LONG called Smt1timer using assigned Variables/registers from chip registers
    DIM Smt1timer as Long Alias SMT1CPR,SMT1TMRU,SMT1TMRH,SMT1TMRL

    Test4: 'Aliased Word using "at" but in reverse alphabetical sequence
    'Aliased varibles MUST be sequence.
    DIM A_Var at 101
    Dim B_Var at 100
    DIM TestWord as Word Alias A_Var, B_Var

    Test5: 'Aliased Long should be defined as long first  then Dim bytes to alias the the Longs bytes
    'Create long first to ensure variables are sequenced.
    DIM MySequentialLong as Long
    DIM TestByte1 as Byte alias MySequentialLong_E
    DIM TestByte2 as Byte alias MySequentialLong_U
    DIM TestByte3 as Byte alias MySequentialLong_H
    DIM TestByte4 as Byte alias MySequentialLong


    ' Initalize & Clear to zero
    Smt1timer  = 0
    TestLong = 0
    MyLong = 0
    TestWord = 0

    TestByte1 = 0
    TestByte2 = 0
    TestByte3 = 0
    TestByte4 = 0

    MainTest:
    For BitNumber = 0 to 31   ' Write a "1" to all 32 bits
        MyLong.BitNumber = 1
        TestLong.BitNumber = 1
        Smt1timer.BitNumber = 1
    Next
    SMT1CPR = 0  ' Only requires bits 0-23

    For BitNumber = 0  to 15
       TestWord.bitnumber = 1
    Next

    For BitNumber = 0  to 7
        TestByte1.BitNumber = 1
        TestByte2.BitNumber = 1
        TestByte3.BitNumber = 1
        TestByte4.BitNumber = 1
    Next


    HSerPrintCRLF 2
    Wait 100 ms

    Hserprint TestWord : HserprintCRLf
    ' Should Return 65535

    HSERPRINT Smt1timer : HSERPRINTCRLF
    'Should Return 1677215

    Hserprint MyLong : HserprintCRLF
    ' Should print 4294967295

    Hserprint TestLong
    ' Should print 4294967295

    Hserprint MySequentialLong
    ' Should print 4294967295



    '-----------------------------------------
    '  All Pass and return the correct values
    '-----------------------------------------

    do
    Loop
