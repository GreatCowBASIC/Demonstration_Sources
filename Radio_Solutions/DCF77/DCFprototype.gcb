/*
So what about the UK time signals (MSF on 60 kHz)? 
Aliexpress offer a dual frequency (40 and 60 kHz) VLF receiver (the 40 kHz is for the Japanese VLF transmissions). 
The problem (as ever) is there is little to no information supplied. 
I tried all possible combinations of pins high and low and could not get it to work. 
So the solution was to remove the 60kHz crystal and put it onto a DCF77 board (I also swapped the ferrite inductors, but this made little difference).
UK VLF time signals  used to be broadcast from Rugby - a nice central location. 
Now they are broadcast from Anthorn in Cumbria (almost in Scotland) . 
This is a long way from me in fact the German one is probably nearer (and is definitely more powerful 50kW versus 17kW). 

As is to be expected the coding is different. Rather than a missing pulse on the minute MSF60 has an extra long pulse (500ms) on the minute. Other than that it is a mixture of long (200ms) and short pulses (100ms) to give the BCD time (except near the minute there can be 300ms pulses "as a parity check"). The code is below. I used a 12LF1552 (as I have no 12F1840's left). It only has a 8-bit counter (timer0), but with the prescaler (256:1) it is essentially 16-bit (with only the high byte accessible).

*/
#option explicit
#chip 18F27Q43,.5

#chip CHECK_USART_BAUD_RATE

/*
           ------------PORTA---------------
    Bit#:  -7---6---5---4---3---2---1---0---
    IO:    -------- NC-DIN-MCL-SDA-SCK-PWR--


    Implies:
        PWR is drawn from the PIC via PortA.0
        I2C to an LCD
        MCLR port.pin is not used
        DataIn (DIN) from clock source
        PortA.5 port.pin is not used/not connected

           ---DEVICE----------
    Bit#:  ---4---3---2---1---
    IO:    --??--??-0v0--5v0--
*/



#chip USART_BAUD_RATE 9600
#chip USART_TX_BLOCKING
#chip USART_DELAY OFF

    'Generated by PIC PPS Tool for Great Cow Basic
    'PPS Tool version: 0.0.6.3
    'PinManager data: v1.81.8
    'Generated for 18F27Q43
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85
    #chip PPSToolPart 18F27Q43

    Sub InitPPS
              
            'Module: UART pin directions
            Dir PORTC.6 Out    ' Make TX1 pin an output
            'Module: UART1
            RC6PPS = 0x0020    'TX1 > RC6
        
          End Sub
    'Template comment at the end of the config file


// ' Define HI2C settings
// #chip HI2C_BAUD_RATE 25
// #chip HI2C_DATA PORTA.2
// #chip HI2C_CLOCK PORTA.1
// Dir HI2C_DATA in
// Dir HI2C_CLOCK in
// HI2CMode Master

wait 20 ms

#chip SignalInPort PORTA.4

dir porta.3 in 'mclr pin
dir porta.0 out 'pon=power on
dir porta.4 in 'time pulses
dir porta.5 out 'out n/c
set porta.0 off 'pon off=on
set porta.5 off



    'Create the supporting variables
    Dim next_in As Byte
    Dim next_out As Byte
    Dim syncbyte As Byte
    Dim temppnt As Byte

    ' Constants etc required for Buffer Ring
    #chip BUFFER_SIZE 64
    #chip bkbhit (next_in <> next_out)

    'Define the Buffer
    Dim buffer( BUFFER_SIZE - 1 ) 'we will use element 0 in the array as part of out buffer

    'Call init the buffer
    InitBufferRing



// option_reg=b'00000111'
// wpua=b'00000110' 'HI2C pins

wait 1 s
HserPrintStringCRLF "DCF77 test"

Dim jj as Byte
jj=0
// kmin1=0:kmin=0
// khour1=0:khour=0
// kday1=0:kday=0
// kmonth1=0:kmonth=0
// kyear1=0:kyear=0 'initialize constants
// tmr0=0
// 'start of main loop...



    /**
    IOCx registers 
    */
    //interrupt on change for group IOCAF - flag
    IOCAFbits.IOCAF4 = 0;
    //interrupt on change for group IOCAN - negative
    IOCANbits.IOCAN4 = 1;
    //interrupt on change for group IOCAP - positive
    IOCAPbits.IOCAP4 = 1;

    
    Dim NewPulse as Bit
    NewPulse = 0

    InitTimer1 Osc, PS1_2
    starttimer 1
    Settimer 1,0
    wait 3 s
    // register default IOC callback functions at runtime; use these methods to register a custom function
    On Interrupt PORTABChange Call IOCAF4_DefaultInterruptHandler
    On Interrupt Timer1Overflow Call iSR1Overflow
    // Enable IOCI interrupt 
    PIE0bits.IOCIE = 1; 
dim jj as long
Sub IOCAF4_DefaultInterruptHandler
    IF IOCAF4 = 1 Then
        Select Case SignalInPort
            Case 1 

                Settimer 1,0
                StartTimer 1                                        
            Case 0  
                StopTimer 1
                
                buffer(next_in) = timer1
                temppnt = next_in
                next_in = ( next_in + 1 ) % BUFFER_SIZE
                If ( next_in = next_out ) Then  ' buffer is full!!
                    next_in = temppnt
                End If
                jj++
        End Select
        IOCAF4 = 0
    End If
End Sub
Sub iSR1Overflow
HserPrint "**"
IOCAF4 = 0
End Sub
do
        wait While !bkbhit 
        id7 = bgetc
        // HserPrint hex(jj_u)
        // HserPrint hex(jj_e)
        // HserPrint hex(jj_h)
        // HserPrint hex(jj)
        // HSerSend 0x3A
        HserPrint id7/8
        HSerSend  13

loop
do
    
    // do

    //     if porta.4=1 then 
    //         Settimer 1,0
    //         exit do 'start of pulse
    //     end if
    // loop

    // do
    //     if porta.4=0 then 
    //         exit do 'end of pulse 
    //     end if
    // loop

    wait While !bkbhit 
    id7 = bgetc

    dim id7 as byte
    // id7=timer1 'id7=37 is about 150 ms


DIM LAST
    #chip 150ms 37
    #chip 288ms 72
    #chip 440ms 110
    #chip timeout 255


    Select Case id7

        
        Case 150ms to 288ms
            iF JJ < LAST THEN
                HSerPrint id7
                HSerSend 9
                HserPrint "BCD = "
                HSerPrint BcdToDec_GCB ( jj )
                HserPrintCRLF
            END IF
            LAST = JJ
        Case 288ms to 440ms 
        Case 440ms to timeout
            jj=0
            HserPrint "Minute Marker " 
            HserPrintByteCRLF id7

        Case Else
                // HserPrint "BCD = "
                // HSerPrint BcdToDec_GCB ( jj )
                // HserPrintCRLF

    End Select

    if id7<110 then 
        //screen3
        // HserPrint timer1
        // HserPrintCRLF
    end if

    if id7>110 then 'found minute marker
        // jj=0
        // khour1=khour 'update on minute roll-over
        // kmin1=kmin
        // kday1=kday
        // kmonth1=kmonth
        // kyear1=kyear
        // khour=0
        // kmin=0
        // kday=0
        // kmonth=0
        // kyear=0
        // screen3
    end if
    '   binary coded decimal (arrgh!!)
    // if id7>37 and id7<72 then
        //     HSerPrint id7
        //     HSerSend 9
        //     HserPrint "BCD = "
        //     HSerPrint BcdToDec_GCB ( jj )
        //     HserPrintCRLF

        //     if jj=51 then kmin=kmin+1
        //     if jj=50 then kmin=kmin+2
        //     if jj=49 then kmin=kmin+4
        //     if jj=48 then kmin=kmin+8
        //     if jj=47 then kmin=kmin+10
        //     if jj=46 then kmin=kmin+20
        //     if jj=45 then kmin=kmin+40

        //     if jj=44 then khour=khour+1
        //     if jj=43 then khour=khour+2
        //     if jj=42 then khour=khour+4
        //     if jj=41 then khour=khour+8
        //     if jj=40 then khour=khour+10
        //     if jj=39 then khour=khour+20

        //     if jj=35 then kday=kday+1
        //     if jj=34 then kday=kday+2
        //     if jj=33 then kday=kday+4
        //     if jj=32 then kday=kday+8
        //     if jj=31 then kday=kday+10
        //     if jj=30 then kday=kday+20

        //     if jj=29 then kmonth=kmonth+1
        //     if jj=28 then kmonth=kmonth+2
        //     if jj=27 then kmonth=kmonth+4
        //     if jj=26 then kmonth=kmonth+8
        //     if jj=25 then kmonth=kmonth+10

        //     if jj=24 then kyear=kyear+1
        //     if jj=23 then kyear=kyear+2
        //     if jj=22 then kyear=kyear+4
        //     if jj=21 then kyear=kyear+8
        //     if jj=20 then kyear=kyear+10
        //     if jj=19 then kyear=kyear+20
        //     if jj=18 then kyear=kyear+40
        //     if jj=17 then kyear=kyear+80
    // end if
loop
end 'should never get here

sub screen3
        // hi2cstart
        // hi2csEND(Sl)
        // hi2csEND(Comsend)
        // hi2csend(0x80) 'first line
        // hi2cstop
        // j1=jj/10
        // j2=jj%10
        // hi2cstart
        // hi2csend(Sl)
        // hi2csend(DS)
        // hi2csend(khour1/10+48)
        // hi2csend(khour1%10+48)
        // hi2csend(32)
        // hi2csend(58)
        // hi2csend(32)
        // hi2csend(kmin1/10+48)
        // hi2csend(kmin1%10+48)
        // hi2csend(32)
        // hi2csend(58)
        // hi2csend(32)
        // hi2csend(j1+48)
        // hi2csend(j2+48)
        // hi2csend(32)
        // hi2cSTOP

        // hi2cStart
        // hi2cSEND(Sl)
        // hi2cSEND(Comsend)
        // hi2csend(0xC0) 'second line
        // hi2cstop
        // hi2cstart
        // hi2cSEND(Sl)
        // hi2cSEND(DS)
        // hi2csend(kday1/10+48)
        // hi2csend(kday1%10+48)
        // hi2csend(32)
        // hi2csend(47)
        // hi2csend(32)
        // hi2csend(kmonth1/10+48)
        // hi2csend(kmonth1%10+48)
        // hi2csend(32)
        // hi2csend(47)
        // hi2csend(32)
        // hi2csend(50)
        // hi2csend(48)
        // hi2csend(kyear1/10+48)
        // hi2csend(kyear1%10+48)
        // hi2csend(32)
        // hi2cstop
end sub

sub onetwoline 'initialize display
        // SL=0x7C 'DISPLAY ID
        // COMSEND=0x00 'display COMMAND send
        // DS=0X40      'display DATA send
        // chht=0x38 'two lines
        // hi2cStart
        // hi2cSEND(Sl)
        // hi2cSEND(Comsend)
        // hi2cSEND(chht) 'initialize 16x1or2
        // hi2cSEND(COMSEND)
        // hi2cSEND(chht+1) '16x1or2
        // hi2cSEND(0x10) 'osc set to slowest
        // hi2cSEND(0x77) 'contrast low byte=3 now 5 now 7
        // hi2cSEND(0x54) 'pwr booster on
        // hi2cSEND(0x6F) 'follower
        // hi2cSEND(0x0C) 'on/off
        // hi2cSEND(0x01) 'clear
        // hi2cstop
end sub



    'Supporting subroutines


    Function bgetc
        Dim local_next_out as Byte    'maintain a local copy of the next_out variable to ensure it does not change when an Interrupt happens
        local_next_out = next_out
        bgetc = buffer(local_next_out)
        local_next_out=(local_next_out+1) % BUFFER_SIZE
        INTOFF
        next_out = local_next_out
        INTON
    End Function


    Sub InitBufferRing

        'Set the buffer to the first address
        next_in = 0
        next_out = 0

    End Sub

    'Convert binary coded decimal to pure decimal
    function rtcc_BcdToDec(in va ) as byte
    rtcc_BcdToDec=( va /16)*10+ va %16
    end function
