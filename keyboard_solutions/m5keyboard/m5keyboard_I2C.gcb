/*
A demonstration program for GCGB and GCB.
--------------------------------------------------------------------------------
This program shows how to communicate with the M5Stack keyboard - see https://docs.m5stack.com/en/unit/cardkb_1.1


@author    Evan
@license   GPL
@version   1.00
@date      2022-08-15
********************************************************************************
*/
#chip 16f18855
#option Explicit

#define M5StackKeyBoard 0xBE 

//Generated by PIC PPS Tool for Great Cow Basic
//PPS Tool version: 0.0.5.2
//PinManager data: 09/02/2017

//Template comment at the start of the config file

#STARTUP InitPPS, 85

Sub InitPPS

    //Module: EUSART
    //TX > RC0
    RC0PPS = 0x0010
    //RC0 > TX (bi-directional)
    TXPPS = 0x0008

    #IF DEF(HI2C_DATA)
        //Module: MSSP1
        //RC3 > SDA1
        SSP1DATPPS = 0x0013
        //SDA1 > RC3 (bi-directional)
        RC3PPS = 0x0015
        //SCL1 > RC4
        RC4PPS = 0x0014
        //RC4 > SCL1 (bi-directional)
        SSP1CLKPPS = 0x0014
    #ENDIF

End Sub
//Template comment at the end of the config file


// ----- Define Hardware settings for USART
    #DEFINE USART_BAUD_RATE 19200
    #DEFINE USART_TX_BLOCKING
    #DEFINE USART_DELAY OFF

// ----- Define Hardware settings for HWI2C
    #DEFINE HI2C_BAUD_RATE 400       // Comment out for software I2C
    #DEFINE HI2C_DATA PORTC.3        // Comment out for software I2C
    #DEFINE HI2C_CLOCK PORTC.4       // Comment out for software I2C
        // Initialise I2C Master
        // HWI2C pins need to be input for SSP2 module
    Dir HI2C_DATA IN        // Comment out for software I2C
    DIR HI2C_CLOCK IN       // Comment out for software I2C
    HI2CMode Master        // Comment out for software I2C

// ----- Define Hardware configuration for software I2C
    // #DEFINE I2C_MODE Master                  // Comment out for hardware I2C
    // #DEFINE I2C_DATA PORTC.3                 // Comment out for hardware I2C
    // #DEFINE I2C_CLOCK PORTC.4                // Comment out for hardware I2C
    // #DEFINE I2C_DISABLE_INTERRUPTS On        // Comment out for hardware I2C

// ----- include mills()
    #include <millis.h>

    // declare working variables for millis()
    Dim CurMs, LstMs as word  
    LstMs = 0
    CurMs = 0


// Create the supporting variables for the ring buffer
    Dim next_in As Byte
    Dim next_out As Byte
    Dim syncbyte As Byte
    Dim temppnt As Byte

// Constants etc required for Buffer Ring
    #DEFINE BUFFER_SIZE 8
    #DEFINE bkbhit (next_in <> next_out)

// Define the Buffer
    Dim buffer( BUFFER_SIZE - 1 ) // We will use element 0 in the array as part of out buffer

// Call to init the buffer
    InitBufferRing

// Main loop
    
    Do
        // Get character(s) and send back to terminal 
        CurMs = millis()
          if CurMs - LstMs >= 1 then  // required Time has Elapsed
            readI2C
            LstMs = CurMs                   // And Record Toggle Time
          end if

        // Do we have data in the buffer?
        if bkbhit then

            // Send the next character in the buffer, exposed via the function `bgetc` back the terminal
            HSerSend bgetc

        end if

    Loop



// Supporting subroutines

    // Read the keyboard - supports either hardware or software  I2C
    // Places incoming data into __inchar variable, then, if not 0x00 put into the ring buffer
    Sub readI2C
        Dim _inchar

        #IF DEF(HI2C_DATA)
            // Use hardware I2C
            HI2CStart
            // Read Operation
            HI2CSend M5StackKeyBoard + 1  //read ops
            HI2CReceive ( _inchar , NACK )
            HI2CStop
        #ENDIF

        #IF DEF(I2C_DATA)
            // Use software I2C
            I2CStart
            I2CSend M5StackKeyBoard + 1  //read ops
            I2CReceive ( _inchar , NACK )
            I2CStop
        #ENDIF

        If _inchar <> 0 Then
            buffer(next_in) = _inchar
            temppnt = next_in
            next_in = ( next_in + 1 ) % BUFFER_SIZE
            If ( next_in = next_out ) Then  // buffer is full!!
                next_in = temppnt
            End If
        End If    

    End Sub

    // Pulls one char from the ring buffer
    Function bgetc
        Dim local_next_out as Byte    // maintain a local copy of the next_out variable to ensure it does not change when an Interrupt happens
        local_next_out = next_out
        bgetc = buffer(local_next_out)
        local_next_out=(local_next_out+1) % BUFFER_SIZE
        INTOFF
        next_out = local_next_out
        INTON
    End Function

    Sub InitBufferRing

        // Set the buffer to the first address
        next_in = 0
        next_out = 0

    End Sub



