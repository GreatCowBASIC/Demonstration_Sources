;Program compiled by Great Cow BASIC (1.00.00 2023-04-05 (Windows 64 bit) : Build 1228) for Microchip PIC-AS using FreeBASIC 1.07.1/2023-04-05 CRC29
;  See the GCBASIC forums at http://sourceforge.net/projects/gcbasic/forums,
;  Check the documentation and Help at http://gcbasic.sourceforge.net/help/,
;or, email:
;   evanvennn at users dot sourceforge dot net

;********************************************************************************


;Set up the assembler options (Chip type, clock source, other bits and pieces)
;PROCESSOR   16F1619
 PAGEWIDTH   180
 RADIX       DEC
 TITLE       "d:\GreatCowBASICGits\Demonstration_Sources.git\trunk\Vendor_Boards\Microchip-Curiosity_Low_Pin_Count_Demo_Board\GCBASIC_firmware_for_Microchip_Curiosity_board_16F1619.s"
 SUBTITLE    "04-06-2023"

; Reverse lookup file(s)
; C:\Program Files\Microchip\xc8\v2.41\pic\include\proc\pic16f1619.inc
; C:\Program Files\Microchip\xc8\v2.41\pic\dat\cfgmap\16f1619.cfgmap
; Alternative CONFIG file is to be found at C:\Program Files\Microchip\xc8\vX.YY\pic\dat\cfgdata as per Microchip support ticket #00730936 

;********************************************************************************

;********************************************************************************
;Explicit CONFIG
 CONFIG FCMEN=ON                                 ;C1 Reverselookup FCMEN = ON
 CONFIG CLKOUTEN=OFF                             ;C1 Reverselookup CLKOUTEN = OFF
 CONFIG CP=OFF                                   ;C1 Reverselookup CP = OFF
 CONFIG MCLRE=ON                                 ;C1 Reverselookup MCLRE = ON
 CONFIG FOSC=INTOSC                              ;C1 Reverselookup FOSC = INTOSC
 CONFIG LVP=ON                                   ;C1 Reverselookup LVP = ON
 CONFIG PLLEN=OFF                                ;C1 Reverselookup PLLEN = OFF
 CONFIG WRT=OFF                                  ;C1 Reverselookup WRT = OFF
 CONFIG WDTE=OFF                                 ;C1 Reverselookup WDTE = OFF
;Inferred CONFIG


;********************************************************************************
; The XC8 xc.inc include file.  This MUST be placed after the CONFIG statements.

 #include <xc.inc>

;********************************************************************************

;Set aside RAM memory locations for variables. All variables are global.
GLOBAL	ADCVALUEWORD
 ADCVALUEWORD                     EQU 32          ; 0X20
GLOBAL	ADCVALUEWORD_H
 ADCVALUEWORD_H                   EQU 33          ; 0X21
GLOBAL	ADREADPORT
 ADREADPORT                       EQU 34          ; 0X22
GLOBAL	CCPCONCACHE
 CCPCONCACHE                      EQU 35          ; 0X23
GLOBAL	DELAYTEMP
 DELAYTEMP                        EQU 112          ; 0X70
GLOBAL	DELAYTEMP2
 DELAYTEMP2                       EQU 113          ; 0X71
GLOBAL	PRX_TEMP
 PRX_TEMP                         EQU 36          ; 0X24
GLOBAL	PRX_TEMP_CACHE
 PRX_TEMP_CACHE                   EQU 40          ; 0X28
GLOBAL	PRX_TEMP_CACHE_E
 PRX_TEMP_CACHE_E                 EQU 43          ; 0X2B
GLOBAL	PRX_TEMP_CACHE_H
 PRX_TEMP_CACHE_H                 EQU 41          ; 0X29
GLOBAL	PRX_TEMP_CACHE_U
 PRX_TEMP_CACHE_U                 EQU 42          ; 0X2A
GLOBAL	PRX_TEMP_E
 PRX_TEMP_E                       EQU 39          ; 0X27
GLOBAL	PRX_TEMP_H
 PRX_TEMP_H                       EQU 37          ; 0X25
GLOBAL	PRX_TEMP_U
 PRX_TEMP_U                       EQU 38          ; 0X26
GLOBAL	PWMCHANNEL
 PWMCHANNEL                       EQU 44          ; 0X2C
GLOBAL	PWMDIRECTION
 PWMDIRECTION                     EQU 45          ; 0X2D
GLOBAL	PWMDIRECTION_H
 PWMDIRECTION_H                   EQU 46          ; 0X2E
GLOBAL	PWMDUTY
 PWMDUTY                          EQU 47          ; 0X2F
GLOBAL	PWMDUTYVALUE
 PWMDUTYVALUE                     EQU 49          ; 0X31
GLOBAL	PWMDUTY_H
 PWMDUTY_H                        EQU 48          ; 0X30
GLOBAL	PWMFREQ
 PWMFREQ                          EQU 50          ; 0X32
GLOBAL	PWMFREQOLD
 PWMFREQOLD                       EQU 52          ; 0X34
GLOBAL	PWMFREQ_H
 PWMFREQ_H                        EQU 51          ; 0X33
GLOBAL	PWMRESOLUTION
 PWMRESOLUTION                    EQU 53          ; 0X35
GLOBAL	PWMRESOLUTION_H
 PWMRESOLUTION_H                  EQU 54          ; 0X36
GLOBAL	PWMSETCOUNTER
 PWMSETCOUNTER                    EQU 55          ; 0X37
GLOBAL	PWMSETCOUNTER_H
 PWMSETCOUNTER_H                  EQU 56          ; 0X38
GLOBAL	PWMTIMEROLD
 PWMTIMEROLD                      EQU 57          ; 0X39
GLOBAL	READAD
 READAD                           EQU 58          ; 0X3A
GLOBAL	READAD10
 READAD10                         EQU 59          ; 0X3B
GLOBAL	READAD10_H
 READAD10_H                       EQU 60          ; 0X3C
GLOBAL	SAVEADCON0
 SAVEADCON0                       EQU 61          ; 0X3D
GLOBAL	SAVEANSELC
 SAVEANSELC                       EQU 62          ; 0X3E
GLOBAL	SAVELATC
 SAVELATC                         EQU 63          ; 0X3F
GLOBAL	SAVEODCONC
 SAVEODCONC                       EQU 64          ; 0X40
GLOBAL	SAVETRISC
 SAVETRISC                        EQU 65          ; 0X41
GLOBAL	SYSBYTETEMPA
 SYSBYTETEMPA                     EQU 117          ; 0X75
GLOBAL	SYSBYTETEMPB
 SYSBYTETEMPB                     EQU 121          ; 0X79
GLOBAL	SYSBYTETEMPX
 SYSBYTETEMPX                     EQU 112          ; 0X70
GLOBAL	SYSDIVLOOP
 SYSDIVLOOP                       EQU 116          ; 0X74
GLOBAL	SYSDIVMULTA
 SYSDIVMULTA                      EQU 119          ; 0X77
GLOBAL	SYSDIVMULTA_H
 SYSDIVMULTA_H                    EQU 120          ; 0X78
GLOBAL	SYSDIVMULTB
 SYSDIVMULTB                      EQU 123          ; 0X7B
GLOBAL	SYSDIVMULTB_H
 SYSDIVMULTB_H                    EQU 124          ; 0X7C
GLOBAL	SYSDIVMULTX
 SYSDIVMULTX                      EQU 114          ; 0X72
GLOBAL	SYSDIVMULTX_H
 SYSDIVMULTX_H                    EQU 115          ; 0X73
GLOBAL	SYSLONGDIVMULTA
 SYSLONGDIVMULTA                  EQU 66          ; 0X42
GLOBAL	SYSLONGDIVMULTA_E
 SYSLONGDIVMULTA_E                EQU 69          ; 0X45
GLOBAL	SYSLONGDIVMULTA_H
 SYSLONGDIVMULTA_H                EQU 67          ; 0X43
GLOBAL	SYSLONGDIVMULTA_U
 SYSLONGDIVMULTA_U                EQU 68          ; 0X44
GLOBAL	SYSLONGDIVMULTB
 SYSLONGDIVMULTB                  EQU 70          ; 0X46
GLOBAL	SYSLONGDIVMULTB_E
 SYSLONGDIVMULTB_E                EQU 73          ; 0X49
GLOBAL	SYSLONGDIVMULTB_H
 SYSLONGDIVMULTB_H                EQU 71          ; 0X47
GLOBAL	SYSLONGDIVMULTB_U
 SYSLONGDIVMULTB_U                EQU 72          ; 0X48
GLOBAL	SYSLONGDIVMULTX
 SYSLONGDIVMULTX                  EQU 74          ; 0X4A
GLOBAL	SYSLONGDIVMULTX_E
 SYSLONGDIVMULTX_E                EQU 77          ; 0X4D
GLOBAL	SYSLONGDIVMULTX_H
 SYSLONGDIVMULTX_H                EQU 75          ; 0X4B
GLOBAL	SYSLONGDIVMULTX_U
 SYSLONGDIVMULTX_U                EQU 76          ; 0X4C
GLOBAL	SYSLONGTEMPA
 SYSLONGTEMPA                     EQU 117          ; 0X75
GLOBAL	SYSLONGTEMPA_E
 SYSLONGTEMPA_E                   EQU 120          ; 0X78
GLOBAL	SYSLONGTEMPA_H
 SYSLONGTEMPA_H                   EQU 118          ; 0X76
GLOBAL	SYSLONGTEMPA_U
 SYSLONGTEMPA_U                   EQU 119          ; 0X77
GLOBAL	SYSLONGTEMPB
 SYSLONGTEMPB                     EQU 121          ; 0X79
GLOBAL	SYSLONGTEMPB_E
 SYSLONGTEMPB_E                   EQU 124          ; 0X7C
GLOBAL	SYSLONGTEMPB_H
 SYSLONGTEMPB_H                   EQU 122          ; 0X7A
GLOBAL	SYSLONGTEMPB_U
 SYSLONGTEMPB_U                   EQU 123          ; 0X7B
GLOBAL	SYSLONGTEMPX
 SYSLONGTEMPX                     EQU 112          ; 0X70
GLOBAL	SYSLONGTEMPX_E
 SYSLONGTEMPX_E                   EQU 115          ; 0X73
GLOBAL	SYSLONGTEMPX_H
 SYSLONGTEMPX_H                   EQU 113          ; 0X71
GLOBAL	SYSLONGTEMPX_U
 SYSLONGTEMPX_U                   EQU 114          ; 0X72
GLOBAL	SYSREPEATTEMP1
 SYSREPEATTEMP1                   EQU 78          ; 0X4E
GLOBAL	SYSTEMP1
 SYSTEMP1                         EQU 79          ; 0X4F
GLOBAL	SYSTEMP1_E
 SYSTEMP1_E                       EQU 82          ; 0X52
GLOBAL	SYSTEMP1_H
 SYSTEMP1_H                       EQU 80          ; 0X50
GLOBAL	SYSTEMP1_U
 SYSTEMP1_U                       EQU 81          ; 0X51
GLOBAL	SYSTEMP2
 SYSTEMP2                         EQU 83          ; 0X53
GLOBAL	SYSTEMP3
 SYSTEMP3                         EQU 84          ; 0X54
GLOBAL	SYSWAITTEMP10US
 SYSWAITTEMP10US                  EQU 117          ; 0X75
GLOBAL	SYSWAITTEMPMS
 SYSWAITTEMPMS                    EQU 114          ; 0X72
GLOBAL	SYSWAITTEMPMS_H
 SYSWAITTEMPMS_H                  EQU 115          ; 0X73
GLOBAL	SYSWAITTEMPS
 SYSWAITTEMPS                     EQU 116          ; 0X74
GLOBAL	SYSWAITTEMPUS
 SYSWAITTEMPUS                    EQU 117          ; 0X75
GLOBAL	SYSWAITTEMPUS_H
 SYSWAITTEMPUS_H                  EQU 118          ; 0X76
GLOBAL	SYSWORDTEMPA
 SYSWORDTEMPA                     EQU 117          ; 0X75
GLOBAL	SYSWORDTEMPA_H
 SYSWORDTEMPA_H                   EQU 118          ; 0X76
GLOBAL	SYSWORDTEMPB
 SYSWORDTEMPB                     EQU 121          ; 0X79
GLOBAL	SYSWORDTEMPB_H
 SYSWORDTEMPB_H                   EQU 122          ; 0X7A
GLOBAL	SYSWORDTEMPX
 SYSWORDTEMPX                     EQU 112          ; 0X70
GLOBAL	SYSWORDTEMPX_H
 SYSWORDTEMPX_H                   EQU 113          ; 0X71
GLOBAL	TIMERSELECTIONBITS
 TIMERSELECTIONBITS               EQU 85          ; 0X55
GLOBAL	TX_PR
 TX_PR                            EQU 86          ; 0X56
GLOBAL	_PWMTIMERSELECTED
 _PWMTIMERSELECTED                EQU 87          ; 0X57

;********************************************************************************

;ALIAS VARIABLES
GLOBAL	SYSREADAD10WORD
 SYSREADAD10WORD                  EQU 59
GLOBAL	SYSREADAD10WORD_H
 SYSREADAD10WORD_H                EQU 60
GLOBAL	SYSREADADBYTE
 SYSREADADBYTE                    EQU 58

;********************************************************************************

 PSECT   PROGMEM0,delta=2, abs
 RESETVEC:
;VECTORS
	ORG	0
	PAGESEL	BASPROGRAMSTART
	GOTO	BASPROGRAMSTART
	ORG	4
	RETFIE

;********************************************************************************

;START OF PROGRAM MEMORY PAGE 0
	ORG	5
GLOBAL	BASPROGRAMSTART
BASPROGRAMSTART:
;CALL INITIALISATION ROUTINES
	CALL	INITSYS
	CALL	INITPPS
	CALL	INITPWM

;START OF THE MAIN PROGRAM
;''A DEMONSTRATION PROGRAM FOR GCGB AND GCB.
;''--------------------------------------------------------------------------------
;'' THIS PROGRAM RECREATION OF MICROCHIP CURIOSITY FIRMWARE FOR THE 16F1619
;''
;'' BASED ON CVD_TOUCH_BUTTON_16F1619 BY TREVOR B ROYDHOUSE
;''
;'' MICROCHIP CURIOSITY 8/14/20 PIN 8 BIT DEMO BOARD
;''  O PIC16F1619 (HTTP://MICROCHIP.COM/PIC16F1619)
;''  O LEDS D4-D7 ON RA5, RA1/PGEC, RA2, RC5
;''  O SWITCH SWITCH1 ON RC4
;''  O SWITCH S2 ON RA3/MCLRE
;''  O TOUCH SWITCH S3 ON RC1/AN5
;''  O POTENTIOMETER POT1 ON RC0/AN4
;''
;'' AN IMPLEMENTATION OF MICROCHIP APPLICATION NOTE AN1298
;'' O  CAPACITIVE TOUCH USING ONLY AN ADC USING THE CONCEPT OF CAPACITIVE VOLTAGE DIVIDER ("CVD")
;'' O  HTTP://WW1.MICROCHIP.COM/DOWNLOADS/EN/APPNOTES/01298A.PDF
;''
;'' ON STARTUP LEDS D4-D7 TURN ON AND OFF
;'' LED D6 TURNS ON WHILE S3 TOUCH SENSOR IS TOUCHED
;'' LED D6 TURNS OFF WHEN S3 TOUCH SENSOR IS NOT TOUCHED
;'' LED D7 IS THE PWM SIGNAL
;'' LED D4 TURNS IN WHEN S1 IS PRESSED
;''
;''AUTHOR    EVAN R. VENN
;''LICENSE   GPL
;''VERSION   1.00
;''DATE      2023-04-02
;''********************************************************************************
;---- CONFIGURATION
;MICROCONTROLLER  32MHZ
;MCLRE SET ON SO THAT SWITCH S2 CAN RESET MICROCONTROLLER
;GENERATED BY PIC PPS TOOL FOR GREAT COW BASIC
;PPS TOOL VERSION: 0.0.6.3
;PINMANAGER DATA: NOT AVAILABLE (3)
;GENERATED FOR 16F1619
;
;TEMPLATE COMMENT AT THE START OF THE CONFIG FILE
;
;TEMPLATE COMMENT AT THE END OF THE CONFIG FILE
;ENSURE ALL VARIABLES ARE EXPLICITLY DEFINED
;---- DEFINE HARDWARE SETTINGS
;DIR SWITCH1 IN
	BANKSEL	TRISC
	BSF	TRISC,4
;DIR PORTA.5 OUT
	BCF	TRISA,5
;DIR PORTA.1 OUT
	BCF	TRISA,1
;DIR PORTA.2 OUT
	BCF	TRISA,2
;DIR PORTC.5 OUT
	BCF	TRISC,5
;DIR PORTC.0 IN
	BSF	TRISC,0
;STARTUP WAIT IN SECONDS
;---- VARIABLES
;DIM PWMSETCOUNTER AS WORD
;PWMSETCOUNTER = 0
	BANKSEL	PWMSETCOUNTER
	CLRF	PWMSETCOUNTER
	CLRF	PWMSETCOUNTER_H
;---- MAIN BODY OF PROGRAM
;LED INIT ON PROGRAM STARTUP
;WAIT WAITSECS S
	MOVLW	1
	MOVWF	SYSWAITTEMPS
	CALL	DELAY_S
;SET LED4 = 1
	BANKSEL	LATA
	BSF	LATA,5
;SET LED5 = 1
	BSF	LATA,1
;SET LED6 = 1
	BSF	LATA,2
;SET LED7 = 1
	BSF	LATC,5
;WAIT WAITSECS S
	MOVLW	1
	MOVWF	SYSWAITTEMPS
	BANKSEL	STATUS
	CALL	DELAY_S
;SET LED7 = 0
	BANKSEL	LATC
	BCF	LATC,5
;SET LED6 = 0
	BCF	LATA,2
;SET LED5 = 0
	BCF	LATA,1
;SET LED4 = 0
	BCF	LATA,5
;REQUIRED TO SUPPORT HPWMUPDATE WHEN USING PWM/CCPN MODULE
;PMW FREQENCY AND DUTY TO VALUE
;DIM PWMDUTYVALUE AS BYTE
;DIM PWMDIRECTION AS INTEGER
;PWMDIRECTION = 1
	MOVLW	1
	BANKSEL	PWMDIRECTION
	MOVWF	PWMDIRECTION
	CLRF	PWMDIRECTION_H
;PWMDUTYVALUE = 127
	MOVLW	127
	MOVWF	PWMDUTYVALUE
;PWM3 IS AN 8 BIT SIGNAL
;HPWM 3, 3, PWMDUTYVALUE, 2
	MOVLW	3
	MOVWF	PWMCHANNEL
	MOVLW	3
	MOVWF	PWMFREQ
	CLRF	PWMFREQ_H
	MOVF	PWMDUTYVALUE,W
	MOVWF	PWMDUTY
	CLRF	PWMDUTY_H
	MOVLW	2
	MOVWF	_PWMTIMERSELECTED
	MOVLW	255
	MOVWF	PWMRESOLUTION
	CLRF	PWMRESOLUTION_H
	CALL	HPWM27
;PROGRAM INFINITE LOOP
;DO FOREVER
GLOBAL	SYSDOLOOP_S1
SYSDOLOOP_S1:
;SET LED TO STATE OF SWITCH
;LED4 = !SWITCH1
	CLRF	SYSTEMP2
	BTFSC	PORTC,4
	INCF	SYSTEMP2,F
	COMF	SYSTEMP2,F
	BANKSEL	LATA
	BCF	LATA,5
	BANKSEL	SYSTEMP2
	BTFSS	SYSTEMP2,0
	GOTO	ENDIF4
	BANKSEL	LATA
	BSF	LATA,5
GLOBAL	ENDIF4
ENDIF4:
;IF PWMSETCOUNTER MOD 64 = 0 THEN
	BANKSEL	PWMSETCOUNTER
	MOVF	PWMSETCOUNTER,W
	MOVWF	SYSWORDTEMPA
	MOVF	PWMSETCOUNTER_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	64
	MOVWF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	CALL	SYSDIVSUB16
	MOVF	SYSWORDTEMPX,W
	MOVWF	SYSTEMP1
	MOVF	SYSWORDTEMPX_H,W
	MOVWF	SYSTEMP1_H
	MOVF	SYSTEMP1,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSTEMP1_H,W
	MOVWF	SYSWORDTEMPA_H
	CLRF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	CALL	SYSCOMPEQUAL16
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF1
;PMW DUTY CHANGE
;HPWMUPDATE 3, READAD ( AN4 )
	MOVLW	3
	MOVWF	PWMCHANNEL
	MOVLW	4
	MOVWF	ADREADPORT
	CALL	FN_READAD6
	MOVF	SYSREADADBYTE,W
	MOVWF	PWMDUTY
	CLRF	PWMDUTY_H
	CALL	HPWMUPDATE
;PWMDUTYVALUE
;CYCLE THE DUTY UP AND DOWN
;PWMDUTYVALUE = PWMDUTYVALUE + PWMDIRECTION
	MOVF	PWMDIRECTION,W
	ADDWF	PWMDUTYVALUE,F
;IF PWMDUTYVALUE = 255 THEN
	INCF	PWMDUTYVALUE,W
	BTFSS	STATUS,2
	GOTO	ELSE2_1
;PWMDIRECTION = -1
	MOVLW	255
	MOVWF	PWMDIRECTION
	MOVWF	PWMDIRECTION_H
;ELSE IF PWMDUTYVALUE = 0 THEN
	GOTO	ENDIF2
GLOBAL	ELSE2_1
ELSE2_1:
	MOVF	PWMDUTYVALUE,F
	BTFSS	STATUS,2
	GOTO	ENDIF2
;PWMDIRECTION = 1
	MOVLW	1
	MOVWF	PWMDIRECTION
	CLRF	PWMDIRECTION_H
;END IF
GLOBAL	ENDIF2
ENDIF2:
;END IF
GLOBAL	ENDIF1
ENDIF1:
;PWMSETCOUNTER++
	INCF	PWMSETCOUNTER,F
	BTFSC	STATUS,2
	INCF	PWMSETCOUNTER_H,F
;READ MTOUCH STATE
;READMTOUCH
	CALL	READMTOUCH
;LOOP
	GOTO	SYSDOLOOP_S1
GLOBAL	SYSDOLOOP_E1
SYSDOLOOP_E1:
;---- METHODS
;GCODE OPTIMISATION FILE - THIS WILL OPTIMISE ADC OPERATIONS BY DISABLING THE ADC OPERATIONS ON THE AD CHANNEL THAT IS SET TO FALSE
;TO ENABLE ADC OPERATIONS ON A SPECIFIC AD CHANNEL SET TO TRUE
;
;LEGACY CHIP CONSTANTS FOR ADC
;
;RECENT CHIP CONSTANTS FOR ADC
;GCODE OPTIMISATION FILE - THIS WILL OPTIMISE PWM OPERATIONS BY DISABLING THE PWM OPERATIONS ON THE PWM CHANNEL AND TIMER THAT IS SET TO FALSE
;TO ENABLE PWM AND TIMER OPERATIONS SET TO FALSE
;
;OPTIMISE CCP/PWM
;
;OPTIMISE PWM
;OPTIMISE TIMERS ASSOCIATED WITH PWM OPERATIONS
GLOBAL	BASPROGRAMEND
BASPROGRAMEND:
	SLEEP
	GOTO	BASPROGRAMEND

;********************************************************************************

;SOURCE: PWM.H (4566)
GLOBAL	CALCULATEDUTY
CALCULATEDUTY:
;DIM PRX_TEMP AS LONG
;DIM PWMDUTY AS WORD
;DIM PWMRESOLUTION AS WORD
;ASSUMES PRX_TEMP AND PWMDUTY ARE VALID
;PRX_TEMP = PWMDUTY  * ( PRX_TEMP + 1 )
	MOVLW	1
	ADDWF	PRX_TEMP,W
	MOVWF	SYSTEMP1
	MOVLW	0
	ADDWFC	PRX_TEMP_H,W
	MOVWF	SYSTEMP1_H
	MOVLW	0
	ADDWFC	PRX_TEMP_U,W
	MOVWF	SYSTEMP1_U
	MOVLW	0
	ADDWFC	PRX_TEMP_E,W
	MOVWF	SYSTEMP1_E
	MOVF	PWMDUTY,W
	MOVWF	SYSLONGTEMPA
	MOVF	PWMDUTY_H,W
	MOVWF	SYSLONGTEMPA_H
	CLRF	SYSLONGTEMPA_U
	CLRF	SYSLONGTEMPA_E
	MOVF	SYSTEMP1,W
	MOVWF	SYSLONGTEMPB
	MOVF	SYSTEMP1_H,W
	MOVWF	SYSLONGTEMPB_H
	MOVF	SYSTEMP1_U,W
	MOVWF	SYSLONGTEMPB_U
	MOVF	SYSTEMP1_E,W
	MOVWF	SYSLONGTEMPB_E
	CALL	SYSMULTSUB32
	MOVF	SYSLONGTEMPX,W
	MOVWF	PRX_TEMP
	MOVF	SYSLONGTEMPX_H,W
	MOVWF	PRX_TEMP_H
	MOVF	SYSLONGTEMPX_U,W
	MOVWF	PRX_TEMP_U
	MOVF	SYSLONGTEMPX_E,W
	MOVWF	PRX_TEMP_E
;SET C OFF
	BCF	STATUS,0
;REPEAT 2
	MOVLW	2
	MOVWF	SYSREPEATTEMP1
GLOBAL	SYSREPEATLOOP1
SYSREPEATLOOP1:
;ROTATE PRX_TEMP LEFT
	RLF	PRX_TEMP,F
	RLF	PRX_TEMP_H,F
	RLF	PRX_TEMP_U,F
	RLF	PRX_TEMP_E,F
;END REPEAT
	DECFSZ	SYSREPEATTEMP1,F
	GOTO	SYSREPEATLOOP1
GLOBAL	SYSREPEATLOOPEND1
SYSREPEATLOOPEND1:
;PRX_TEMP = PRX_TEMP / PWMRESOLUTION    'WHERE PWMRESOLUTION IS 255 OR 1023
	MOVF	PRX_TEMP,W
	MOVWF	SYSLONGTEMPA
	MOVF	PRX_TEMP_H,W
	MOVWF	SYSLONGTEMPA_H
	MOVF	PRX_TEMP_U,W
	MOVWF	SYSLONGTEMPA_U
	MOVF	PRX_TEMP_E,W
	MOVWF	SYSLONGTEMPA_E
	MOVF	PWMRESOLUTION,W
	MOVWF	SYSLONGTEMPB
	MOVF	PWMRESOLUTION_H,W
	MOVWF	SYSLONGTEMPB_H
	CLRF	SYSLONGTEMPB_U
	CLRF	SYSLONGTEMPB_E
	CALL	SYSDIVSUB32
	MOVF	SYSLONGTEMPA,W
	MOVWF	PRX_TEMP
	MOVF	SYSLONGTEMPA_H,W
	MOVWF	PRX_TEMP_H
	MOVF	SYSLONGTEMPA_U,W
	MOVWF	PRX_TEMP_U
	MOVF	SYSLONGTEMPA_E,W
	MOVWF	PRX_TEMP_E
;SET C OFF
	BCF	STATUS,0
;REPEAT 6
	MOVLW	6
	MOVWF	SYSREPEATTEMP1
GLOBAL	SYSREPEATLOOP2
SYSREPEATLOOP2:
;ROTATE PRX_TEMP LEFT
	RLF	PRX_TEMP,F
	RLF	PRX_TEMP_H,F
	RLF	PRX_TEMP_U,F
	RLF	PRX_TEMP_E,F
;END REPEAT
	DECFSZ	SYSREPEATTEMP1,F
	GOTO	SYSREPEATLOOP2
GLOBAL	SYSREPEATLOOPEND2
SYSREPEATLOOPEND2:
;EXITS WITH PRX_TEMP CALCULATED
	RETURN

;********************************************************************************

GLOBAL	DELAY_10US
DELAY_10US:
GLOBAL	D10US_START
D10US_START:
	MOVLW	25
	MOVWF	DELAYTEMP
GLOBAL	DELAYUS0
DELAYUS0:
	DECFSZ	DELAYTEMP,F
	GOTO	DELAYUS0
	NOP
	DECFSZ	SYSWAITTEMP10US, F
	GOTO	D10US_START
	RETURN

;********************************************************************************

GLOBAL	DELAY_MS
DELAY_MS:
	INCF	SYSWAITTEMPMS_H, F
GLOBAL	DMS_START
DMS_START:
	MOVLW	14
	MOVWF	DELAYTEMP2
GLOBAL	DMS_OUTER
DMS_OUTER:
	MOVLW	189
	MOVWF	DELAYTEMP
GLOBAL	DMS_INNER
DMS_INNER:
	DECFSZ	DELAYTEMP, F
	GOTO	DMS_INNER
	DECFSZ	DELAYTEMP2, F
	GOTO	DMS_OUTER
	DECFSZ	SYSWAITTEMPMS, F
	GOTO	DMS_START
	DECFSZ	SYSWAITTEMPMS_H, F
	GOTO	DMS_START
	RETURN

;********************************************************************************

GLOBAL	DELAY_S
DELAY_S:
GLOBAL	DS_START
DS_START:
	MOVLW	232
	MOVWF	SYSWAITTEMPMS
	MOVLW	3
	MOVWF	SYSWAITTEMPMS_H
	CALL	DELAY_MS
	DECFSZ	SYSWAITTEMPS, F
	GOTO	DS_START
	RETURN

;********************************************************************************

;OVERLOADED SIGNATURE: BYTE:WORD:BYTE:BYTE:WORD:, SOURCE: PWM.H (3368)
GLOBAL	HPWM27
HPWM27:
;DIM PWMDUTY AS WORD
;HPWM ( PWMCHANNEL, PWMFREQ, [WORD]PWMDUTY, _PWMTIMERSELECTED, PWMRESOLUTION  )
	GOTO	HPWM28

;********************************************************************************

;OVERLOADED SIGNATURE: BYTE:WORD:WORD:BYTE:WORD:, SOURCE: PWM.H (3375)
GLOBAL	HPWM28
HPWM28:
;DIM PRX_TEMP AS LONG
;DIM TIMERSELECTIONBITS AS BYTE
;IF HPWM_FAST OPERATION SELECTED, ONLY RECALCULATE DUTY TIMER PRESCALER WHEN
;NEEDED.
;IF ( PWMFREQ <> PWMFREQOLD )  OR ( _PWMTIMERSELECTED <> PWMTIMEROLD ) THEN
	MOVF	PWMFREQ,W
	MOVWF	SYSWORDTEMPA
	MOVF	PWMFREQ_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVF	PWMFREQOLD,W
	MOVWF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	CALL	SYSCOMPEQUAL16
	COMF	SYSBYTETEMPX,F
	MOVF	SYSBYTETEMPX,W
	MOVWF	SYSTEMP2
	MOVF	_PWMTIMERSELECTED,W
	MOVWF	SYSBYTETEMPA
	MOVF	PWMTIMEROLD,W
	MOVWF	SYSBYTETEMPB
	CALL	SYSCOMPEQUAL
	COMF	SYSBYTETEMPX,F
	MOVF	SYSBYTETEMPX,W
	MOVWF	SYSTEMP1
	MOVF	SYSTEMP2,W
	IORWF	SYSTEMP1,W
	MOVWF	SYSTEMP3
	BTFSS	SYSTEMP3,0
	GOTO	ELSE16_1
;COMMENCE CALCULATIONS OF PMW PARAMETERS
;THIS FIGURES OUT PRESCALER REQUIRED.  WE CAN SET TO 1, 4 OR 16 TO SET TX_PR
;SO, START WITH 1 - CHECK THE REMAINDER. IF THE REMAINDER IN THE HIGH BYTE IS GREATER THEN ZERO THEN DO SAME WITH A PRESCALER VALUE OF 4
;SO, USING 4 - CHECK THE REMAINDER. IF THE REMAINDER IN THE HIGH BYTE IS GREATER THEN ZERO THEN DO SAME WITH A PRESCALER VALUE OF 16
;SO, USING 16
;THIS SIMPLY SETS UP TX_PR TO 1,4 OR 16
;PRX_TEMP  = PWMOSC1 / PWMFREQ
	MOVLW	64
	MOVWF	SYSLONGTEMPA
	MOVLW	31
	MOVWF	SYSLONGTEMPA_H
	CLRF	SYSLONGTEMPA_U
	CLRF	SYSLONGTEMPA_E
	MOVF	PWMFREQ,W
	MOVWF	SYSLONGTEMPB
	MOVF	PWMFREQ_H,W
	MOVWF	SYSLONGTEMPB_H
	CLRF	SYSLONGTEMPB_U
	CLRF	SYSLONGTEMPB_E
	CALL	SYSDIVSUB32
	MOVF	SYSLONGTEMPA,W
	MOVWF	PRX_TEMP
	MOVF	SYSLONGTEMPA_H,W
	MOVWF	PRX_TEMP_H
	MOVF	SYSLONGTEMPA_U,W
	MOVWF	PRX_TEMP_U
	MOVF	SYSLONGTEMPA_E,W
	MOVWF	PRX_TEMP_E
;TX_PR = 1
	MOVLW	1
	MOVWF	TX_PR
;IF PRX_TEMP_H > 0 THEN
	MOVF	PRX_TEMP_H,W
	SUBLW	0
	BTFSC	STATUS,0
	GOTO	ENDIF18
;TX_PR = 4
	MOVLW	4
	MOVWF	TX_PR
;DIVIDE BY 4
;SET STATUS.C OFF
	BCF	STATUS,0
;ROTATE PRX_TEMP RIGHT
	RRF	PRX_TEMP_E,F
	RRF	PRX_TEMP_U,F
	RRF	PRX_TEMP_H,F
	RRF	PRX_TEMP,F
;SET STATUS.C OFF
	BCF	STATUS,0
;ROTATE PRX_TEMP RIGHT
	RRF	PRX_TEMP_E,F
	RRF	PRX_TEMP_U,F
	RRF	PRX_TEMP_H,F
	RRF	PRX_TEMP,F
;END IF
GLOBAL	ENDIF18
ENDIF18:
;IF PRX_TEMP_H > 0 THEN
	MOVF	PRX_TEMP_H,W
	SUBLW	0
	BTFSC	STATUS,0
	GOTO	ENDIF19
;TX_PR = 16
	MOVLW	16
	MOVWF	TX_PR
;DIVIDE BY 4
;SET STATUS.C OFF
	BCF	STATUS,0
;ROTATE PRX_TEMP RIGHT
	RRF	PRX_TEMP_E,F
	RRF	PRX_TEMP_U,F
	RRF	PRX_TEMP_H,F
	RRF	PRX_TEMP,F
;SET STATUS.C OFF
	BCF	STATUS,0
;ROTATE PRX_TEMP RIGHT
	RRF	PRX_TEMP_E,F
	RRF	PRX_TEMP_U,F
	RRF	PRX_TEMP_H,F
	RRF	PRX_TEMP,F
;END IF
GLOBAL	ENDIF19
ENDIF19:
;IF PRX_TEMP_H > 0 THEN
	MOVF	PRX_TEMP_H,W
	SUBLW	0
	BTFSC	STATUS,0
	GOTO	ENDIF20
;TX_PR = 64
	MOVLW	64
	MOVWF	TX_PR
;DIVIDE BY 4
;SET STATUS.C OFF
	BCF	STATUS,0
;ROTATE PRX_TEMP RIGHT
	RRF	PRX_TEMP_E,F
	RRF	PRX_TEMP_U,F
	RRF	PRX_TEMP_H,F
	RRF	PRX_TEMP,F
;SET STATUS.C OFF
	BCF	STATUS,0
;ROTATE PRX_TEMP RIGHT
	RRF	PRX_TEMP_E,F
	RRF	PRX_TEMP_U,F
	RRF	PRX_TEMP_H,F
	RRF	PRX_TEMP,F
;END IF
GLOBAL	ENDIF20
ENDIF20:
;THIS SECTION SETUPS THE TIMER
;SET UP PRX DEPENDENT ON TIMER SELECTED
;SELECT CASE _PWMTIMERSELECTED
;CASE 2 'SELECT TIMER2 AS THE DRIVER FOR PWM
GLOBAL	SYSSELECT3CASE1
SYSSELECT3CASE1:
	MOVLW	2
	SUBWF	_PWMTIMERSELECTED,W
	BTFSS	STATUS,2
	GOTO	SYSSELECTEND3
	;SET	T2PR
;PR2 = PRX_TEMP  'THIS IS REQUIRED IN THE NEXT SCTION OF CODE, AND AS WILL NOT KNOW WHICH TIMER HAS BEEN SELECTED
	MOVF	PRX_TEMP,W
	MOVWF	T2PR
;SET CLOCK SOURCE, IF REQUIRED
;SET TO FOSC/4 FOR BACKWARD COMPATIBILITY2D WHERE CS<3:0> = 0000 = FOSC/4
;T2CLKCON.T2CS0 = 0
	BCF	T2CLKCON,0
;T2CLKCON.T2CS1 = 0
	BCF	T2CLKCON,1
;T2CLKCON.T2CS2 = 0
	BCF	T2CLKCON,2
;T2CLKCON.T2CS3 = 0
	BCF	T2CLKCON,3
;T2PSYNC NOT SYNCHRONIZED; T2MODE SOFTWARE CONTROL; T2CKPOL RISING EDGE; T2CKSYNC NOT SYNCHRONIZED
;T2HLT = 0X00
;#IFDEF VAR(T2HLT): T2HLT = 0X00: #ENDIF
	CLRF	T2HLT
;T2RSEL T2CKIPPS PIN
;T2RST = 0X00
;#IFDEF VAR(T2RST): T2RST = 0X00: #ENDIF
	CLRF	T2RST
;TMR2.  HOLDING REGISTER FOR THE 8-BIT TMR2 REGISTER
;T2TMR = 0X00
;#IFDEF VAR(T2TMR): T2TMR = 0X00: #ENDIF
	CLRF	T2TMR
;SETUP TIMERX BY CLEARING THE PRESCALER BITS - IT IS SET NEXT....
;SET T2CKPS0 OFF
	BCF	T2CON,4
;SET T2CKPS1 OFF
	BCF	T2CON,5
;SET T2CKPS2 OFF
	BCF	T2CON,6
;SET PRESCALER BITS T2CON 3
;IF TX_PR = 4  THEN SET T2CKPS1 ON
	MOVLW	4
	SUBWF	TX_PR,W
	BTFSC	STATUS,2
;IF TX_PR = 4  THEN SET T2CKPS1 ON
	BSF	T2CON,5
;IF TX_PR = 4  THEN SET T2CKPS1 ON
;IF TX_PR = 16 THEN SET T2CKPS2 ON
	MOVLW	16
	SUBWF	TX_PR,W
	BTFSC	STATUS,2
;IF TX_PR = 16 THEN SET T2CKPS2 ON
	BSF	T2CON,6
;IF TX_PR = 16 THEN SET T2CKPS2 ON
;IF TX_PR = 64 THEN SET T2CKPS2 ON: SET T2CKPS1 ON
	MOVLW	64
	SUBWF	TX_PR,W
	BTFSS	STATUS,2
	GOTO	ENDIF23
;IF TX_PR = 64 THEN SET T2CKPS2 ON: SET T2CKPS1 ON
	BSF	T2CON,6
;IF TX_PR = 64 THEN SET T2CKPS2 ON: SET T2CKPS1 ON
	BSF	T2CON,5
;IF TX_PR = 64 THEN SET T2CKPS2 ON: SET T2CKPS1 ON
GLOBAL	ENDIF23
ENDIF23:
;CLEARING IF FLAG.
;SET TMR2IF OFF
	BCF	PIR1,1
;START TIMER2
;SET TMR2ON ON
	BSF	T2CON,7
;END SELECT
GLOBAL	SYSSELECTEND3
SYSSELECTEND3:
;PWMFREQOLD = PWMFREQ
	MOVF	PWMFREQ,W
	MOVWF	PWMFREQOLD
;PWMTIMEROLD = _PWMTIMERSELECTED
	MOVF	_PWMTIMERSELECTED,W
	MOVWF	PWMTIMEROLD
;CACHE THE PRX_TEMP TO SUPPORT HPWM_FAST.
;PRX_TEMP_CACHE = PRX_TEMP
	MOVF	PRX_TEMP,W
	MOVWF	PRX_TEMP_CACHE
	MOVF	PRX_TEMP_H,W
	MOVWF	PRX_TEMP_CACHE_H
	MOVF	PRX_TEMP_U,W
	MOVWF	PRX_TEMP_CACHE_U
	MOVF	PRX_TEMP_E,W
	MOVWF	PRX_TEMP_CACHE_E
;ELSE
	GOTO	ENDIF16
GLOBAL	ELSE16_1
ELSE16_1:
;AS WIERD AS THIS LOOKS.... RESTORE THE CACHE TO PRX_TEMP AS WE NEED IT WHEN IN HPWM_FAST MODE
;PRX_TEMP IS USED IN CHANNEL SETTING SECTION, SO, IF WE DID NOT RESTORE WE WOULD NOT HAVE A CONSISTENT SET OF INFORMATION.
;PRX_TEMP = PRX_TEMP_CACHE
	MOVF	PRX_TEMP_CACHE,W
	MOVWF	PRX_TEMP
	MOVF	PRX_TEMP_CACHE_H,W
	MOVWF	PRX_TEMP_H
	MOVF	PRX_TEMP_CACHE_U,W
	MOVWF	PRX_TEMP_U
	MOVF	PRX_TEMP_CACHE_E,W
	MOVWF	PRX_TEMP_E
;END IF
GLOBAL	ENDIF16
ENDIF16:
GLOBAL	TENBITPMWSECTION
TENBITPMWSECTION:
;THIS SECTION SETUPS UP THE PWM DUTY
;THE FOLLOWING CODE CAN BE OPTIMISED VIA 'DEFINES'
;DIM PRX_TEMP_CACHE AS LONG
;CACHE THE PRX_TEMP VALUE ONLY WHEN NOT HPWM_FAST - THIS CAN BE THEN USED BY HPWMUPDATE
;IF PWMCHANNEL = 3 THEN  'IN SECTION USE_HPWM3
	MOVLW	3
	SUBWF	PWMCHANNEL,W
	BTFSS	STATUS,2
	GOTO	ENDIF17
;CALCULATES DUTY, ASSISGNS DUTY TO  BITS 15-8 AND 7-6 OF PMWXDH(H&L) AND LINKS THIS PWM TO THE CORRECT TIMER
;CALCULATEDUTY 'SETS PRX_TEMP  TO THE DUTY VALUE FOR BITS 15-8 AND 7-6
	CALL	CALCULATEDUTY
;PWM3DCH = PRX_TEMP_H
	MOVF	PRX_TEMP_H,W
	BANKSEL	PWM3DCH
	MOVWF	PWM3DCH
;PWM3DCL = PRX_TEMP
	BANKSEL	PRX_TEMP
	MOVF	PRX_TEMP,W
	BANKSEL	PWM3DCL
	MOVWF	PWM3DCL
;SELECT TIMER BY UPDATING CCPTMRS REGISTER
;TIMERSELECTIONBITS =  (_PWMTIMERSELECTED / 2 )-1 'THIS IS A CHIPPWMTIMERVARIANT CHIP.  MOVE THE TIMER BITS TO THE LEFT BY ONE BIT TO CATER FOR DIFFERENT ADDRESSING
	BCF	STATUS,0
	BANKSEL	_PWMTIMERSELECTED
	RRF	_PWMTIMERSELECTED,W
	MOVWF	SYSTEMP2
	DECF	SYSTEMP2,W
	MOVWF	TIMERSELECTIONBITS
;SETWITH ( P3TSEL0, TIMERSELECTIONBITS.0 )
;MACRO SOURCE: STDBASIC.H (370)
;IF SOURCE THEN
	BTFSS	TIMERSELECTIONBITS,0
	GOTO	ELSE24_1
;TARGETBIT = 1
	BANKSEL	CCPTMRS
	BSF	CCPTMRS,4
;ELSE
	GOTO	ENDIF24
GLOBAL	ELSE24_1
ELSE24_1:
;TARGETBIT = 0
	BANKSEL	CCPTMRS
	BCF	CCPTMRS,4
;END IF
GLOBAL	ENDIF24
ENDIF24:
;SETWITH ( P3TSEL1, TIMERSELECTIONBITS.1 )
;MACRO SOURCE: STDBASIC.H (370)
;IF SOURCE THEN
	BANKSEL	TIMERSELECTIONBITS
	BTFSS	TIMERSELECTIONBITS,1
	GOTO	ELSE25_1
;TARGETBIT = 1
	BANKSEL	CCPTMRS
	BSF	CCPTMRS,5
;ELSE
	GOTO	ENDIF25
GLOBAL	ELSE25_1
ELSE25_1:
;TARGETBIT = 0
	BANKSEL	CCPTMRS
	BCF	CCPTMRS,5
;END IF
GLOBAL	ENDIF25
ENDIF25:
;START PMW3
;SET PWM3EN ON
	BANKSEL	PWM3CON
	BSF	PWM3CON,7
;END IF
GLOBAL	ENDIF17
ENDIF17:
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: PWM.H (4076)
GLOBAL	HPWMUPDATE
HPWMUPDATE:
;THE FOLLOWING CODE CAN BE OPTIMISED VIA 'DEFINES'
;DIM PRX_TEMP AS LONG
;DIM PWMDUTY AS WORD
;DIM PWMRESOLUTION AS WORD
;RESTORE THE CACHE VALUE
;PRX_TEMP = PRX_TEMP_CACHE
	MOVF	PRX_TEMP_CACHE,W
	MOVWF	PRX_TEMP
	CLRF	PRX_TEMP_H
	CLRF	PRX_TEMP_U
	CLRF	PRX_TEMP_E
GLOBAL	PWMUPDATE_HARDWAREMODEPWM1
PWMUPDATE_HARDWAREMODEPWM1:
GLOBAL	PWMUPDATE_HARDWAREMODEPWM3
PWMUPDATE_HARDWAREMODEPWM3:
;IF PWMCHANNEL = 3 THEN  'IN SECTION USE_HPWM3
	MOVLW	3
	SUBWF	PWMCHANNEL,W
	BTFSS	STATUS,2
	GOTO	ENDIF26
;CALCULATES DUTY, ASSISGNS DUTY TO  BITS 15-8 AND 7-6 OF PMWXDH(H&L) AND LINKS THIS PWM TO THE CORRECT TIMER
;CALCULATEDUTY 'SETS PRX_TEMP  TO THE DUTY VALUE FOR BITS 15-8 AND 7-6
	CALL	CALCULATEDUTY
;ASSUMES PRX_TEMP AND PWMDUTY ARE VALID
;PWM3DCH = PRX_TEMP_H
	MOVF	PRX_TEMP_H,W
	BANKSEL	PWM3DCH
	MOVWF	PWM3DCH
;PWM3DCL = PRX_TEMP
	BANKSEL	PRX_TEMP
	MOVF	PRX_TEMP,W
	BANKSEL	PWM3DCL
	MOVWF	PWM3DCL
;SET PWM3EN ON
	BSF	PWM3CON,7
;END IF
GLOBAL	ENDIF26
ENDIF26:
GLOBAL	PWMUPDATE_CCPMODE
PWMUPDATE_CCPMODE:
GLOBAL	PWMUPDATE_HARDWAREMODEPWMCCP1
PWMUPDATE_HARDWAREMODEPWMCCP1:
;IFDEF BIT(CCPR1L) TESTING THIS BIT IS TO IDENTIFY THE USE OF CCPR1L FOR PWM
;IF PWMCHANNEL = 1 THEN  'IN SECTION USE_HPWMCCP1
	BANKSEL	PWMCHANNEL
	DECF	PWMCHANNEL,W
	BTFSS	STATUS,2
	GOTO	ENDIF27
;ASSUME MORE THAT ONE CCP
;IFDEF BIT(CCP1FMT) TESTING THIS BIT IS TO IDENTIFY THE USE OF CCPR1H AND CCPR1L FOR PWM
;CALCULATEDUTY 'SETS PRX_TEMP  TO THE DUTY VALUE FOR BITS 15-8 AND 7-6
	CALL	CALCULATEDUTY
;CCPR1H = PRX_TEMP_H
	MOVF	PRX_TEMP_H,W
	BANKSEL	CCPR1H
	MOVWF	CCPR1H
;CCPR1L = PRX_TEMP
	BANKSEL	PRX_TEMP
	MOVF	PRX_TEMP,W
	BANKSEL	CCPR1L
	MOVWF	CCPR1L
;END IF
GLOBAL	ENDIF27
ENDIF27:
GLOBAL	PWMUPDATE_HARDWAREMODEPWMCCP3
PWMUPDATE_HARDWAREMODEPWMCCP3:
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: GCBASIC_FIRMWARE_FOR_MICROCHIP_CURIOSITY_BOARD_16F1619.GCB (49)
GLOBAL	INITPPS
INITPPS:
;MODULE: PWM3
;RC5PPS = 0X000E    'PWM3OUT > RC5
	MOVLW	14
	BANKSEL	RC5PPS
	MOVWF	RC5PPS
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: PWM.H (253)
GLOBAL	INITPWM
INITPWM:
;_PWMTIMERSELECTED = 2
	MOVLW	2
	MOVWF	_PWMTIMERSELECTED
;DIM PRX_TEMP AS LONG
GLOBAL	LEGACY_STARTOFFIXEDCCPPWMMODECODE
LEGACY_STARTOFFIXEDCCPPWMMODECODE:
;DIM CCPCONCACHE AS BYTE
;CCPCONCACHE = 0
	CLRF	CCPCONCACHE
;SET PWM PERIOD
;PR2 = PR2_CPP_PWM_TEMP
	MOVLW	210
	MOVWF	T2PR
;SET T2CON.T2CKPS0 OFF
	BCF	T2CON,4
;SET T2CON.T2CKPS1 OFF
	BCF	T2CON,5
;SET T2CON.T2CKPS2 OFF
	BCF	T2CON,6
;SET DUTY CYCLE
;CCPCONCACHE.CCP1FMT = 1
	BSF	CCPCONCACHE,4
;CCPR1H = DUTYCYCLEH
	MOVLW	105
	BANKSEL	CCPR1H
	MOVWF	CCPR1H
;CCPR1L = DUTYCYCLEL*64
	MOVLW	128
	MOVWF	CCPR1L
;[CANSKIP]T2CLKCON = 1
	MOVLW	1
	BANKSEL	T2CLKCON
	MOVWF	T2CLKCON
;[CANSKIP]CCPCONCACHE.EN = 1
	BSF	CCPCONCACHE,7
;LEGACY CODE, REPLACED BY CANSKIP
;FINISH PREPARING CCP*CON
;SET CCPCONCACHE.CCP1M3 ON
;SET CCPCONCACHE.CCP1M2 ON
;SET CCPCONCACHE.CCP1M1 OFF
;SET CCPCONCACHE.CCP1M0 OFF'
;CCPCONCACHE.CCP1M3, CCPCONCACHE.CCP1M2, CCPCONCACHE.CCP1M1, CCPCONCACHE.CCP1M0 = B'1100'
	BSF	CCPCONCACHE,3
	BSF	CCPCONCACHE,2
	BCF	CCPCONCACHE,1
	BCF	CCPCONCACHE,0
;ENABLE TIMER 2
;SET T2CON.TMR2ON ON
	BSF	T2CON,7
;PWMFREQOLD = 0
	CLRF	PWMFREQOLD
;PWMTIMEROLD = 0
	CLRF	PWMTIMEROLD
GLOBAL	STARTOFFIXEDPWMMODECODE
STARTOFFIXEDPWMMODECODE:
GLOBAL	SETPWMDUTYCODE
SETPWMDUTYCODE:
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (162)
GLOBAL	INITSYS
INITSYS:
;ASM SHOWDEBUG THIS CODE BLOCK SETS THE INTERNAL OSCILLATOR TO CHIPMHZ
;ASM SHOWDEBUG OSCCON TYPE IS 105 'BIT(SPLLEN) OR BIT(IRCF3) AND NOBIT(INTSRC) AND IFDEF BIT(IRCF3)
;EQUATES TO OSCCON = OSCCON AND B'10000111' & OSCCON = OSCCON OR B'11110000'
;= 32MHZ
;SET IRCF3 ON
	BANKSEL	OSCCON
	BSF	OSCCON,6
;SET IRCF2 ON
	BSF	OSCCON,5
;SET IRCF1 ON
	BSF	OSCCON,4
;SET IRCF0 OFF
	BCF	OSCCON,3
;SET SPLLEN ON
	BSF	OSCCON,7
;ASM SHOWDEBUG _COMPLETE_THE_CHIP_SETUP_OF_BSR,ADCS,ANSEL_AND_OTHER_KEY_SETUP_REGISTERS_OR_REGISTER_BITS
;ENSURE ALL PORTS ARE SET FOR DIGITAL I/O AND, TURN OFF A/D
;SET ADFM OFF
	BCF	ADCON1,7
;SWITCH OFF A/D VAR(ADCON0)
;SET ADCON0.ADON OFF
	BCF	ADCON0,0
;ANSELA = 0
	BANKSEL	ANSELA
	CLRF	ANSELA
;ANSELB = 0
	CLRF	ANSELB
;ANSELC = 0
	CLRF	ANSELC
;SET COMPARATOR REGISTER BITS FOR MANY MCUS WITH REGISTER CM2CON0
;C2ON = 0
	BANKSEL	CM2CON0
	BCF	CM2CON0,7
;C1ON = 0
	BCF	CM1CON0,7
;
;'TURN OFF ALL PORTS
;PORTA = 0
	BANKSEL	PORTA
	CLRF	PORTA
;PORTB = 0
	CLRF	PORTB
;PORTC = 0
	CLRF	PORTC
	RETURN

;********************************************************************************

;OVERLOADED SIGNATURE: BYTE:, SOURCE: A-D.H (2101)
GLOBAL	FN_READAD6
FN_READAD6:
;ADFM SHOULD CONFIGURED TO ENSURE LEFT JUSTIFIED
;SET ADFM OFF
	BANKSEL	ADCON1
	BCF	ADCON1,7
;***************************************
;PERFORM CONVERSION
;LLREADAD 1
;MACRO SOURCE: A-D.H (577)
;HANDLE DEVICES WITH NO ANSEL0 AND NO ANSEL
;CODE FOR DEVICES WITH ANSELA/ANSELB/ANSELE REGISTERS
;SELECT CASE ADREADPORT ' #IFDEF VAR(ANSELA). ANSELA EXISTS DEBUGADC_H
;CHIPPINS = 20
;#IFNDEF BIT(CHS5)
;CASE 2: SET ANSELA.2 ON
GLOBAL	SYSSELECT1CASE1
SYSSELECT1CASE1:
	MOVLW	2
	BANKSEL	ADREADPORT
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT1CASE2
;CASE 2: SET ANSELA.2 ON
	BANKSEL	ANSELA
	BSF	ANSELA,2
;CASE 4: SET ANSELC.0 ON
	GOTO	SYSSELECTEND1
GLOBAL	SYSSELECT1CASE2
SYSSELECT1CASE2:
	MOVLW	4
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECTEND1
;CASE 4: SET ANSELC.0 ON
	BANKSEL	ANSELC
	BSF	ANSELC,0
;END SELECT  'END SELECT #1
GLOBAL	SYSSELECTEND1
SYSSELECTEND1:
;SET ADCS2 OFF
	BANKSEL	ADCON1
	BCF	ADCON1,6
;SET ADCS1 OFF
	BCF	ADCON1,5
;SET ADCS0 ON
	BSF	ADCON1,4
;CHOOSE PORT
;SET CHS0 OFF
	BCF	ADCON0,2
;SET CHS1 OFF
	BCF	ADCON0,3
;SET CHS2 OFF
	BCF	ADCON0,4
;SET CHS3 OFF
	BCF	ADCON0,5
;SET CHS4 OFF
	BCF	ADCON0,6
;IF ADREADPORT.0 ON THEN SET CHS0 ON
	BANKSEL	ADREADPORT
	BTFSS	ADREADPORT,0
	GOTO	ENDIF6
;IF ADREADPORT.0 ON THEN SET CHS0 ON
	BANKSEL	ADCON0
	BSF	ADCON0,2
;IF ADREADPORT.0 ON THEN SET CHS0 ON
GLOBAL	ENDIF6
ENDIF6:
;IF ADREADPORT.1 ON THEN SET CHS1 ON
	BANKSEL	ADREADPORT
	BTFSS	ADREADPORT,1
	GOTO	ENDIF7
;IF ADREADPORT.1 ON THEN SET CHS1 ON
	BANKSEL	ADCON0
	BSF	ADCON0,3
;IF ADREADPORT.1 ON THEN SET CHS1 ON
GLOBAL	ENDIF7
ENDIF7:
;IF ADREADPORT.2 ON THEN SET CHS2 ON
	BANKSEL	ADREADPORT
	BTFSS	ADREADPORT,2
	GOTO	ENDIF8
;IF ADREADPORT.2 ON THEN SET CHS2 ON
	BANKSEL	ADCON0
	BSF	ADCON0,4
;IF ADREADPORT.2 ON THEN SET CHS2 ON
GLOBAL	ENDIF8
ENDIF8:
;IF ADREADPORT.3 ON THEN SET CHS3 ON
	BANKSEL	ADREADPORT
	BTFSS	ADREADPORT,3
	GOTO	ENDIF9
;IF ADREADPORT.3 ON THEN SET CHS3 ON
	BANKSEL	ADCON0
	BSF	ADCON0,5
;IF ADREADPORT.3 ON THEN SET CHS3 ON
GLOBAL	ENDIF9
ENDIF9:
;IF ADREADPORT.4 ON THEN SET CHS4 ON
	BANKSEL	ADREADPORT
	BTFSS	ADREADPORT,4
	GOTO	ENDIF10
;IF ADREADPORT.4 ON THEN SET CHS4 ON
	BANKSEL	ADCON0
	BSF	ADCON0,6
;IF ADREADPORT.4 ON THEN SET CHS4 ON
GLOBAL	ENDIF10
ENDIF10:
;ENABLE AD OPERATIONS
;SET ADON ON
	BANKSEL	ADCON0
	BSF	ADCON0,0
;ACQUISITION DELAY
;WAIT AD_DELAY
	MOVLW	2
	MOVWF	SYSWAITTEMP10US
	BANKSEL	STATUS
	CALL	DELAY_10US
;READ A/D 1
;SET GO_NOT_DONE ON
	BANKSEL	ADCON0
	BSF	ADCON0,1
;NOP
	NOP
;WAIT WHILE GO_NOT_DONE ON
GLOBAL	SYSWAITLOOP2
SYSWAITLOOP2:
	BTFSC	ADCON0,1
	GOTO	SYSWAITLOOP2
;SWITCH OFF A/D
;SET ADCON0.ADON OFF
	BCF	ADCON0,0
;ANSELA = 0
	BANKSEL	ANSELA
	CLRF	ANSELA
;ANSELB = 0
	CLRF	ANSELB
;ANSELC = 0
	CLRF	ANSELC
;READAD = ADRESH
	BANKSEL	ADRESH
	MOVF	ADRESH,W
	BANKSEL	READAD
	MOVWF	READAD
;SET ADFM OFF
	BANKSEL	ADCON1
	BCF	ADCON1,7
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;OVERLOADED SIGNATURE: BYTE:, SOURCE: A-D.H (2388)
GLOBAL	FN_READAD108
FN_READAD108:
;ALWAYS RIGHT JUSTIFIED
;SET ADFM ON
	BANKSEL	ADCON1
	BSF	ADCON1,7
;DO CONVERSION
;LLREADAD 0
;MACRO SOURCE: A-D.H (577)
;HANDLE DEVICES WITH NO ANSEL0 AND NO ANSEL
;CODE FOR DEVICES WITH ANSELA/ANSELB/ANSELE REGISTERS
;SELECT CASE ADREADPORT ' #IFDEF VAR(ANSELA). ANSELA EXISTS DEBUGADC_H
;CHIPPINS = 20
;#IFNDEF BIT(CHS5)
;CASE 2: SET ANSELA.2 ON
GLOBAL	SYSSELECT2CASE1
SYSSELECT2CASE1:
	MOVLW	2
	BANKSEL	ADREADPORT
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE2
;CASE 2: SET ANSELA.2 ON
	BANKSEL	ANSELA
	BSF	ANSELA,2
;CASE 4: SET ANSELC.0 ON
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE2
SYSSELECT2CASE2:
	MOVLW	4
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECTEND2
;CASE 4: SET ANSELC.0 ON
	BANKSEL	ANSELC
	BSF	ANSELC,0
;END SELECT  'END SELECT #1
GLOBAL	SYSSELECTEND2
SYSSELECTEND2:
;SET ADCS2 OFF
	BANKSEL	ADCON1
	BCF	ADCON1,6
;SET ADCS1 OFF
	BCF	ADCON1,5
;SET ADCS0 ON
	BSF	ADCON1,4
;CHOOSE PORT
;SET CHS0 OFF
	BCF	ADCON0,2
;SET CHS1 OFF
	BCF	ADCON0,3
;SET CHS2 OFF
	BCF	ADCON0,4
;SET CHS3 OFF
	BCF	ADCON0,5
;SET CHS4 OFF
	BCF	ADCON0,6
;IF ADREADPORT.0 ON THEN SET CHS0 ON
	BANKSEL	ADREADPORT
	BTFSS	ADREADPORT,0
	GOTO	ENDIF11
;IF ADREADPORT.0 ON THEN SET CHS0 ON
	BANKSEL	ADCON0
	BSF	ADCON0,2
;IF ADREADPORT.0 ON THEN SET CHS0 ON
GLOBAL	ENDIF11
ENDIF11:
;IF ADREADPORT.1 ON THEN SET CHS1 ON
	BANKSEL	ADREADPORT
	BTFSS	ADREADPORT,1
	GOTO	ENDIF12
;IF ADREADPORT.1 ON THEN SET CHS1 ON
	BANKSEL	ADCON0
	BSF	ADCON0,3
;IF ADREADPORT.1 ON THEN SET CHS1 ON
GLOBAL	ENDIF12
ENDIF12:
;IF ADREADPORT.2 ON THEN SET CHS2 ON
	BANKSEL	ADREADPORT
	BTFSS	ADREADPORT,2
	GOTO	ENDIF13
;IF ADREADPORT.2 ON THEN SET CHS2 ON
	BANKSEL	ADCON0
	BSF	ADCON0,4
;IF ADREADPORT.2 ON THEN SET CHS2 ON
GLOBAL	ENDIF13
ENDIF13:
;IF ADREADPORT.3 ON THEN SET CHS3 ON
	BANKSEL	ADREADPORT
	BTFSS	ADREADPORT,3
	GOTO	ENDIF14
;IF ADREADPORT.3 ON THEN SET CHS3 ON
	BANKSEL	ADCON0
	BSF	ADCON0,5
;IF ADREADPORT.3 ON THEN SET CHS3 ON
GLOBAL	ENDIF14
ENDIF14:
;IF ADREADPORT.4 ON THEN SET CHS4 ON
	BANKSEL	ADREADPORT
	BTFSS	ADREADPORT,4
	GOTO	ENDIF15
;IF ADREADPORT.4 ON THEN SET CHS4 ON
	BANKSEL	ADCON0
	BSF	ADCON0,6
;IF ADREADPORT.4 ON THEN SET CHS4 ON
GLOBAL	ENDIF15
ENDIF15:
;ENABLE AD OPERATIONS
;SET ADON ON
	BANKSEL	ADCON0
	BSF	ADCON0,0
;ACQUISITION DELAY
;WAIT AD_DELAY
	MOVLW	2
	MOVWF	SYSWAITTEMP10US
	BANKSEL	STATUS
	CALL	DELAY_10US
;READ A/D 1
;SET GO_NOT_DONE ON
	BANKSEL	ADCON0
	BSF	ADCON0,1
;NOP
	NOP
;WAIT WHILE GO_NOT_DONE ON
GLOBAL	SYSWAITLOOP3
SYSWAITLOOP3:
	BTFSC	ADCON0,1
	GOTO	SYSWAITLOOP3
;SWITCH OFF A/D
;SET ADCON0.ADON OFF
	BCF	ADCON0,0
;ANSELA = 0
	BANKSEL	ANSELA
	CLRF	ANSELA
;ANSELB = 0
	CLRF	ANSELB
;ANSELC = 0
	CLRF	ANSELC
;WRITE OUTPUT
;READAD10 = ADRESL
	BANKSEL	ADRESL
	MOVF	ADRESL,W
	BANKSEL	READAD10
	MOVWF	READAD10
	CLRF	READAD10_H
;READAD10_H = ADRESH
	BANKSEL	ADRESH
	MOVF	ADRESH,W
	BANKSEL	READAD10_H
	MOVWF	READAD10_H
;PUT A/D FORMAT BACK TO NORMAL
;SET ADFM OFF
	BANKSEL	ADCON1
	BCF	ADCON1,7
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: GCBASIC_FIRMWARE_FOR_MICROCHIP_CURIOSITY_BOARD_16F1619.GCB (141)
GLOBAL	READMTOUCH
READMTOUCH:
;DIM ADCVALUEWORD AS WORD
;DIM SAVEADCON0, SAVEODCONC, SAVEANSELC, SAVETRISC, SAVELATC AS BYTE
;SAVEADCON0 = ADCON0
	BANKSEL	ADCON0
	MOVF	ADCON0,W
	BANKSEL	SAVEADCON0
	MOVWF	SAVEADCON0
;SAVETRISC = TRISC
	BANKSEL	TRISC
	MOVF	TRISC,W
	BANKSEL	SAVETRISC
	MOVWF	SAVETRISC
;SAVELATC = LATC
	BANKSEL	LATC
	MOVF	LATC,W
	BANKSEL	SAVELATC
	MOVWF	SAVELATC
;ADCVALUEWORD = 0
	CLRF	ADCVALUEWORD
	CLRF	ADCVALUEWORD_H
;---- CONSTANTS
;AN5/RC1 - SENSOR CHANNEL
;DIR SENSORCHANNEL IN
	BANKSEL	TRISC
	BSF	TRISC,1
;AN6/RC2 - SECONDARY (DUMMY) CHANNEL
;DIR SECONDARYCHANNEL OUT
	BCF	TRISC,2
;INTOFF
;AN1298 - STEP 1: SET SECONDARY (DUMMY) CHANNEL HIGH (VDD)
;SET AS OUTPUT
;DIR SECONDARYCHANNEL OUT	
	BCF	TRISC,2
;SET AS OPEN DRAIN
;SAVEODCONC = ODCONC
	BANKSEL	ODCONC
	MOVF	ODCONC,W
	BANKSEL	SAVEODCONC
	MOVWF	SAVEODCONC
;SET ODCONC.2 = 1
	BANKSEL	ODCONC
	BSF	ODCONC,2
;SET AS DIGITAL
;ANSELC = SAVEANSELC
	BANKSEL	SAVEANSELC
	MOVF	SAVEANSELC,W
	BANKSEL	ANSELC
	MOVWF	ANSELC
;SET ANSELC.2 = 0
	BCF	ANSELC,2
;SET HIGH (VDD)
;SET SECONDARYCHANNEL = 1
	BANKSEL	LATC
	BSF	LATC,2
;AN1298 - STEP 2: SELECT SECONDARY CHANNEL ON ADC (CHARGE CHOLD TO VDD)
;ADC CHANNEL SELECT -> AN6/RC2 (BITS 2-6)
	;SET	ADCON0
	MOVLW	25
	BANKSEL	ADCON0
	MOVWF	ADCON0
;AN1298 - STEP 3: SET SENSOR PIN AS OUTPUT, LOW (GND) TO ELIMINATE ANY CHARGE
;SET AS OUTPUT
;DIR SENSORCHANNEL OUT
	BCF	TRISC,1
;SET AS DIGITAL
;SET ANSELC.1 = 0
	BANKSEL	ANSELC
	BCF	ANSELC,1
;SET LOW (GROUND)
;SET SENSORCHANNEL = 0
	BANKSEL	LATC
	BCF	LATC,1
;AN1298 - STEP 4: SET SENSOR PIN AS INPUT
;SET AS INPUT
;DIR SENSORCHANNEL IN	
	BANKSEL	TRISC
	BSF	TRISC,1
;SET AS ANALOG
;SET ANSELC.1 = 1
	BANKSEL	ANSELC
	BSF	ANSELC,1
;AN1298 - STEP 5: SELECT SENSOR CHANNEL ON ADC (V-DIV SENSOR:CHOLD)
;ADC CHANNEL SELECT -> AN5/RC1 (BITS 2-6)
	;SET	ADCON0
	MOVLW	21
	BANKSEL	ADCON0
	MOVWF	ADCON0
;ENABLE ADC (BIT 0)
;DELAY TO ALLOW ADC VOLTAGE TO STABILISE
;WAIT 10 US 		
	MOVLW	26
	MOVWF	DELAYTEMP
GLOBAL	DELAYUS1
DELAYUS1:
	DECFSZ	DELAYTEMP,F
	GOTO	DELAYUS1
	NOP
;AN1298 - STEP 6: START ADC CONVERSION
;SET ADFM ON
	BSF	ADCON1,7
;START ADC CONVERSION (SET GO/DONE BIT 1 = 1)
;SET ADCON0.1 = 1  	
	BSF	ADCON0,1
;WAIT FOR ADC CONVERSION (DONE BIT 1 = 0)
;WAIT WHILE ADCON0.1 = 1
GLOBAL	SYSWAITLOOP1
SYSWAITLOOP1:
	BTFSC	ADCON0,1
	GOTO	SYSWAITLOOP1
;AN1298 - STEP 7: READ ADC RESULT
;ADCVALUEWORD = READAD10(AN5)
	MOVLW	5
	BANKSEL	ADREADPORT
	MOVWF	ADREADPORT
	CALL	FN_READAD108
	MOVF	SYSREADAD10WORD,W
	MOVWF	ADCVALUEWORD
	MOVF	SYSREADAD10WORD_H,W
	MOVWF	ADCVALUEWORD_H
;ACTION RESULT
;LATC = SAVELATC
	MOVF	SAVELATC,W
	BANKSEL	LATC
	MOVWF	LATC
;IF ADCVALUEWORD > 10 THEN
	BANKSEL	ADCVALUEWORD
	MOVF	ADCVALUEWORD,W
	MOVWF	SYSWORDTEMPB
	MOVF	ADCVALUEWORD_H,W
	MOVWF	SYSWORDTEMPB_H
	MOVLW	10
	MOVWF	SYSWORDTEMPA
	CLRF	SYSWORDTEMPA_H
	CALL	SYSCOMPLESSTHAN16
	BTFSS	SYSBYTETEMPX,0
	GOTO	ELSE5_1
;IF TOUCHING S3 TOUCH BUTTON
;LED6 = 1
	BANKSEL	LATA
	BSF	LATA,2
;ELSE
	GOTO	ENDIF5
GLOBAL	ELSE5_1
ELSE5_1:
;LED6 = 0
	BANKSEL	LATA
	BCF	LATA,2
;END IF
GLOBAL	ENDIF5
ENDIF5:
;TRISC = SAVETRISC
	BANKSEL	SAVETRISC
	MOVF	SAVETRISC,W
	BANKSEL	TRISC
	MOVWF	TRISC
;ANSELC = SAVEANSELC
	BANKSEL	SAVEANSELC
	MOVF	SAVEANSELC,W
	BANKSEL	ANSELC
	MOVWF	ANSELC
;ODCONC = SAVEODCONC
	BANKSEL	SAVEODCONC
	MOVF	SAVEODCONC,W
	BANKSEL	ODCONC
	MOVWF	ODCONC
;ADCON0 = SAVEADCON0
	BANKSEL	SAVEADCON0
	MOVF	SAVEADCON0,W
	BANKSEL	ADCON0
	MOVWF	ADCON0
;ADCON0.ADON = 0
	BCF	ADCON0,0
;INTON
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3081)
GLOBAL	SYSCOMPEQUAL
SYSCOMPEQUAL:
;DIM SYSBYTETEMPA, SYSBYTETEMPB, SYSBYTETEMPX AS BYTE
;CLRF SYSBYTETEMPX
	CLRF	SYSBYTETEMPX
;MOVF SYSBYTETEMPA, W
	MOVF	SYSBYTETEMPA, W
;SUBWF SYSBYTETEMPB, W
	SUBWF	SYSBYTETEMPB, W
;BTFSC STATUS, Z
	BTFSC	STATUS,2
;COMF SYSBYTETEMPX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3107)
GLOBAL	SYSCOMPEQUAL16
SYSCOMPEQUAL16:
;DIM SYSWORDTEMPA AS WORD
;DIM SYSWORDTEMPB AS WORD
;DIM SYSBYTETEMPX AS BYTE
;CLRF SYSBYTETEMPX
	CLRF	SYSBYTETEMPX
;TEST LOW, EXIT IF FALSE
;MOVF SYSWORDTEMPA, W
	MOVF	SYSWORDTEMPA, W
;SUBWF SYSWORDTEMPB, W
	SUBWF	SYSWORDTEMPB, W
;BTFSS STATUS, Z
	BTFSS	STATUS,2
;RETURN
	RETURN
;TEST HIGH, EXIT IF FALSE
;MOVF SYSWORDTEMPA_H, W
	MOVF	SYSWORDTEMPA_H, W
;SUBWF SYSWORDTEMPB_H, W
	SUBWF	SYSWORDTEMPB_H, W
;BTFSS STATUS, Z
	BTFSS	STATUS,2
;RETURN
	RETURN
;COMF SYSBYTETEMPX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3161)
GLOBAL	SYSCOMPEQUAL32
SYSCOMPEQUAL32:
;DIM SYSLONGTEMPA AS LONG
;DIM SYSLONGTEMPB AS LONG
;DIM SYSBYTETEMPX AS BYTE
;CLRF SYSBYTETEMPX
	CLRF	SYSBYTETEMPX
;TEST LOW, EXIT IF FALSE
;MOVF SYSLONGTEMPA, W
	MOVF	SYSLONGTEMPA, W
;SUBWF SYSLONGTEMPB, W
	SUBWF	SYSLONGTEMPB, W
;BTFSS STATUS, Z
	BTFSS	STATUS,2
;RETURN
	RETURN
;TEST HIGH, EXIT IF FALSE
;MOVF SYSLONGTEMPA_H, W
	MOVF	SYSLONGTEMPA_H, W
;SUBWF SYSLONGTEMPB_H, W
	SUBWF	SYSLONGTEMPB_H, W
;BTFSS STATUS, Z
	BTFSS	STATUS,2
;RETURN
	RETURN
;TEST UPPER, EXIT IF FALSE
;MOVF SYSLONGTEMPA_U, W
	MOVF	SYSLONGTEMPA_U, W
;SUBWF SYSLONGTEMPB_U, W
	SUBWF	SYSLONGTEMPB_U, W
;BTFSS STATUS, Z
	BTFSS	STATUS,2
;RETURN
	RETURN
;TEST EXP, EXIT IF FALSE
;MOVF SYSLONGTEMPA_E, W
	MOVF	SYSLONGTEMPA_E, W
;SUBWF SYSLONGTEMPB_E, W
	SUBWF	SYSLONGTEMPB_E, W
;BTFSS STATUS, Z
	BTFSS	STATUS,2
;RETURN
	RETURN
;COMF SYSBYTETEMPX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3416)
GLOBAL	SYSCOMPLESSTHAN16
SYSCOMPLESSTHAN16:
;DIM SYSWORDTEMPA AS WORD
;DIM SYSWORDTEMPB AS WORD
;DIM SYSBYTETEMPX AS BYTE
;CLRF SYSBYTETEMPX
	CLRF	SYSBYTETEMPX
;TEST HIGH, EXIT IF MORE
;MOVF SYSWORDTEMPA_H,W
	MOVF	SYSWORDTEMPA_H,W
;SUBWF SYSWORDTEMPB_H,W
	SUBWF	SYSWORDTEMPB_H,W
;BTFSS STATUS,C
	BTFSS	STATUS,0
;RETURN
	RETURN
;TEST HIGH, EXIT TRUE IF LESS
;MOVF SYSWORDTEMPB_H,W
	MOVF	SYSWORDTEMPB_H,W
;SUBWF SYSWORDTEMPA_H,W
	SUBWF	SYSWORDTEMPA_H,W
;BTFSS STATUS,C
	BTFSS	STATUS,0
;GOTO SCLT16TRUE
	GOTO	SCLT16TRUE
;TEST LOW, EXIT IF MORE OR EQUAL
;MOVF SYSWORDTEMPB,W
	MOVF	SYSWORDTEMPB,W
;SUBWF SYSWORDTEMPA,W
	SUBWF	SYSWORDTEMPA,W
;BTFSC STATUS,C
	BTFSC	STATUS,0
;RETURN
	RETURN
GLOBAL	SCLT16TRUE
SCLT16TRUE:
;COMF SYSBYTETEMPX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3474)
GLOBAL	SYSCOMPLESSTHAN32
SYSCOMPLESSTHAN32:
;DIM SYSLONGTEMPA AS LONG
;DIM SYSLONGTEMPB AS LONG
;DIM SYSBYTETEMPX AS BYTE
;CLRF SYSBYTETEMPX
	CLRF	SYSBYTETEMPX
;TEST EXP, EXIT IF MORE
;MOVF SYSLONGTEMPA_E,W
	MOVF	SYSLONGTEMPA_E,W
;SUBWF SYSLONGTEMPB_E,W
	SUBWF	SYSLONGTEMPB_E,W
;BTFSS STATUS,C
	BTFSS	STATUS,0
;RETURN
	RETURN
;IF NOT MORE AND NOT ZERO, IS LESS
;BTFSS STATUS,Z
	BTFSS	STATUS,2
;GOTO SCLT32TRUE
	GOTO	SCLT32TRUE
;TEST UPPER, EXIT IF MORE
;MOVF SYSLONGTEMPA_U,W
	MOVF	SYSLONGTEMPA_U,W
;SUBWF SYSLONGTEMPB_U,W
	SUBWF	SYSLONGTEMPB_U,W
;BTFSS STATUS,C
	BTFSS	STATUS,0
;RETURN
	RETURN
;IF NOT MORE AND NOT ZERO, IS LESS
;BTFSS STATUS,Z
	BTFSS	STATUS,2
;GOTO SCLT32TRUE
	GOTO	SCLT32TRUE
;TEST HIGH, EXIT IF MORE
;MOVF SYSLONGTEMPA_H,W
	MOVF	SYSLONGTEMPA_H,W
;SUBWF SYSLONGTEMPB_H,W
	SUBWF	SYSLONGTEMPB_H,W
;BTFSS STATUS,C
	BTFSS	STATUS,0
;RETURN
	RETURN
;IF NOT MORE AND NOT ZERO, IS LESS
;BTFSS STATUS,Z
	BTFSS	STATUS,2
;GOTO SCLT32TRUE
	GOTO	SCLT32TRUE
;TEST LOW, EXIT IF MORE OR EQUAL
;MOVF SYSLONGTEMPB,W
	MOVF	SYSLONGTEMPB,W
;SUBWF SYSLONGTEMPA,W
	SUBWF	SYSLONGTEMPA,W
;BTFSC STATUS,C
	BTFSC	STATUS,0
;RETURN
	RETURN
GLOBAL	SCLT32TRUE
SCLT32TRUE:
;COMF SYSBYTETEMPX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (2864)
GLOBAL	SYSDIVSUB16
SYSDIVSUB16:
;DIM SYSWORDTEMPA AS WORD
;DIM SYSWORDTEMPB AS WORD
;DIM SYSWORDTEMPX AS WORD
;DIM SYSDIVMULTA AS WORD
;DIM SYSDIVMULTB AS WORD
;DIM SYSDIVMULTX AS WORD
;SYSDIVMULTA = SYSWORDTEMPA
	MOVF	SYSWORDTEMPA,W
	MOVWF	SYSDIVMULTA
	MOVF	SYSWORDTEMPA_H,W
	MOVWF	SYSDIVMULTA_H
;SYSDIVMULTB = SYSWORDTEMPB
	MOVF	SYSWORDTEMPB,W
	MOVWF	SYSDIVMULTB
	MOVF	SYSWORDTEMPB_H,W
	MOVWF	SYSDIVMULTB_H
;SYSDIVMULTX = 0
	CLRF	SYSDIVMULTX
	CLRF	SYSDIVMULTX_H
;AVOID DIVISION BY ZERO
;IF SYSDIVMULTB = 0 THEN
	MOVF	SYSDIVMULTB,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSDIVMULTB_H,W
	MOVWF	SYSWORDTEMPA_H
	CLRF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	CALL	SYSCOMPEQUAL16
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF30
;SYSWORDTEMPA = 0
	CLRF	SYSWORDTEMPA
	CLRF	SYSWORDTEMPA_H
;EXIT SUB
	RETURN
;END IF
GLOBAL	ENDIF30
ENDIF30:
;MAIN CALC ROUTINE
;SYSDIVLOOP = 16
	MOVLW	16
	MOVWF	SYSDIVLOOP
GLOBAL	SYSDIV16START
SYSDIV16START:
;SET C OFF
	BCF	STATUS,0
;ROTATE SYSDIVMULTA LEFT
	RLF	SYSDIVMULTA,F
	RLF	SYSDIVMULTA_H,F
;ROTATE SYSDIVMULTX LEFT
	RLF	SYSDIVMULTX,F
	RLF	SYSDIVMULTX_H,F
;SYSDIVMULTX = SYSDIVMULTX - SYSDIVMULTB
	MOVF	SYSDIVMULTB,W
	SUBWF	SYSDIVMULTX,F
	MOVF	SYSDIVMULTB_H,W
	SUBWFB	SYSDIVMULTX_H,F
;SET SYSDIVMULTA.0 ON
	BSF	SYSDIVMULTA,0
;IF C OFF THEN
	BTFSC	STATUS,0
	GOTO	ENDIF31
;SET SYSDIVMULTA.0 OFF
	BCF	SYSDIVMULTA,0
;SYSDIVMULTX = SYSDIVMULTX + SYSDIVMULTB
	MOVF	SYSDIVMULTB,W
	ADDWF	SYSDIVMULTX,F
	MOVF	SYSDIVMULTB_H,W
	ADDWFC	SYSDIVMULTX_H,F
;END IF
GLOBAL	ENDIF31
ENDIF31:
;DECFSZ SYSDIVLOOP, F
	DECFSZ	SYSDIVLOOP, F
;GOTO SYSDIV16START
	GOTO	SYSDIV16START
;SYSWORDTEMPA = SYSDIVMULTA
	MOVF	SYSDIVMULTA,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSDIVMULTA_H,W
	MOVWF	SYSWORDTEMPA_H
;SYSWORDTEMPX = SYSDIVMULTX
	MOVF	SYSDIVMULTX,W
	MOVWF	SYSWORDTEMPX
	MOVF	SYSDIVMULTX_H,W
	MOVWF	SYSWORDTEMPX_H
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (2940)
GLOBAL	SYSDIVSUB32
SYSDIVSUB32:
;DIM SYSLONGTEMPA AS LONG
;DIM SYSLONGTEMPB AS LONG
;DIM SYSLONGTEMPX AS LONG
;#IFDEF PIC
;DIM SYSLONGDIVMULTA AS LONG
;DIM SYSLONGDIVMULTB AS LONG
;DIM SYSLONGDIVMULTX AS LONG
;#ENDIF
;SYSLONGDIVMULTA = SYSLONGTEMPA
	MOVF	SYSLONGTEMPA,W
	MOVWF	SYSLONGDIVMULTA
	MOVF	SYSLONGTEMPA_H,W
	MOVWF	SYSLONGDIVMULTA_H
	MOVF	SYSLONGTEMPA_U,W
	MOVWF	SYSLONGDIVMULTA_U
	MOVF	SYSLONGTEMPA_E,W
	MOVWF	SYSLONGDIVMULTA_E
;SYSLONGDIVMULTB = SYSLONGTEMPB
	MOVF	SYSLONGTEMPB,W
	MOVWF	SYSLONGDIVMULTB
	MOVF	SYSLONGTEMPB_H,W
	MOVWF	SYSLONGDIVMULTB_H
	MOVF	SYSLONGTEMPB_U,W
	MOVWF	SYSLONGDIVMULTB_U
	MOVF	SYSLONGTEMPB_E,W
	MOVWF	SYSLONGDIVMULTB_E
;SYSLONGDIVMULTX = 0
	CLRF	SYSLONGDIVMULTX
	CLRF	SYSLONGDIVMULTX_H
	CLRF	SYSLONGDIVMULTX_U
	CLRF	SYSLONGDIVMULTX_E
;AVOID DIVISION BY ZERO
;IF SYSLONGDIVMULTB = 0 THEN
	MOVF	SYSLONGDIVMULTB,W
	MOVWF	SYSLONGTEMPA
	MOVF	SYSLONGDIVMULTB_H,W
	MOVWF	SYSLONGTEMPA_H
	MOVF	SYSLONGDIVMULTB_U,W
	MOVWF	SYSLONGTEMPA_U
	MOVF	SYSLONGDIVMULTB_E,W
	MOVWF	SYSLONGTEMPA_E
	CLRF	SYSLONGTEMPB
	CLRF	SYSLONGTEMPB_H
	CLRF	SYSLONGTEMPB_U
	CLRF	SYSLONGTEMPB_E
	CALL	SYSCOMPEQUAL32
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF32
;SYSLONGTEMPA = 0
	CLRF	SYSLONGTEMPA
	CLRF	SYSLONGTEMPA_H
	CLRF	SYSLONGTEMPA_U
	CLRF	SYSLONGTEMPA_E
;EXIT SUB
	RETURN
;END IF
GLOBAL	ENDIF32
ENDIF32:
;MAIN CALC ROUTINE
;SYSDIVLOOP = 32
	MOVLW	32
	MOVWF	SYSDIVLOOP
GLOBAL	SYSDIV32START
SYSDIV32START:
;SET C OFF
	BCF	STATUS,0
;ROTATE SYSLONGDIVMULTA LEFT
	RLF	SYSLONGDIVMULTA,F
	RLF	SYSLONGDIVMULTA_H,F
	RLF	SYSLONGDIVMULTA_U,F
	RLF	SYSLONGDIVMULTA_E,F
;ROTATE SYSLONGDIVMULTX LEFT
	RLF	SYSLONGDIVMULTX,F
	RLF	SYSLONGDIVMULTX_H,F
	RLF	SYSLONGDIVMULTX_U,F
	RLF	SYSLONGDIVMULTX_E,F
;SYSLONGDIVMULTX = SYSLONGDIVMULTX - SYSLONGDIVMULTB
	MOVF	SYSLONGDIVMULTB,W
	SUBWF	SYSLONGDIVMULTX,F
	MOVF	SYSLONGDIVMULTB_H,W
	SUBWFB	SYSLONGDIVMULTX_H,F
	MOVF	SYSLONGDIVMULTB_U,W
	SUBWFB	SYSLONGDIVMULTX_U,F
	MOVF	SYSLONGDIVMULTB_E,W
	SUBWFB	SYSLONGDIVMULTX_E,F
;SET SYSLONGDIVMULTA.0 ON
	BSF	SYSLONGDIVMULTA,0
;IF C OFF THEN
	BTFSC	STATUS,0
	GOTO	ENDIF33
;SET SYSLONGDIVMULTA.0 OFF
	BCF	SYSLONGDIVMULTA,0
;SYSLONGDIVMULTX = SYSLONGDIVMULTX + SYSLONGDIVMULTB
	MOVF	SYSLONGDIVMULTB,W
	ADDWF	SYSLONGDIVMULTX,F
	MOVF	SYSLONGDIVMULTB_H,W
	ADDWFC	SYSLONGDIVMULTX_H,F
	MOVF	SYSLONGDIVMULTB_U,W
	ADDWFC	SYSLONGDIVMULTX_U,F
	MOVF	SYSLONGDIVMULTB_E,W
	ADDWFC	SYSLONGDIVMULTX_E,F
;END IF
GLOBAL	ENDIF33
ENDIF33:
;DECFSZ SYSDIVLOOP, F
	DECFSZ	SYSDIVLOOP, F
;GOTO SYSDIV32START
	GOTO	SYSDIV32START
;SYSLONGTEMPA = SYSLONGDIVMULTA
	MOVF	SYSLONGDIVMULTA,W
	MOVWF	SYSLONGTEMPA
	MOVF	SYSLONGDIVMULTA_H,W
	MOVWF	SYSLONGTEMPA_H
	MOVF	SYSLONGDIVMULTA_U,W
	MOVWF	SYSLONGTEMPA_U
	MOVF	SYSLONGDIVMULTA_E,W
	MOVWF	SYSLONGTEMPA_E
;SYSLONGTEMPX = SYSLONGDIVMULTX
	MOVF	SYSLONGDIVMULTX,W
	MOVWF	SYSLONGTEMPX
	MOVF	SYSLONGDIVMULTX_H,W
	MOVWF	SYSLONGTEMPX_H
	MOVF	SYSLONGDIVMULTX_U,W
	MOVWF	SYSLONGTEMPX_U
	MOVF	SYSLONGDIVMULTX_E,W
	MOVWF	SYSLONGTEMPX_E
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (2685)
GLOBAL	SYSMULTSUB32
SYSMULTSUB32:
;DIM SYSLONGTEMPA AS LONG
;DIM SYSLONGTEMPB AS LONG
;DIM SYSLONGTEMPX AS LONG
;CAN'T USE NORMAL SYSDIVMULT VARIABLES FOR 32 BIT, THEY OVERLAP WITH
;SYSLONGTEMP VARIABLES
;DIM SYSLONGDIVMULTA AS LONG
;DIM SYSLONGDIVMULTB AS LONG
;DIM SYSLONGDIVMULTX AS LONG
;SYSLONGDIVMULTA = SYSLONGTEMPA
	MOVF	SYSLONGTEMPA,W
	MOVWF	SYSLONGDIVMULTA
	MOVF	SYSLONGTEMPA_H,W
	MOVWF	SYSLONGDIVMULTA_H
	MOVF	SYSLONGTEMPA_U,W
	MOVWF	SYSLONGDIVMULTA_U
	MOVF	SYSLONGTEMPA_E,W
	MOVWF	SYSLONGDIVMULTA_E
;SYSLONGDIVMULTB = SYSLONGTEMPB
	MOVF	SYSLONGTEMPB,W
	MOVWF	SYSLONGDIVMULTB
	MOVF	SYSLONGTEMPB_H,W
	MOVWF	SYSLONGDIVMULTB_H
	MOVF	SYSLONGTEMPB_U,W
	MOVWF	SYSLONGDIVMULTB_U
	MOVF	SYSLONGTEMPB_E,W
	MOVWF	SYSLONGDIVMULTB_E
;SYSLONGDIVMULTX = 0
	CLRF	SYSLONGDIVMULTX
	CLRF	SYSLONGDIVMULTX_H
	CLRF	SYSLONGDIVMULTX_U
	CLRF	SYSLONGDIVMULTX_E
GLOBAL	MUL32LOOP
MUL32LOOP:
;IF SYSLONGDIVMULTB.0 ON THEN SYSLONGDIVMULTX += SYSLONGDIVMULTA
	BTFSS	SYSLONGDIVMULTB,0
	GOTO	ENDIF28
;IF SYSLONGDIVMULTB.0 ON THEN SYSLONGDIVMULTX += SYSLONGDIVMULTA
	MOVF	SYSLONGDIVMULTA,W
	ADDWF	SYSLONGDIVMULTX,F
	MOVF	SYSLONGDIVMULTA_H,W
	ADDWFC	SYSLONGDIVMULTX_H,F
	MOVF	SYSLONGDIVMULTA_U,W
	ADDWFC	SYSLONGDIVMULTX_U,F
	MOVF	SYSLONGDIVMULTA_E,W
	ADDWFC	SYSLONGDIVMULTX_E,F
;IF SYSLONGDIVMULTB.0 ON THEN SYSLONGDIVMULTX += SYSLONGDIVMULTA
GLOBAL	ENDIF28
ENDIF28:
;SET STATUS.C OFF
	BCF	STATUS,0
;ROTATE SYSLONGDIVMULTB RIGHT
	RRF	SYSLONGDIVMULTB_E,F
	RRF	SYSLONGDIVMULTB_U,F
	RRF	SYSLONGDIVMULTB_H,F
	RRF	SYSLONGDIVMULTB,F
;SET STATUS.C OFF
	BCF	STATUS,0
;ROTATE SYSLONGDIVMULTA LEFT
	RLF	SYSLONGDIVMULTA,F
	RLF	SYSLONGDIVMULTA_H,F
	RLF	SYSLONGDIVMULTA_U,F
	RLF	SYSLONGDIVMULTA_E,F
;IF SYSLONGDIVMULTB > 0 THEN GOTO MUL32LOOP
	MOVF	SYSLONGDIVMULTB,W
	MOVWF	SYSLONGTEMPB
	MOVF	SYSLONGDIVMULTB_H,W
	MOVWF	SYSLONGTEMPB_H
	MOVF	SYSLONGDIVMULTB_U,W
	MOVWF	SYSLONGTEMPB_U
	MOVF	SYSLONGDIVMULTB_E,W
	MOVWF	SYSLONGTEMPB_E
	CLRF	SYSLONGTEMPA
	CLRF	SYSLONGTEMPA_H
	CLRF	SYSLONGTEMPA_U
	CLRF	SYSLONGTEMPA_E
	CALL	SYSCOMPLESSTHAN32
	BTFSC	SYSBYTETEMPX,0
;IF SYSLONGDIVMULTB > 0 THEN GOTO MUL32LOOP
	GOTO	MUL32LOOP
;IF SYSLONGDIVMULTB > 0 THEN GOTO MUL32LOOP
;SYSLONGTEMPX = SYSLONGDIVMULTX
	MOVF	SYSLONGDIVMULTX,W
	MOVWF	SYSLONGTEMPX
	MOVF	SYSLONGDIVMULTX_H,W
	MOVWF	SYSLONGTEMPX_H
	MOVF	SYSLONGDIVMULTX_U,W
	MOVWF	SYSLONGTEMPX_U
	MOVF	SYSLONGDIVMULTX_E,W
	MOVWF	SYSLONGTEMPX_E
	RETURN

;********************************************************************************

;START OF PROGRAM MEMORY PAGE 1
	PSECT	PROGMEM1,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	2048
;START OF PROGRAM MEMORY PAGE 2
	PSECT	PROGMEM2,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	4096
;START OF PROGRAM MEMORY PAGE 3
	PSECT	PROGMEM3,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	6144
;
; Declare Power-On-Reset entry point
;
 END     RESETVEC
