;Program compiled by GCBASIC (2024.2.16 (Windows 64 bit) : Build 1337) for Microchip MPASM/MPLAB-X Assembler using FreeBASIC 1.07.1/2024-02-15 CRC247
;Need help? 
;  See the GCBASIC forums at http://sourceforge.net/projects/gcbasic/forums,
;  Check the documentation and Help at http://gcbasic.sourceforge.net/help/,
;or, email us:
;   w_cholmondeley at users dot sourceforge dot net
;   evanvennn at users dot sourceforge dot net
;********************************************************************************
;   Source file    : D:\GreatCowBASICGits\Demonstration_Sources.git\Vendor_Boards\Great_Cow_Basic_Demo_Board\18Fx6q20_ChipRange_Demonstrations\170_show_i2c_devices_to_serial_terminal.gcb
;   Setting file   : C:\GCstudio\gcbasic\use.ini
;   Preserve mode  : 2
;   Assembler      : "C:\Program Files\Microchip\xc8\v2.46\pic-as\bin\pic-as.exe"
;   Programmer     : C:\GCstudio\gcbasic\..\PICKitPlus\PICKitCommandline.exe
;   Output file    : D:\GreatCowBASICGits\Demonstration_Sources.git\Vendor_Boards\Great_Cow_Basic_Demo_Board\18Fx6q20_ChipRange_Demonstrations\170_show_i2c_devices_to_serial_terminal.asm
;********************************************************************************

;Set up the assembler options (Chip type, clock source, other bits and pieces)
 LIST p=18F16Q20, r=DEC
#include <P18F16Q20.inc>
 CONFIG  CPD = OFF
 CONFIG  CP = OFF
 CONFIG  WRTSAF = OFF
 CONFIG  WRTD = OFF
 CONFIG  WRTB = OFF
 CONFIG  VDDIO3MD = STANDARD_RANGE
 CONFIG  VDDIO2MD = STANDARD_RANGE
 CONFIG  WDTE = OFF
 CONFIG  XINST = OFF
 CONFIG  LVP = OFF
 CONFIG  MVECEN = OFF
 CONFIG  MCLRE = INTMCLR
 CONFIG  FCMEN = ON
 CONFIG  CLKOUTEN = OFF
 CONFIG  RSTOSC = HFINTOSC_1MHZ
 CONFIG  FEXTOSC = OFF

;********************************************************************************

;Set aside memory locations for variables
COMPORT                          EQU    1282          ; 0X502
DELAYTEMP                        EQU    1280          ; 0X500
DELAYTEMP2                       EQU    1281          ; 0X501
DEVICEID                         EQU    1283          ; 0X503
DISPLAYNEWLINE                   EQU    1290          ; 0X50A
DUMPI2CREAD                      EQU    1291          ; 0X50B
HI2C1LASTERROR                   EQU    1292          ; 0X50C
HI2C1STATEMACHINE                EQU    1293          ; 0X50D
HI2CACKPOLLSTATE                 EQU    1294          ; 0X50E
HI2CCURRENTMODE                  EQU    1295          ; 0X50F
HI2CWAITMSSPTIMEOUT              EQU    1296          ; 0X510
HSERPRINTCRLFCOUNT               EQU    1297          ; 0X511
I2CBYTE                          EQU    1298          ; 0X512
PRINTLEN                         EQU    1299          ; 0X513
SERDATA                          EQU    1300          ; 0X514
STRINGPOINTER                    EQU    1301          ; 0X515
SYSBYTETEMPA                     EQU    1285          ; 0X505
SYSBYTETEMPB                     EQU    1289          ; 0X509
SYSBYTETEMPX                     EQU    1280          ; 0X500
SYSCALCTEMPA                     EQU    1285          ; 0X505
SYSDIVLOOP                       EQU    1284          ; 0X504
SYSPRINTDATAHANDLER              EQU    1302          ; 0X516
SYSPRINTDATAHANDLER_H            EQU    1303          ; 0X517
SYSPRINTTEMP                     EQU    1304          ; 0X518
SYSREPEATTEMP1                   EQU    1305          ; 0X519
SYSSTRINGA                       EQU    1287          ; 0X507
SYSSTRINGA_H                     EQU    1288          ; 0X508
SYSSTRINGLENGTH                  EQU    1286          ; 0X506
SYSSTRINGPARAM1                  EQU    5362          ; 0X14F2
SYSSTRINGTEMP                    EQU    1306          ; 0X51A
SYSTEMP1                         EQU    1307          ; 0X51B
SYSTEMP2                         EQU    1308          ; 0X51C
SYSVALTEMP                       EQU    1309          ; 0X51D
SYSWAITTEMPUS                    EQU    1285          ; 0X505
SYSWAITTEMPUS_H                  EQU    1286          ; 0X506
_HEXPICAS                        EQU    5358          ; 0X14EE

;********************************************************************************

;ALIAS VARIABLES
AFSR0                            EQU 1257
AFSR0_H                          EQU 1258
SYS_HEXPICAS_0                   EQU 5358
SYS_HEXPICAS_1                   EQU 5359
SYS_HEXPICAS_2                   EQU 5360

;********************************************************************************

;VECTORS
	ORG	0
	GOTO	BASPROGRAMSTART
	ORG	8
	RETFIE

;********************************************************************************

;PROGRAM_MEMORY_PAGE: 0
	ORG	12
BASPROGRAMSTART
;CALL INITIALISATION ROUTINES
	RCALL	INITSYS
	RCALL	INITPPS
	RCALL	INITUSART
	RCALL	HI2CINIT

;START_OF_THE_MAIN_PROGRAM
;
;This demonstration shows the I2C devices attached the microcontroller, this program support the Microchip I2C module.
;
;I2C device required a data bus and a clock bus, devices also required an input voltage and 0v.
;I2C data bus is connected to PortA.4
;I2C clock bus is connected to PortA.1
;Serial output is connected, as previously, to PortC.4
;
;Connect your IC2 devices and see the results on the serial terminal.
;
;************************************************************************
;@author  EvanV
;@licence GPL
;@version 1.02
;@date    04-02-2024
;
;----- Configuration
;Chip Settings.
;PIC PPS Tool version: 0.0.6.5
;Add this code segment to your GCBASIC source program
;
;Hardware
;-------------------PORTA----------------
;Bit#:  -7---6---5---4---3---2---1---0---
;IO:    -----------------SW---------ADC--
;-----------------------------------------
;
;
;-------------------PORTB----------------
;Bit#:  -7---6---5---4---3---2---1---0---
;IO:    TX--SCL-SDA----------------------
;----------------------------------------
;
;------------------PORTC-----------------
;Bit#:  -7---6---5---4---3---2---1---0---
;IO:    LED-LED-LED-LED------------------
;----------------------------------------
;
;Define constants to make things easier. We can reuse these at any time.
;Set the ports as an output
;Dir LEDD7 Out
	BCF	TRISC,7,ACCESS
;Dir LEDD6 Out
	BCF	TRISC,6,ACCESS
;Dir LEDD5 Out
	BCF	TRISC,5,ACCESS
;Dir LEDD4 Out
	BCF	TRISC,4,ACCESS
;This is the PORTA.0 port
;Dir POTENTIOMETER In
	BSF	TRISA,0,ACCESS
;Dir     SWITCHIN      In
	BSF	TRISA,3,ACCESS
;Define I2C settings
;HI2CMode (Master)
	MOVLW	12
	MOVWF	HI2CCURRENTMODE,ACCESS
	RCALL	HI2CMODE
;*****************************************************************************************************
;Main program commences here.. everything before this is setup for the board.
;Dim DeviceID As Byte
;Dim DISPLAYNEWLINE As Byte
;Dim HI2CWaitMSSPTimeout As Byte
;Dim DumpI2CRead as Byte
;Do
SYSDOLOOP_S1
;HSerPrintCRLF
	MOVLW	1
	MOVWF	HSERPRINTCRLFCOUNT,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
	RCALL	HSERPRINTCRLF
;HSerPrint "Hardware I2C"
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE1
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE1
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE1
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
;USING SYSSTRINGPARAM1*12
	RCALL	HSERPRINT314
;HSerPrintCRLF 2
	MOVLW	2
	MOVWF	HSERPRINTCRLFCOUNT,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
	RCALL	HSERPRINTCRLF
;Now assumes Serial Terminal is operational
;HSerPrintCRLF
	MOVLW	1
	MOVWF	HSERPRINTCRLFCOUNT,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
	RCALL	HSERPRINTCRLF
;HSerPrint "   "
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE2
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE2
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE2
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
;USING SYSSTRINGPARAM1*3
	RCALL	HSERPRINT314
;Create a horizontal row of numbers
;For DeviceID = 0 To 15
;LEGACY METHOD
	SETF	DEVICEID,ACCESS
SYSFORLOOP1
	INCF	DEVICEID,F,ACCESS
;HSerPrint Hex(deviceID)
	MOVFF	DEVICEID,SYSVALTEMP
	RCALL	FN__HEXPICAS
	MOVLW	LOW _HEXPICAS
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH _HEXPICAS
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
	RCALL	HSERPRINT314
;HSerPrint " "
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE3
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE3
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE3
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
;USING SYSSTRINGPARAM1*1
	RCALL	HSERPRINT314
;Next
	MOVLW	15
	SUBWF	DEVICEID,W,ACCESS
	BTFSS	STATUS, C,ACCESS
	BRA	SYSFORLOOP1
SYSFORLOOPEND1
;Create a vertical column of numbers
;For DeviceID = 0 To 255
;LEGACY METHOD
	SETF	DEVICEID,ACCESS
SYSFORLOOP2
	INCF	DEVICEID,F,ACCESS
;DisplayNewLine = DeviceID % 16
	MOVFF	DEVICEID,SYSBYTETEMPA
	MOVLW	16
	MOVWF	SYSBYTETEMPB,ACCESS
	RCALL	SYSDIVSUB
	MOVFF	SYSBYTETEMPX,DISPLAYNEWLINE
;If DisplayNewLine = 0 Then
	MOVF	DISPLAYNEWLINE,F,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	ENDIF2
;HSerPrintCRLF
	MOVLW	1
	MOVWF	HSERPRINTCRLFCOUNT,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
	RCALL	HSERPRINTCRLF
;HSerPrint Hex(DeviceID)
	MOVFF	DEVICEID,SYSVALTEMP
	RCALL	FN__HEXPICAS
	MOVLW	LOW _HEXPICAS
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH _HEXPICAS
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
	RCALL	HSERPRINT314
;If DisplayNewLine > 0 Then
	MOVF	DISPLAYNEWLINE,W,ACCESS
	SUBLW	0
	BTFSC	STATUS, C,ACCESS
	BRA	ENDIF5
;HSerPrint " "
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE3
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE3
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE3
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
;USING SYSSTRINGPARAM1*1
	RCALL	HSERPRINT314
;End If
ENDIF5
;End If
ENDIF2
;HSerPrint " "
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE3
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE3
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE3
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
;USING SYSSTRINGPARAM1*1
	RCALL	HSERPRINT314
;Do an initial Start
;HI2CStart
	RCALL	SI2CSTART
;Send address
;HI2CSend ( DeviceID )
	MOVFF	DEVICEID,I2CBYTE
	RCALL	SI2CSEND
;If HI2CWaitMSSPTimeout <> 255 Then
	INCF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSC	STATUS, Z,ACCESS
	BRA	ELSE3_1
;Did device fail to respond?
;If HI2CAckpollState = FALSE Then
	MOVF	HI2CACKPOLLSTATE,F,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	ELSE6_1
;HSerPrint   Hex(DeviceID)
	MOVFF	DEVICEID,SYSVALTEMP
	RCALL	FN__HEXPICAS
	MOVLW	LOW _HEXPICAS
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH _HEXPICAS
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
	RCALL	HSERPRINT314
;Else
	BRA	ENDIF6
ELSE6_1
;HSerPrint   "--"
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE4
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE4
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE4
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
;USING SYSSTRINGPARAM1*2
	RCALL	HSERPRINT314
;End If
ENDIF6
;Get the read datato prevent any potential slave lockup
;If DeviceID.0 = 1 Then HI2CSend ( DumpI2CRead )
	BTFSS	DEVICEID,0,ACCESS
	BRA	ENDIF7
;If DeviceID.0 = 1 Then HI2CSend ( DumpI2CRead )
	MOVFF	DUMPI2CREAD,I2CBYTE
	RCALL	SI2CSEND
;If DeviceID.0 = 1 Then HI2CSend ( DumpI2CRead )
ENDIF7
;Else
	BRA	ENDIF3
ELSE3_1
;HSerPrint "! "
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE5
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE5
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE5
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
;USING SYSSTRINGPARAM1*2
	RCALL	HSERPRINT314
;End If
ENDIF3
;I2C Stop
;HI2CStop
	RCALL	SI2CSTOP
;Next
	MOVLW	255
	SUBWF	DEVICEID,W,ACCESS
	BTFSS	STATUS, C,ACCESS
	BRA	SYSFORLOOP2
SYSFORLOOPEND2
;HSerPrintCRLF 2
	MOVLW	2
	MOVWF	HSERPRINTCRLFCOUNT,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
	RCALL	HSERPRINTCRLF
;HSerPrint   "End of Search"
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE6
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE6
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE6
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
;USING SYSSTRINGPARAM1*13
	RCALL	HSERPRINT314
;HSerPrintCRLF 2
	MOVLW	2
	MOVWF	HSERPRINTCRLFCOUNT,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
	RCALL	HSERPRINTCRLF
;Wait While SwitchIn <> DOWN
SYSWAITLOOP1
	BTFSC	PORTA,3,ACCESS
	BRA	SYSWAITLOOP1
;Loop
	BRA	SYSDOLOOP_S1
SYSDOLOOP_E1
BASPROGRAMEND
	SLEEP
	BRA	BASPROGRAMEND

;********************************************************************************

;SOURCE: HWI2C.H (722)
HI2CINIT
;asm showdebug  This method sets the variable `HI2CCurrentMode`, and, if required calls the method `SI2CInit` to set up new MSSP modules - aka K-Mode family chips
;HI2CCurrentMode = 0
	CLRF	HI2CCURRENTMODE,ACCESS
;Initialise the I2C module
;SI2CInit
	BRA	SI2CINIT

;********************************************************************************

;SOURCE: HWI2C.H (260)
HI2CMODE
;asm showdebug  This method sets the variable `HI2CCurrentMode`, and, if required, sets the SSPCON1.bits
	RETURN

;********************************************************************************

;OVERLOADED SIGNATURE: STRING:BYTE:, SOURCE: USART.H (2458)
HSERPRINT314
;PrintLen = PrintData(0)
	MOVFF	SYSPRINTDATAHANDLER,AFSR0
	MOVFF	SYSPRINTDATAHANDLER_H,AFSR0_H
	MOVFF	INDF0,PRINTLEN
;If PrintLen <> 0 then
	MOVF	PRINTLEN,F,ACCESS
	BTFSC	STATUS, Z,ACCESS
	BRA	ENDIF11
;Write Data
;for SysPrintTemp = 1 to PrintLen
	MOVLW	1
	MOVWF	SYSPRINTTEMP,ACCESS
SYSFORLOOP4
;HSerSend(PrintData(SysPrintTemp),comport )
	MOVF	SYSPRINTTEMP,W,ACCESS
	ADDWF	SYSPRINTDATAHANDLER,W,ACCESS
	MOVWF	AFSR0,ACCESS
	MOVLW	0
	ADDWFC	SYSPRINTDATAHANDLER_H,W,ACCESS
	MOVWF	AFSR0_H,ACCESS
	MOVFF	INDF0,SERDATA
	RCALL	HSERSEND304
;next
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	SYSPRINTTEMP,W,ACCESS
	SUBWF	PRINTLEN,W,ACCESS
	MOVWF	SYSTEMP1,ACCESS
	MOVFF	SYSTEMP1,SYSBYTETEMPA
	CLRF	SYSBYTETEMPB,ACCESS
	RCALL	SYSCOMPEQUAL
	COMF	SYSBYTETEMPX,F,ACCESS
	BTFSS	SYSBYTETEMPX,0,ACCESS
	BRA	ENDIF12
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	INCF	SYSPRINTTEMP,F,ACCESS
	BRA	SYSFORLOOP4
;END IF
ENDIF12
SYSFORLOOPEND4
;End If
ENDIF11
;CR
;All Usarts
;--------------------------
;Specific USARTs
;------------------
	RETURN

;********************************************************************************

;SOURCE: USART.H (2666)
HSERPRINTCRLF
;repeat HSerPrintCRLFCount
	MOVFF	HSERPRINTCRLFCOUNT,SYSREPEATTEMP1
	MOVF	SYSREPEATTEMP1,F,ACCESS
	BTFSC	STATUS, Z,ACCESS
	BRA	SYSREPEATLOOPEND1
SYSREPEATLOOP1
;HSerSend(13,comport)
	MOVLW	13
	MOVWF	SERDATA,ACCESS
	RCALL	HSERSEND304
;HSerSend(10,comport)
	MOVLW	10
	MOVWF	SERDATA,ACCESS
	RCALL	HSERSEND304
;end Repeat
	DECFSZ	SYSREPEATTEMP1,F,ACCESS
	BRA	SYSREPEATLOOP1
SYSREPEATLOOPEND1
	RETURN

;********************************************************************************

;OVERLOADED SIGNATURE: BYTE:BYTE:, SOURCE: USART.H (1570)
HSERSEND304
HSERSENDUSART1HANDLER
;USART_TX_BLOCKING
;Wait While TXIF = Off
SYSWAITLOOP3
	BTFSS	PIR6,U1TXIF,ACCESS
	BRA	SYSWAITLOOP3
;TXREG = SerData
	MOVFF	SERDATA,U1TXB
	RETURN

;********************************************************************************

;SOURCE: 170_SHOW_I2C_DEVICES_TO_SERIAL_TERMINAL.GCB (31)
INITPPS
;Module: I2C1
;RB6PPS = 0x001C    // SCL1 > RB6
	MOVLW	28
	BANKSEL	RB6PPS
	MOVWF	RB6PPS,BANKED
;I2C1SCLPPS = 0x000E    // RB6 > SCL1 (bi-directional)
	MOVLW	14
	MOVWF	I2C1SCLPPS,BANKED
;RB5PPS = 0x001D    // SDA1 > RB5
	MOVLW	29
	MOVWF	RB5PPS,BANKED
;I2C1SDAPPS = 0x000D    // RB5 > SDA1 (bi-directional)
	MOVLW	13
	MOVWF	I2C1SDAPPS,BANKED
;Module: UART pin directions
;Dir PORTB.7 Out    // Make TX1 pin an output
	BCF	TRISB,7,ACCESS
;Module: UART1
;RB7PPS = 0x0013    // TX1 > RB7
	MOVLW	19
	MOVWF	RB7PPS,BANKED
	BANKSEL	0
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (177)
INITSYS
;Clear BSR on ChipFamily16 MCUs
;MOVLB 0
	MOVLB	0
;asm showdebug Default settings for microcontrollers with _OSCCON1_
;Default OSCCON1 typically, NOSC HFINTOSC; NDIV 1 - Common as this simply sets the HFINTOSC
;OSCCON1 = 0x60
	MOVLW	96
	MOVWF	OSCCON1,BANKED
;Default value typically, CSWHOLD may proceed; SOSCPWR Low power
;OSCCON3 = 0x00
	CLRF	OSCCON3,BANKED
;Default value typically, MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled
;OSCEN = 0x00
	CLRF	OSCEN,BANKED
;Default value
;OSCTUNE = 0x00
	CLRF	OSCTUNE,BANKED
;asm showdebug The MCU is a chip family 16
;Section supports many MCUs, 18FxxK40, 18FxxK42 etc that have NDIV3 bit
;asm showdebug OSCCON type is 101
;OSCCON1 = 0x60          // Setting OSCCON1 implies clearing Clear NDIV3:0
	MOVLW	96
	MOVWF	OSCCON1,BANKED
;OSCFRQ = 0b00001000  '64mhz
	MOVLW	8
	MOVWF	OSCFRQ,BANKED
;asm showdebug _Complete_the_chip_setup_of_BSR_ADCs_ANSEL_and_other_key_setup_registers_or_register_bits
;Clear TBLPTRU on MCUs with this bit as this must be zero
;TBLPTRU = 0
	CLRF	TBLPTRU,ACCESS
;Ensure all ports are set for digital I/O and, turn off A/D
;SET ADFM OFF
	BANKSEL	ADCON0
	BCF	ADCON0,ADFM0,BANKED
;Switch off A/D Var(ADCON0)
;SET ADCON0.ADON OFF
	BCF	ADCON0,ADON,BANKED
;ANSELA = 0
	BANKSEL	ANSELA
	CLRF	ANSELA,BANKED
;ANSELB = 0
	CLRF	ANSELB,BANKED
;ANSELC = 0
	CLRF	ANSELC,BANKED
;Turn off all ports
;PORTA = 0
	CLRF	PORTA,ACCESS
;PORTB = 0
	CLRF	PORTB,ACCESS
;PORTC = 0
	CLRF	PORTC,ACCESS
	BANKSEL	0
	RETURN

;********************************************************************************

;SOURCE: USART.H (1014)
INITUSART
;Set the default value for USART handler - required when more than one USART
;comport = 1
	MOVLW	1
	MOVWF	COMPORT,ACCESS
;PIC USART 1 Init
;U1BRGH=SPBRGH_TEMP
	MOVLW	6
	BANKSEL	U1BRGH
	MOVWF	U1BRGH,BANKED
;U1BRGL=SPBRGL_TEMP
	MOVLW	129
	MOVWF	U1BRGL,BANKED
;U1BRGS = BRGS1_SCRIPT
	BSF	U1CON0,U1BRGS,BANKED
;U1TXEN=1   'Enable TX1
	BSF	U1CON0,U1TXEN,BANKED
;U1RXEN=1   'Enable RX1
	BSF	U1CON0,U1RXEN,BANKED
;ON_U1CON1=1 'Enable USART1
	BSF	U1CON1,ON_U1CON1,BANKED
	BANKSEL	0
	RETURN

;********************************************************************************

;SOURCE: HWI2C.H (802)
SI2CINIT
;asm showdebug  This method sets the MSSP modules for K-mode family chips
;Dir HI2C_DATA out
	BCF	TRISB,5,ACCESS
;Dir HI2C_CLOCK out
	BCF	TRISB,6,ACCESS
;I2C1CON1 = I2C1I2C1CON1Default
	MOVLW	128
	BANKSEL	I2C1CON1
	MOVWF	I2C1CON1,BANKED
;I2C1CON2 = I2C1I2C1CON2Default
	MOVLW	33
	MOVWF	I2C1CON2,BANKED
;I2C1CLK =  I2C1CLOCKSOURCE
	MOVLW	3
	MOVWF	I2C1CLK,BANKED
;I2C1CON0 = I2C1I2C1CON0Default
	MOVLW	132
	MOVWF	I2C1CON0,BANKED
;I2C1PIR = 0    ;Clear all the error flags
	CLRF	I2C1PIR,BANKED
;I2C1ERR = 0
	CLRF	I2C1ERR,BANKED
;I2C1CON0.EN=1
	BSF	I2C1CON0,EN,BANKED
;Commence I2C protocol
;I2C1CON2.ACNT = 0
	BCF	I2C1CON2,ACNT,BANKED
;I2C1CON2.ABD=0
	BCF	I2C1CON2,ABD,BANKED
;I2C1CON0.MDR=1
	BSF	I2C1CON0,MDR,BANKED
;Initialise correct state of I2C module. Not sure why this is needed but it is. Microchip failed to explain why this is required. But, it is.
;SI2CStart
	BANKSEL	0
	RCALL	SI2CSTART
;SI2CSend ( 0xff )
	SETF	I2CBYTE,ACCESS
	RCALL	SI2CSEND
;SI2CStop
	RCALL	SI2CSTOP
;HI2CCurrentMode = 0
	CLRF	HI2CCURRENTMODE,ACCESS
	RETURN

;********************************************************************************

;SOURCE: HWI2C.H (879)
SI2CSEND
;asm showdebug  Redirected for K-mode family probalby called HI2CSend
;asm showdebug  This method sets the registers and register bits to send I2C data
;This is now a state Machine to cater for the new approach with the I2C module
;Select Case HI2C1StateMachine
;case 2  'send data
SYSSELECT1CASE1
	MOVLW	2
	SUBWF	HI2C1STATEMACHINE,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	SYSSELECT1CASE2
;HI2CWaitMSSPTimeout = 0
	CLRF	HI2CWAITMSSPTIMEOUT,ACCESS
;waits up to 254us then creates error message
;do while HI2CWaitMSSPTimeout < 255
SYSDOLOOP_S3
	MOVLW	255
	SUBWF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSC	STATUS, C,ACCESS
	BRA	SYSDOLOOP_E3
;HI2CWaitMSSPTimeout++
	INCF	HI2CWAITMSSPTIMEOUT,F,ACCESS
;Wait for this event
;if I2C1STAT1.TXBE = 1 then
	BANKSEL	I2C1STAT1
	BTFSS	I2C1STAT1,TXBE,BANKED
	BRA	ELSE15_1
;Set the byte count to 1, place outbyte in register, and wait for hardware state machine
;I2C1CNT = 1
	MOVLW	1
	MOVWF	I2C1CNTL,BANKED
;I2C1TXB = I2Cbyte
	MOVFF	I2CBYTE,I2C1TXB
;SI2CWait4Ack
	BANKSEL	0
	RCALL	SI2CWAIT4ACK
;SI2Cwait4MDR
	RCALL	SI2CWAIT4MDR
;exit Sub
	RETURN
;else
	BRA	ENDIF15
ELSE15_1
;wait 1 us
	MOVLW	5
	MOVWF	DELAYTEMP,ACCESS
DELAYUS4
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS4
;end if
ENDIF15
;loop
	BRA	SYSDOLOOP_S3
SYSDOLOOP_E3
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_TXBE_TIMEOUT
	INCF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	ENDIF16
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_TXBE_TIMEOUT
	MOVLW	2
	IORWF	HI2C1LASTERROR,F,ACCESS
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_TXBE_TIMEOUT
ENDIF16
;case 1  'A start
	BRA	SYSSELECTEND1
SYSSELECT1CASE2
	DECF	HI2C1STATEMACHINE,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	SYSSELECT1CASE3
;Clear the output buffers, set byte count to zero, clear event and place Slave Address in register
;I2C1STAT1.CLRBF = 1
	BANKSEL	I2C1STAT1
	BSF	I2C1STAT1,CLRBF,BANKED
;I2C1CNT = 0
	CLRF	I2C1CNTL,BANKED
;I2C1PIR.SCIF = 0
	BCF	I2C1PIR,SCIF,BANKED
;I2C1ADB1 = I2Cbyte
	MOVFF	I2CBYTE,I2C1ADB1
;wait HI2CITSCLWaitPeriod us
	MOVLW	2
	MOVWF	DELAYTEMP2,ACCESS
DELAYUSO5
	CLRF	DELAYTEMP,ACCESS
DELAYUS5
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS5
	DECFSZ	DELAYTEMP2,F,ACCESS
	BRA	DELAYUSO5
	MOVLW	19
	MOVWF	DELAYTEMP,ACCESS
DELAYUS6
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS6
;Set to start
;I2C1CON0.S = 1
	BSF	I2C1CON0,S,BANKED
;HI2CWaitMSSPTimeout = 0
	CLRF	HI2CWAITMSSPTIMEOUT,ACCESS
;waits up to 254us then creates error message
;do while HI2CWaitMSSPTimeout < 255
SYSDOLOOP_S4
	MOVLW	255
	SUBWF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSC	STATUS, C,ACCESS
	BRA	SYSDOLOOP_E4
;HI2CWaitMSSPTimeout++
	INCF	HI2CWAITMSSPTIMEOUT,F,ACCESS
;Wait for this event
;if I2C1PIR.SCIF = 1 then
	BTFSS	I2C1PIR,SCIF,BANKED
	BRA	ELSE17_1
;wait HI2CITSCLWaitPeriod us
	MOVLW	2
	MOVWF	DELAYTEMP2,ACCESS
DELAYUSO7
	CLRF	DELAYTEMP,ACCESS
DELAYUS7
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS7
	DECFSZ	DELAYTEMP2,F,ACCESS
	BRA	DELAYUSO7
	MOVLW	19
	MOVWF	DELAYTEMP,ACCESS
DELAYUS8
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS8
;HI2C1StateMachine = 2  'Set state Machine to send data
	MOVLW	2
	MOVWF	HI2C1STATEMACHINE,ACCESS
;HI2CAckPollState = I2C1CON1.5
	CLRF	HI2CACKPOLLSTATE,ACCESS
	BTFSC	I2C1CON1,5,BANKED
	INCF	HI2CACKPOLLSTATE,F,ACCESS
;exit Sub
	BANKSEL	0
	RETURN
;else
	BRA	ENDIF17
ELSE17_1
;wait HI2CITSCLWaitPeriod us
	MOVLW	2
	MOVWF	DELAYTEMP2,ACCESS
DELAYUSO9
	CLRF	DELAYTEMP,ACCESS
DELAYUS9
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS9
	DECFSZ	DELAYTEMP2,F,ACCESS
	BRA	DELAYUSO9
	MOVLW	19
	MOVWF	DELAYTEMP,ACCESS
DELAYUS10
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS10
;end if
ENDIF17
;loop
	BRA	SYSDOLOOP_S4
SYSDOLOOP_E4
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_START_TIMEOUT
	INCF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	ENDIF18
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_START_TIMEOUT
	MOVLW	4
	IORWF	HI2C1LASTERROR,F,ACCESS
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_START_TIMEOUT
ENDIF18
;case 3  'A restart
	BRA	SYSSELECTEND1
SYSSELECT1CASE3
	MOVLW	3
	SUBWF	HI2C1STATEMACHINE,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	SYSSELECTEND1
;wait for hardware machine to settle
;wait while I2C1STAT0.MMA = 1
SYSWAITLOOP2
	BANKSEL	I2C1STAT0
	BTFSC	I2C1STAT0,MMA,BANKED
	BRA	SYSWAITLOOP2
;set count to zero, place Slave address in register and clear event
;I2C1CNT = 0
	CLRF	I2C1CNTL,BANKED
;I2C1ADB1 = I2Cbyte
	MOVFF	I2CBYTE,I2C1ADB1
;I2C1PIR.SCIF = 0
	BCF	I2C1PIR,SCIF,BANKED
;HI2CWaitMSSPTimeout = 0
	CLRF	HI2CWAITMSSPTIMEOUT,ACCESS
;waits up to 254us then creates error message
;do while HI2CWaitMSSPTimeout < 255
SYSDOLOOP_S5
	MOVLW	255
	SUBWF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSC	STATUS, C,ACCESS
	BRA	SYSDOLOOP_E5
;HI2CWaitMSSPTimeout++
	INCF	HI2CWAITMSSPTIMEOUT,F,ACCESS
;Wait for this event
;if I2C1PIR.SCIF = 1 then
	BTFSS	I2C1PIR,SCIF,BANKED
	BRA	ELSE19_1
;HI2C1StateMachine = 2  'Set state Machine to send data
	MOVLW	2
	MOVWF	HI2C1STATEMACHINE,ACCESS
;HI2CAckPollState = I2C1CON1.5
	CLRF	HI2CACKPOLLSTATE,ACCESS
	BTFSC	I2C1CON1,5,BANKED
	INCF	HI2CACKPOLLSTATE,F,ACCESS
;exit Sub
	BANKSEL	0
	RETURN
;else
	BRA	ENDIF19
ELSE19_1
;Set as Start and Clear Restart
;I2C1CON0.S = 1
	BSF	I2C1CON0,S,BANKED
;I2C1CON0.RSEN=0
	BCF	I2C1CON0,RSEN,BANKED
;wait 1 us
	MOVLW	5
	MOVWF	DELAYTEMP,ACCESS
DELAYUS11
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS11
;end if
ENDIF19
;loop
	BRA	SYSDOLOOP_S5
SYSDOLOOP_E5
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_RESTART_TIMEOUT
	INCF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	ENDIF20
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_RESTART_TIMEOUT
	MOVLW	8
	IORWF	HI2C1LASTERROR,F,ACCESS
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_RESTART_TIMEOUT
ENDIF20
;end select
SYSSELECTEND1
	BANKSEL	0
	RETURN

;********************************************************************************

;SOURCE: HWI2C.H (831)
SI2CSTART
;asm showdebug  Redirected for K-Mode family probalby called HI2CStart
;asm showdebug  This method sets the registers and register bits to generate the I2C  START signal. Master_mode only.
;HI2C1StateMachine = 1
	MOVLW	1
	MOVWF	HI2C1STATEMACHINE,ACCESS
;HI2CWaitMSSPTimeout = false
	CLRF	HI2CWAITMSSPTIMEOUT,ACCESS
;Clear the error state variable
;HI2C1lastError = I2C1_GOOD
	CLRF	HI2C1LASTERROR,ACCESS
	RETURN

;********************************************************************************

;SOURCE: HWI2C.H (850)
SI2CSTOP
;asm showdebug  Redirected for K-mode family probalby called HI2CStop
;asm showdebug  This method sets the registers and register bits to generate the I2C  STOP signal
;Waits up to 254us then set the error state
;HI2C1StateMachine = 0
	CLRF	HI2C1STATEMACHINE,ACCESS
;HI2CWaitMSSPTimeout = 0
	CLRF	HI2CWAITMSSPTIMEOUT,ACCESS
;do while HI2CWaitMSSPTimeout < 255
SYSDOLOOP_S2
	MOVLW	255
	SUBWF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSC	STATUS, C,ACCESS
	BRA	SYSDOLOOP_E2
;HI2CWaitMSSPTimeout++
	INCF	HI2CWAITMSSPTIMEOUT,F,ACCESS
;Wait till this event
;if I2C1PIR.PCIF = 1 then
	BANKSEL	I2C1PIR
	BTFSS	I2C1PIR,PCIF,BANKED
	BRA	ELSE13_1
;SI2Cwait4Stop
	BANKSEL	0
	RCALL	SI2CWAIT4STOP
;TSCL wait, part of the specificiation of the I2C Module
;wait HI2CITSCLWaitPeriod us
	MOVLW	2
	MOVWF	DELAYTEMP2,ACCESS
DELAYUSO1
	CLRF	DELAYTEMP,ACCESS
DELAYUS1
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS1
	DECFSZ	DELAYTEMP2,F,ACCESS
	BRA	DELAYUSO1
	MOVLW	19
	MOVWF	DELAYTEMP,ACCESS
DELAYUS2
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS2
;exit sub
	RETURN
;else
	BRA	ENDIF13
ELSE13_1
;wait 1 us
	MOVLW	5
	MOVWF	DELAYTEMP,ACCESS
DELAYUS3
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS3
;end if
ENDIF13
;loop
	BRA	SYSDOLOOP_S2
SYSDOLOOP_E2
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_STOP_TIMEOUT
	INCF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	ENDIF14
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_STOP_TIMEOUT
	MOVLW	128
	IORWF	HI2C1LASTERROR,F,ACCESS
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_STOP_TIMEOUT
ENDIF14
	BANKSEL	0
	RETURN

;********************************************************************************

;SOURCE: HWI2C.H (1013)
SI2CWAIT4ACK
;HI2CWaitMSSPTimeout = 0
	CLRF	HI2CWAITMSSPTIMEOUT,ACCESS
;waits up to 254us then creates error message
;do while HI2CWaitMSSPTimeout < 255
SYSDOLOOP_S6
	MOVLW	255
	SUBWF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSC	STATUS, C,ACCESS
	BRA	SYSDOLOOP_E6
;HI2CWaitMSSPTimeout++
	INCF	HI2CWAITMSSPTIMEOUT,F,ACCESS
;Wait for this event
;if I2C1CON1.ACKSTAT = 0 then
	BANKSEL	I2C1CON1
	BTFSC	I2C1CON1,ACKSTAT,BANKED
	BRA	ELSE23_1
;Set status
;HI2CAckPollState = !I2C1CON1.ACKSTAT
	CLRF	SYSTEMP1,ACCESS
	BTFSC	I2C1CON1,ACKSTAT,BANKED
	INCF	SYSTEMP1,F,ACCESS
	COMF	SYSTEMP1,W,ACCESS
	MOVWF	HI2CACKPOLLSTATE,ACCESS
;exit sub
	BANKSEL	0
	RETURN
;else
	BRA	ENDIF23
ELSE23_1
;wait 1 us
	MOVLW	5
	MOVWF	DELAYTEMP,ACCESS
DELAYUS12
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS12
;end if
ENDIF23
;loop
	BRA	SYSDOLOOP_S6
SYSDOLOOP_E6
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_ACK_TIMEOUT
	INCF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	ENDIF24
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_ACK_TIMEOUT
	MOVLW	32
	IORWF	HI2C1LASTERROR,F,ACCESS
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_ACK_TIMEOUT
ENDIF24
;HI2CWaitMSSPTimeout is now TRUE = 255
	BANKSEL	0
	RETURN

;********************************************************************************

;SOURCE: HWI2C.H (1042)
SI2CWAIT4MDR
;HI2CWaitMSSPTimeout = 0
	CLRF	HI2CWAITMSSPTIMEOUT,ACCESS
;waits up to 254us then creates error message
;do while HI2CWaitMSSPTimeout < 255
SYSDOLOOP_S7
	MOVLW	255
	SUBWF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSC	STATUS, C,ACCESS
	BRA	SYSDOLOOP_E7
;HI2CWaitMSSPTimeout++
	INCF	HI2CWAITMSSPTIMEOUT,F,ACCESS
;wait for this event
;if I2C1CON0.MDR = 0 then
	BANKSEL	I2C1CON0
	BTFSC	I2C1CON0,MDR,BANKED
	BRA	ELSE26_1
;exit sub
	BANKSEL	0
	RETURN
;else
	BRA	ENDIF26
ELSE26_1
;wait 1 us
	MOVLW	5
	MOVWF	DELAYTEMP,ACCESS
DELAYUS13
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS13
;end if
ENDIF26
;loop
	BRA	SYSDOLOOP_S7
SYSDOLOOP_E7
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_MDR_TIMEOUT
	INCF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	ENDIF27
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_MDR_TIMEOUT
	MOVLW	64
	IORWF	HI2C1LASTERROR,F,ACCESS
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_MDR_TIMEOUT
ENDIF27
;HI2CWaitMSSPTimeout is now TRUE = 255
	BANKSEL	0
	RETURN

;********************************************************************************

;SOURCE: HWI2C.H (1065)
SI2CWAIT4STOP
;HI2CWaitMSSPTimeout = 0
	CLRF	HI2CWAITMSSPTIMEOUT,ACCESS
;waits up to 254us then creates error message
;do while HI2CWaitMSSPTimeout < 255
SYSDOLOOP_S8
	MOVLW	255
	SUBWF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSC	STATUS, C,ACCESS
	BRA	SYSDOLOOP_E8
;HI2CWaitMSSPTimeout++
	INCF	HI2CWAITMSSPTIMEOUT,F,ACCESS
;Wait for this event
;if I2C1PIR.PCIF = 1 then
	BANKSEL	I2C1PIR
	BTFSS	I2C1PIR,PCIF,BANKED
	BRA	ELSE28_1
;exit sub
	BANKSEL	0
	RETURN
;else
	BRA	ENDIF28
ELSE28_1
;wait 1 us
	MOVLW	5
	MOVWF	DELAYTEMP,ACCESS
DELAYUS14
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS14
;end if
ENDIF28
;loop
	BRA	SYSDOLOOP_S8
SYSDOLOOP_E8
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_STOP_TIMEOUT
	INCF	HI2CWAITMSSPTIMEOUT,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	ENDIF29
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_STOP_TIMEOUT
	MOVLW	128
	IORWF	HI2C1LASTERROR,F,ACCESS
;if HI2CWaitMSSPTimeout = 255 then HI2C1lastError = HI2C1lastError or I2C1_STOP_TIMEOUT
ENDIF29
;HI2CWaitMSSPTimeout is now TRUE = 255
	BANKSEL	0
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3153)
SYSCOMPEQUAL
;Dim SysByteTempA, SysByteTempB, SysByteTempX as byte
;setf SysByteTempX
	SETF	SYSBYTETEMPX,ACCESS
;movf SysByteTempB, W
	MOVF	SYSBYTETEMPB, W,ACCESS
;cpfseq SysByteTempA
	CPFSEQ	SYSBYTETEMPA,ACCESS
;clrf SysByteTempX
	CLRF	SYSBYTETEMPX,ACCESS
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (2868)
SYSDIVSUB
;dim SysByteTempA as byte
;dim SysByteTempB as byte
;dim SysByteTempX as byte
;Check for div/0
;movf SysByteTempB, F
	MOVF	SYSBYTETEMPB, F,ACCESS
;btfsc STATUS, Z
	BTFSC	STATUS, Z,ACCESS
;return
	RETURN
;Main calc routine
;SysByteTempX = 0
	CLRF	SYSBYTETEMPX,ACCESS
;SysDivLoop = 8
	MOVLW	8
	MOVWF	SYSDIVLOOP,ACCESS
SYSDIV8START
;bcf STATUS, C
	BCF	STATUS, C,ACCESS
;rlf SysByteTempA, F
	RLCF	SYSBYTETEMPA, F,ACCESS
;rlf SysByteTempX, F
	RLCF	SYSBYTETEMPX, F,ACCESS
;movf SysByteTempB, W
	MOVF	SYSBYTETEMPB, W,ACCESS
;subwf SysByteTempX, F
	SUBWF	SYSBYTETEMPX, F,ACCESS
;bsf SysByteTempA, 0
	BSF	SYSBYTETEMPA, 0,ACCESS
;btfsc STATUS, C
	BTFSC	STATUS, C,ACCESS
;goto Div8NotNeg
	BRA	DIV8NOTNEG
;bcf SysByteTempA, 0
	BCF	SYSBYTETEMPA, 0,ACCESS
;movf SysByteTempB, W
	MOVF	SYSBYTETEMPB, W,ACCESS
;addwf SysByteTempX, F
	ADDWF	SYSBYTETEMPX, F,ACCESS
DIV8NOTNEG
;decfsz SysDivLoop, F
	DECFSZ	SYSDIVLOOP, F,ACCESS
;goto SysDiv8Start
	BRA	SYSDIV8START
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (1646)
SYSREADSTRING
;Dim SysCalcTempA As Byte
;Dim SysStringLength As Byte
;ChipFamily 16 support
;Get length
;TBLRD*+
	TBLRD*+
;movff TABLAT,SysCalcTempA
	MOVFF	TABLAT,SYSCALCTEMPA
;movff TABLAT,INDF1
	MOVFF	TABLAT,INDF1
;goto SysStringReadCheck
	BRA	SYSSTRINGREADCHECK
SYSREADSTRINGPART
;TBLRD*+
	TBLRD*+
;movf TABLAT, W
	MOVF	TABLAT, W,ACCESS
;movwf SysCalcTempA
	MOVWF	SYSCALCTEMPA,ACCESS
;addwf SysStringLength,F
	ADDWF	SYSSTRINGLENGTH,F,ACCESS
;Check length
SYSSTRINGREADCHECK
;If length is 0, exit
;movf SysCalcTempA,F
	MOVF	SYSCALCTEMPA,F,ACCESS
;btfsc STATUS,Z
	BTFSC	STATUS,Z,ACCESS
;return
	RETURN
;Copy
SYSSTRINGREAD
;Copy char
;TBLRD*+
	TBLRD*+
;movff TABLAT,PREINC1
	MOVFF	TABLAT,PREINC1
;decfsz SysCalcTempA, F
	DECFSZ	SYSCALCTEMPA, F,ACCESS
;goto SysStringRead
	BRA	SYSSTRINGREAD
	RETURN

;********************************************************************************

SYSSTRINGTABLES

STRINGTABLE1
	DB	12,72,97,114,100,119,97,114,101,32,73,50,67


STRINGTABLE2
	DB	3,32,32,32


STRINGTABLE3
	DB	1,32


STRINGTABLE4
	DB	2,45,45


STRINGTABLE5
	DB	2,33,32


STRINGTABLE6
	DB	13,69,110,100,32,111,102,32,83,101,97,114,99,104


;********************************************************************************

;SOURCE: PICAS.H (7)
FN__HEXPICAS
;_HexPICAS(0) = 2
	MOVLW	2
	BANKSEL	SYS_HEXPICAS_0
	MOVWF	SYS_HEXPICAS_0,BANKED
;dim SysStringTemp as byte
;Low nibble
;SysStringTemp = SysValTemp And 0x0F
	MOVLW	15
	ANDWF	SYSVALTEMP,W,ACCESS
	BANKSEL	SYSSTRINGTEMP
	MOVWF	SYSSTRINGTEMP,BANKED
;If SysStringTemp > 9 Then SysStringTemp = SysStringTemp + 7
	SUBLW	9
	BTFSC	STATUS, C,ACCESS
	BRA	ENDIF8
;If SysStringTemp > 9 Then SysStringTemp = SysStringTemp + 7
	MOVLW	7
	ADDWF	SYSSTRINGTEMP,F,BANKED
;If SysStringTemp > 9 Then SysStringTemp = SysStringTemp + 7
ENDIF8
;_HexPICAS(2) = SysStringTemp + 48
	MOVLW	48
	ADDWF	SYSSTRINGTEMP,W,BANKED
	BANKSEL	SYS_HEXPICAS_2
	MOVWF	SYS_HEXPICAS_2,BANKED
;Get high nibble
;For SysStringTemp = 1 to 4
;LEGACY METHOD
	BANKSEL	SYSSTRINGTEMP
	CLRF	SYSSTRINGTEMP,BANKED
SYSFORLOOP3
	INCF	SYSSTRINGTEMP,F,BANKED
;Rotate SysValTemp Right
	RRCF	SYSVALTEMP,F,ACCESS
;Next
	MOVLW	4
	SUBWF	SYSSTRINGTEMP,W,BANKED
	BTFSS	STATUS, C,ACCESS
	BRA	SYSFORLOOP3
SYSFORLOOPEND3
;SysStringTemp = SysValTemp And 0x0F
	MOVLW	15
	ANDWF	SYSVALTEMP,W,ACCESS
	MOVWF	SYSSTRINGTEMP,BANKED
;If SysStringTemp > 9 Then SysStringTemp = SysStringTemp + 7
	SUBLW	9
	BTFSC	STATUS, C,ACCESS
	BRA	ENDIF10
;If SysStringTemp > 9 Then SysStringTemp = SysStringTemp + 7
	MOVLW	7
	ADDWF	SYSSTRINGTEMP,F,BANKED
;If SysStringTemp > 9 Then SysStringTemp = SysStringTemp + 7
ENDIF10
;_HexPICAS(1) = SysStringTemp + 48
	MOVLW	48
	ADDWF	SYSSTRINGTEMP,W,BANKED
	BANKSEL	SYS_HEXPICAS_1
	MOVWF	SYS_HEXPICAS_1,BANKED
	BANKSEL	0
	RETURN

;********************************************************************************


 END
