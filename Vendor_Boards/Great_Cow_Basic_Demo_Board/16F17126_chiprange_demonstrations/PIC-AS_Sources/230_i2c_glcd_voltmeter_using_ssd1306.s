;Program compiled by Great Cow BASIC (1.00.00 Release Candidate 2022-11-06 (Windows 64 bit) : Build 1189) for Microchip PIC-AS
;  See the GCBASIC forums at http://sourceforge.net/projects/gcbasic/forums,
;  Check the documentation and Help at http://gcbasic.sourceforge.net/help/,
;or, email:
;   evanvennn at users dot sourceforge dot net

;********************************************************************************


;Set up the assembler options (Chip type, clock source, other bits and pieces)
;PROCESSOR   16F17126
 PAGEWIDTH   180
 RADIX       DEC
 TITLE       "d:\GreatCowBASICGits\Demonstration_Sources.git\trunk\Vendor_Boards\Great_Cow_Basic_Demo_Board\16F17126_chiprange_demonstrations\230_i2c_glcd_voltmeter_using_ssd1306.s"
 SUBTITLE    "11-14-2022"

; Reverse lookup file(s)
; C:\Program Files\Microchip\xc8\v2.40\pic\include\proc\pic16f17126.inc
; C:\Program Files\Microchip\xc8\v2.40\pic\dat\cfgmap\16f17126.cfgmap
; Alternative CONFIG file is to be found at C:\Program Files\Microchip\xc8\vX.YY\pic\dat\cfgdata as per Microchip support ticket #00730936 

;********************************************************************************

;********************************************************************************
;Explicit CONFIG
 CONFIG FCMEN=ON                                 ;C1 Reverselookup FCMEN = ON
 CONFIG CLKOUTEN=OFF                             ;C1 Reverselookup CLKOUTEN = OFF
 CONFIG RSTOSC=HFINTOSC_32MHz                    ;C1 Reverselookup RSTOSC = HFINTOSC_32MHZ
 CONFIG FEXTOSC=OFF                              ;C1 Reverselookup FEXTOSC = OFF
 CONFIG MCLRE=INTMCLR                            ;C1 Reverselookup MCLRE = INTMCLR
 CONFIG WDTE=OFF                                 ;C1 Reverselookup WDTE = OFF
 CONFIG LVP=OFF                                  ;C1 Reverselookup LVP = OFF
 CONFIG WRTSAF=OFF                               ;C1 Reverselookup WRTSAF = OFF
 CONFIG WRTD=OFF                                 ;C1 Reverselookup WRTD = OFF
 CONFIG WRTB=OFF                                 ;C1 Reverselookup WRTB = OFF
 CONFIG CPD=OFF                                  ;C1 Reverselookup CPD = OFF
 CONFIG CP=OFF                                   ;C1 Reverselookup CP = OFF
;Inferred CONFIG


;********************************************************************************
; The XC8 xc.inc include file.  This MUST be placed after the CONFIG statements.

 #include <xc.inc>

;********************************************************************************

;Set aside RAM memory locations for variables. All variables are global.
GLOBAL	ADCVAL
 ADCVAL                           EQU 32          ; 0X20
GLOBAL	ADCVAL_H
 ADCVAL_H                         EQU 33          ; 0X21
GLOBAL	ADREADPORT
 ADREADPORT                       EQU 34          ; 0X22
GLOBAL	ANGLE
 ANGLE                            EQU 35          ; 0X23
GLOBAL	ANGLE_H
 ANGLE_H                          EQU 36          ; 0X24
GLOBAL	ANSELB
 ANSELB                           EQU 37          ; 0X25
GLOBAL	ASC
 ASC                              EQU 38          ; 0X26
GLOBAL	CHARCODE
 CHARCODE                         EQU 39          ; 0X27
GLOBAL	CHARCOL
 CHARCOL                          EQU 40          ; 0X28
GLOBAL	CHARCOLS
 CHARCOLS                         EQU 42          ; 0X2A
GLOBAL	CHARCOL_H
 CHARCOL_H                        EQU 41          ; 0X29
GLOBAL	CHARLOCX
 CHARLOCX                         EQU 43          ; 0X2B
GLOBAL	CHARLOCX_H
 CHARLOCX_H                       EQU 44          ; 0X2C
GLOBAL	CHARLOCY
 CHARLOCY                         EQU 45          ; 0X2D
GLOBAL	CHARLOCY_H
 CHARLOCY_H                       EQU 46          ; 0X2E
GLOBAL	CHARROW
 CHARROW                          EQU 47          ; 0X2F
GLOBAL	CHARROWS
 CHARROWS                         EQU 49          ; 0X31
GLOBAL	CHARROW_H
 CHARROW_H                        EQU 48          ; 0X30
GLOBAL	COL
 COL                              EQU 50          ; 0X32
GLOBAL	COS
 COS                              EQU 51          ; 0X33
GLOBAL	COS_H
 COS_H                            EQU 52          ; 0X34
GLOBAL	CURRCHARCOL
 CURRCHARCOL                      EQU 53          ; 0X35
GLOBAL	CURRCHARROW
 CURRCHARROW                      EQU 54          ; 0X36
GLOBAL	CURRCHARVAL
 CURRCHARVAL                      EQU 55          ; 0X37
GLOBAL	DELAYTEMP
 DELAYTEMP                        EQU 112          ; 0X70
GLOBAL	DELAYTEMP2
 DELAYTEMP2                       EQU 113          ; 0X71
GLOBAL	DRAWLINE
 DRAWLINE                         EQU 56          ; 0X38
GLOBAL	DRAWLINE_H
 DRAWLINE_H                       EQU 57          ; 0X39
GLOBAL	GLCDBACKGROUND
 GLCDBACKGROUND                   EQU 58          ; 0X3A
GLOBAL	GLCDBACKGROUND_H
 GLCDBACKGROUND_H                 EQU 59          ; 0X3B
GLOBAL	GLCDBITNO
 GLCDBITNO                        EQU 60          ; 0X3C
GLOBAL	GLCDCHANGE
 GLCDCHANGE                       EQU 61          ; 0X3D
GLOBAL	GLCDCOLOUR
 GLCDCOLOUR                       EQU 62          ; 0X3E
GLOBAL	GLCDCOLOUR_H
 GLCDCOLOUR_H                     EQU 63          ; 0X3F
GLOBAL	GLCDDATATEMP
 GLCDDATATEMP                     EQU 64          ; 0X40
GLOBAL	GLCDFNTDEFAULT
 GLCDFNTDEFAULT                   EQU 65          ; 0X41
GLOBAL	GLCDFNTDEFAULTHEIGHT
 GLCDFNTDEFAULTHEIGHT             EQU 66          ; 0X42
GLOBAL	GLCDFNTDEFAULTSIZE
 GLCDFNTDEFAULTSIZE               EQU 67          ; 0X43
GLOBAL	GLCDFONTWIDTH
 GLCDFONTWIDTH                    EQU 68          ; 0X44
GLOBAL	GLCDFOREGROUND
 GLCDFOREGROUND                   EQU 69          ; 0X45
GLOBAL	GLCDFOREGROUND_H
 GLCDFOREGROUND_H                 EQU 70          ; 0X46
GLOBAL	GLCDPRINTLEN
 GLCDPRINTLEN                     EQU 71          ; 0X47
GLOBAL	GLCDPRINTLOC
 GLCDPRINTLOC                     EQU 72          ; 0X48
GLOBAL	GLCDPRINTLOC_H
 GLCDPRINTLOC_H                   EQU 73          ; 0X49
GLOBAL	GLCDPRINT_STRING_COUNTER
 GLCDPRINT_STRING_COUNTER         EQU 74          ; 0X4A
GLOBAL	GLCDTEMP
 GLCDTEMP                         EQU 75          ; 0X4B
GLOBAL	GLCDTEMP_H
 GLCDTEMP_H                       EQU 76          ; 0X4C
GLOBAL	GLCDX
 GLCDX                            EQU 77          ; 0X4D
GLOBAL	GLCDY
 GLCDY                            EQU 78          ; 0X4E
GLOBAL	GLCD_YORDINATE
 GLCD_YORDINATE                   EQU 79          ; 0X4F
GLOBAL	GLCD_YORDINATE_H
 GLCD_YORDINATE_H                 EQU 80          ; 0X50
GLOBAL	HI2CACKPOLLSTATE
 HI2CACKPOLLSTATE                 EQU 81          ; 0X51
GLOBAL	HI2CCURRENTMODE
 HI2CCURRENTMODE                  EQU 82          ; 0X52
GLOBAL	HI2CWAITMSSPTIMEOUT
 HI2CWAITMSSPTIMEOUT              EQU 83          ; 0X53
GLOBAL	I2CBYTE
 I2CBYTE                          EQU 84          ; 0X54
GLOBAL	LEFT
 LEFT                             EQU 9158          ; 0X23C6
GLOBAL	LINECOLOUR
 LINECOLOUR                       EQU 85          ; 0X55
GLOBAL	LINECOLOUR_H
 LINECOLOUR_H                     EQU 86          ; 0X56
GLOBAL	LINEDIFFX
 LINEDIFFX                        EQU 87          ; 0X57
GLOBAL	LINEDIFFX_H
 LINEDIFFX_H                      EQU 88          ; 0X58
GLOBAL	LINEDIFFX_X2
 LINEDIFFX_X2                     EQU 89          ; 0X59
GLOBAL	LINEDIFFX_X2_H
 LINEDIFFX_X2_H                   EQU 90          ; 0X5A
GLOBAL	LINEDIFFY
 LINEDIFFY                        EQU 91          ; 0X5B
GLOBAL	LINEDIFFY_H
 LINEDIFFY_H                      EQU 92          ; 0X5C
GLOBAL	LINEDIFFY_X2
 LINEDIFFY_X2                     EQU 93          ; 0X5D
GLOBAL	LINEDIFFY_X2_H
 LINEDIFFY_X2_H                   EQU 94          ; 0X5E
GLOBAL	LINEERR
 LINEERR                          EQU 95          ; 0X5F
GLOBAL	LINEERR_H
 LINEERR_H                        EQU 96          ; 0X60
GLOBAL	LINESTEPX
 LINESTEPX                        EQU 97          ; 0X61
GLOBAL	LINESTEPX_H
 LINESTEPX_H                      EQU 98          ; 0X62
GLOBAL	LINESTEPY
 LINESTEPY                        EQU 99          ; 0X63
GLOBAL	LINESTEPY_H
 LINESTEPY_H                      EQU 100          ; 0X64
GLOBAL	LINEX1
 LINEX1                           EQU 101          ; 0X65
GLOBAL	LINEX1_H
 LINEX1_H                         EQU 102          ; 0X66
GLOBAL	LINEX2
 LINEX2                           EQU 103          ; 0X67
GLOBAL	LINEX2_H
 LINEX2_H                         EQU 104          ; 0X68
GLOBAL	LINEY1
 LINEY1                           EQU 105          ; 0X69
GLOBAL	LINEY1_H
 LINEY1_H                         EQU 106          ; 0X6A
GLOBAL	LINEY2
 LINEY2                           EQU 107          ; 0X6B
GLOBAL	LINEY2_H
 LINEY2_H                         EQU 108          ; 0X6C
GLOBAL	LOCX
 LOCX                             EQU 109          ; 0X6D
GLOBAL	LOCY
 LOCY                             EQU 110          ; 0X6E
GLOBAL	L_CALIBRATE
 L_CALIBRATE                      EQU 160          ; 0XA0
GLOBAL	L_CALIBRATE_H
 L_CALIBRATE_H                    EQU 161          ; 0XA1
GLOBAL	L_FROMHIGH
 L_FROMHIGH                       EQU 162          ; 0XA2
GLOBAL	L_FROMHIGH_H
 L_FROMHIGH_H                     EQU 163          ; 0XA3
GLOBAL	L_FROMLOW
 L_FROMLOW                        EQU 164          ; 0XA4
GLOBAL	L_FROMLOW_H
 L_FROMLOW_H                      EQU 165          ; 0XA5
GLOBAL	L_MAP
 L_MAP                            EQU 166          ; 0XA6
GLOBAL	L_MAP_H
 L_MAP_H                          EQU 167          ; 0XA7
GLOBAL	L_SYSCALC
 L_SYSCALC                        EQU 168          ; 0XA8
GLOBAL	L_SYSCALCF
 L_SYSCALCF                       EQU 170          ; 0XAA
GLOBAL	L_SYSCALCF_E
 L_SYSCALCF_E                     EQU 173          ; 0XAD
GLOBAL	L_SYSCALCF_H
 L_SYSCALCF_H                     EQU 171          ; 0XAB
GLOBAL	L_SYSCALCF_U
 L_SYSCALCF_U                     EQU 172          ; 0XAC
GLOBAL	L_SYSCALC_H
 L_SYSCALC_H                      EQU 169          ; 0XA9
GLOBAL	L_TOHIGH
 L_TOHIGH                         EQU 174          ; 0XAE
GLOBAL	L_TOHIGH_H
 L_TOHIGH_H                       EQU 175          ; 0XAF
GLOBAL	L_TOLOW
 L_TOLOW                          EQU 176          ; 0XB0
GLOBAL	L_TOLOW_H
 L_TOLOW_H                        EQU 177          ; 0XB1
GLOBAL	MID
 MID                              EQU 9117          ; 0X239D
GLOBAL	OLD_ANGLE
 OLD_ANGLE                        EQU 178          ; 0XB2
GLOBAL	OLD_ANGLE_H
 OLD_ANGLE_H                      EQU 179          ; 0XB3
GLOBAL	OLD_XEND
 OLD_XEND                         EQU 111          ; 0X6F
GLOBAL	OLD_YEND
 OLD_YEND                         EQU 180          ; 0XB4
GLOBAL	POSCHARX
 POSCHARX                         EQU 181          ; 0XB5
GLOBAL	POSCHARX_H
 POSCHARX_H                       EQU 182          ; 0XB6
GLOBAL	POSCHARY
 POSCHARY                         EQU 183          ; 0XB7
GLOBAL	PRINTLOCX
 PRINTLOCX                        EQU 184          ; 0XB8
GLOBAL	PRINTLOCX_H
 PRINTLOCX_H                      EQU 185          ; 0XB9
GLOBAL	PRINTLOCY
 PRINTLOCY                        EQU 186          ; 0XBA
GLOBAL	PRINTLOCY_H
 PRINTLOCY_H                      EQU 187          ; 0XBB
GLOBAL	RADIUS
 RADIUS                           EQU 188          ; 0XBC
GLOBAL	READAD
 READAD                           EQU 189          ; 0XBD
GLOBAL	ROW
 ROW                              EQU 190          ; 0XBE
GLOBAL	SCALE
 SCALE                            EQU 191          ; 0XBF
GLOBAL	SCALE_H
 SCALE_H                          EQU 192          ; 0XC0
GLOBAL	SIN
 SIN                              EQU 193          ; 0XC1
GLOBAL	SIN_H
 SIN_H                            EQU 194          ; 0XC2
GLOBAL	SSD1306SENDBYTE
 SSD1306SENDBYTE                  EQU 195          ; 0XC3
GLOBAL	SSD1306_BUFFERALIAS
 SSD1306_BUFFERALIAS              EQU 9199          ; 0X23EF
GLOBAL	SSD1306_BUFFERLOCATIONCALC
 SSD1306_BUFFERLOCATIONCALC       EQU 196          ; 0XC4
GLOBAL	SSD1306_BUFFERLOCATIONCALC_H
 SSD1306_BUFFERLOCATIONCALC_H     EQU 197          ; 0XC5
GLOBAL	STR
 STR                              EQU 9111          ; 0X2397
GLOBAL	STRINGPOINTER
 STRINGPOINTER                    EQU 198          ; 0XC6
GLOBAL	SYSARRAYTEMP1
 SYSARRAYTEMP1                    EQU 199          ; 0XC7
GLOBAL	SYSARRAYTEMP2
 SYSARRAYTEMP2                    EQU 200          ; 0XC8
GLOBAL	SYSBYTETEMPA
 SYSBYTETEMPA                     EQU 117          ; 0X75
GLOBAL	SYSBYTETEMPB
 SYSBYTETEMPB                     EQU 121          ; 0X79
GLOBAL	SYSBYTETEMPX
 SYSBYTETEMPX                     EQU 112          ; 0X70
GLOBAL	SYSCALCTEMPA
 SYSCALCTEMPA                     EQU 117          ; 0X75
GLOBAL	SYSCALCTEMPX
 SYSCALCTEMPX                     EQU 112          ; 0X70
GLOBAL	SYSCALCTEMPX_H
 SYSCALCTEMPX_H                   EQU 113          ; 0X71
GLOBAL	SYSCHAR
 SYSCHAR                          EQU 201          ; 0XC9
GLOBAL	SYSCHARCOUNT
 SYSCHARCOUNT                     EQU 202          ; 0XCA
GLOBAL	SYSCHARSTART
 SYSCHARSTART                     EQU 203          ; 0XCB
GLOBAL	SYSDIVLOOP
 SYSDIVLOOP                       EQU 116          ; 0X74
GLOBAL	SYSDIVMULTA
 SYSDIVMULTA                      EQU 119          ; 0X77
GLOBAL	SYSDIVMULTA_H
 SYSDIVMULTA_H                    EQU 120          ; 0X78
GLOBAL	SYSDIVMULTB
 SYSDIVMULTB                      EQU 123          ; 0X7B
GLOBAL	SYSDIVMULTB_H
 SYSDIVMULTB_H                    EQU 124          ; 0X7C
GLOBAL	SYSDIVMULTX
 SYSDIVMULTX                      EQU 114          ; 0X72
GLOBAL	SYSDIVMULTX_H
 SYSDIVMULTX_H                    EQU 115          ; 0X73
GLOBAL	SYSFORLOOPABSVALUE8
 SYSFORLOOPABSVALUE8              EQU 204          ; 0XCC
GLOBAL	SYSFORLOOPABSVALUE8_H
 SYSFORLOOPABSVALUE8_H            EQU 205          ; 0XCD
GLOBAL	SYSFORLOOPSTEP0
 SYSFORLOOPSTEP0                  EQU 206          ; 0XCE
GLOBAL	SYSFORLOOPSTEP0_H
 SYSFORLOOPSTEP0_H                EQU 207          ; 0XCF
GLOBAL	SYSFORLOOPSTEP7
 SYSFORLOOPSTEP7                  EQU 208          ; 0XD0
GLOBAL	SYSFORLOOPSTEP7_H
 SYSFORLOOPSTEP7_H                EQU 209          ; 0XD1
GLOBAL	SYSINTEGERTEMPA
 SYSINTEGERTEMPA                  EQU 117          ; 0X75
GLOBAL	SYSINTEGERTEMPA_H
 SYSINTEGERTEMPA_H                EQU 118          ; 0X76
GLOBAL	SYSINTEGERTEMPB
 SYSINTEGERTEMPB                  EQU 121          ; 0X79
GLOBAL	SYSINTEGERTEMPB_H
 SYSINTEGERTEMPB_H                EQU 122          ; 0X7A
GLOBAL	SYSINTEGERTEMPX
 SYSINTEGERTEMPX                  EQU 112          ; 0X70
GLOBAL	SYSINTEGERTEMPX_H
 SYSINTEGERTEMPX_H                EQU 113          ; 0X71
GLOBAL	SYSLCDPRINTDATAHANDLER
 SYSLCDPRINTDATAHANDLER           EQU 210          ; 0XD2
GLOBAL	SYSLCDPRINTDATAHANDLER_H
 SYSLCDPRINTDATAHANDLER_H         EQU 211          ; 0XD3
GLOBAL	SYSLONGDIVMULTA
 SYSLONGDIVMULTA                  EQU 212          ; 0XD4
GLOBAL	SYSLONGDIVMULTA_E
 SYSLONGDIVMULTA_E                EQU 215          ; 0XD7
GLOBAL	SYSLONGDIVMULTA_H
 SYSLONGDIVMULTA_H                EQU 213          ; 0XD5
GLOBAL	SYSLONGDIVMULTA_U
 SYSLONGDIVMULTA_U                EQU 214          ; 0XD6
GLOBAL	SYSLONGDIVMULTB
 SYSLONGDIVMULTB                  EQU 216          ; 0XD8
GLOBAL	SYSLONGDIVMULTB_E
 SYSLONGDIVMULTB_E                EQU 219          ; 0XDB
GLOBAL	SYSLONGDIVMULTB_H
 SYSLONGDIVMULTB_H                EQU 217          ; 0XD9
GLOBAL	SYSLONGDIVMULTB_U
 SYSLONGDIVMULTB_U                EQU 218          ; 0XDA
GLOBAL	SYSLONGDIVMULTX
 SYSLONGDIVMULTX                  EQU 220          ; 0XDC
GLOBAL	SYSLONGDIVMULTX_E
 SYSLONGDIVMULTX_E                EQU 223          ; 0XDF
GLOBAL	SYSLONGDIVMULTX_H
 SYSLONGDIVMULTX_H                EQU 221          ; 0XDD
GLOBAL	SYSLONGDIVMULTX_U
 SYSLONGDIVMULTX_U                EQU 222          ; 0XDE
GLOBAL	SYSLONGTEMPA
 SYSLONGTEMPA                     EQU 117          ; 0X75
GLOBAL	SYSLONGTEMPA_E
 SYSLONGTEMPA_E                   EQU 120          ; 0X78
GLOBAL	SYSLONGTEMPA_H
 SYSLONGTEMPA_H                   EQU 118          ; 0X76
GLOBAL	SYSLONGTEMPA_U
 SYSLONGTEMPA_U                   EQU 119          ; 0X77
GLOBAL	SYSLONGTEMPB
 SYSLONGTEMPB                     EQU 121          ; 0X79
GLOBAL	SYSLONGTEMPB_E
 SYSLONGTEMPB_E                   EQU 124          ; 0X7C
GLOBAL	SYSLONGTEMPB_H
 SYSLONGTEMPB_H                   EQU 122          ; 0X7A
GLOBAL	SYSLONGTEMPB_U
 SYSLONGTEMPB_U                   EQU 123          ; 0X7B
GLOBAL	SYSLONGTEMPX
 SYSLONGTEMPX                     EQU 112          ; 0X70
GLOBAL	SYSLONGTEMPX_E
 SYSLONGTEMPX_E                   EQU 115          ; 0X73
GLOBAL	SYSLONGTEMPX_H
 SYSLONGTEMPX_H                   EQU 113          ; 0X71
GLOBAL	SYSLONGTEMPX_U
 SYSLONGTEMPX_U                   EQU 114          ; 0X72
GLOBAL	SYSREPEATTEMP1
 SYSREPEATTEMP1                   EQU 224          ; 0XE0
GLOBAL	SYSREPEATTEMP4
 SYSREPEATTEMP4                   EQU 225          ; 0XE1
GLOBAL	SYSSIGNBYTE
 SYSSIGNBYTE                      EQU 125          ; 0X7D
GLOBAL	SYSSTRDATA
 SYSSTRDATA                       EQU 226          ; 0XE2
GLOBAL	SYSSTRINGA
 SYSSTRINGA                       EQU 119          ; 0X77
GLOBAL	SYSSTRINGA_H
 SYSSTRINGA_H                     EQU 120          ; 0X78
GLOBAL	SYSSTRINGLENGTH
 SYSSTRINGLENGTH                  EQU 118          ; 0X76
GLOBAL	SYSSTRINGTEMP
 SYSSTRINGTEMP                    EQU 227          ; 0XE3
GLOBAL	SYSSYSINSTRINGAHANDLER
 SYSSYSINSTRINGAHANDLER           EQU 228          ; 0XE4
GLOBAL	SYSSYSINSTRINGAHANDLER_H
 SYSSYSINSTRINGAHANDLER_H         EQU 229          ; 0XE5
GLOBAL	SYSSYSINSTRINGHANDLER
 SYSSYSINSTRINGHANDLER            EQU 230          ; 0XE6
GLOBAL	SYSSYSINSTRINGHANDLER_H
 SYSSYSINSTRINGHANDLER_H          EQU 231          ; 0XE7
GLOBAL	SYSTEMP1
 SYSTEMP1                         EQU 232          ; 0XE8
GLOBAL	SYSTEMP1_E
 SYSTEMP1_E                       EQU 235          ; 0XEB
GLOBAL	SYSTEMP1_H
 SYSTEMP1_H                       EQU 233          ; 0XE9
GLOBAL	SYSTEMP1_U
 SYSTEMP1_U                       EQU 234          ; 0XEA
GLOBAL	SYSTEMP2
 SYSTEMP2                         EQU 236          ; 0XEC
GLOBAL	SYSTEMP2_H
 SYSTEMP2_H                       EQU 237          ; 0XED
GLOBAL	SYSTEMP3
 SYSTEMP3                         EQU 238          ; 0XEE
GLOBAL	SYSVALTEMP
 SYSVALTEMP                       EQU 288          ; 0X120
GLOBAL	SYSVALTEMP_H
 SYSVALTEMP_H                     EQU 289          ; 0X121
GLOBAL	SYSWAITTEMP10US
 SYSWAITTEMP10US                  EQU 117          ; 0X75
GLOBAL	SYSWAITTEMPMS
 SYSWAITTEMPMS                    EQU 114          ; 0X72
GLOBAL	SYSWAITTEMPMS_H
 SYSWAITTEMPMS_H                  EQU 115          ; 0X73
GLOBAL	SYSWORDTEMPA
 SYSWORDTEMPA                     EQU 117          ; 0X75
GLOBAL	SYSWORDTEMPA_H
 SYSWORDTEMPA_H                   EQU 118          ; 0X76
GLOBAL	SYSWORDTEMPB
 SYSWORDTEMPB                     EQU 121          ; 0X79
GLOBAL	SYSWORDTEMPB_H
 SYSWORDTEMPB_H                   EQU 122          ; 0X7A
GLOBAL	SYSWORDTEMPX
 SYSWORDTEMPX                     EQU 112          ; 0X70
GLOBAL	SYSWORDTEMPX_H
 SYSWORDTEMPX_H                   EQU 113          ; 0X71
GLOBAL	TRIG_ARG1
 TRIG_ARG1                        EQU 290          ; 0X122
GLOBAL	TRIG_ARG1_H
 TRIG_ARG1_H                      EQU 291          ; 0X123
GLOBAL	TRIG_ARG2
 TRIG_ARG2                        EQU 292          ; 0X124
GLOBAL	TRIG_ARG2_H
 TRIG_ARG2_H                      EQU 293          ; 0X125
GLOBAL	TRIG_I
 TRIG_I                           EQU 239          ; 0XEF
GLOBAL	TRIG_REF
 TRIG_REF                         EQU 294          ; 0X126
GLOBAL	TRIG_REF_H
 TRIG_REF_H                       EQU 295          ; 0X127
GLOBAL	TRIG_SIGN
 TRIG_SIGN                        EQU 296          ; 0X128
GLOBAL	TRIG_SIGN_H
 TRIG_SIGN_H                      EQU 297          ; 0X129
GLOBAL	TRIG_VAL
 TRIG_VAL                         EQU 298          ; 0X12A
GLOBAL	TRIG_VAL_H
 TRIG_VAL_H                       EQU 299          ; 0X12B
GLOBAL	VOLTS
 VOLTS                            EQU 9106          ; 0X2392
GLOBAL	XCENTRE
 XCENTRE                          EQU 300          ; 0X12C
GLOBAL	XEND
 XEND                             EQU 301          ; 0X12D
GLOBAL	YCENTRE
 YCENTRE                          EQU 302          ; 0X12E
GLOBAL	YEND
 YEND                             EQU 303          ; 0X12F

;********************************************************************************

;ALIAS VARIABLES
GLOBAL	AFSR0
 AFSR0                            EQU 4
GLOBAL	AFSR0_H
 AFSR0_H                          EQU 5
GLOBAL	SYSLEFT_0
 SYSLEFT_0                        EQU 1574
GLOBAL	SYSMID_0
 SYSMID_0                         EQU 1485
GLOBAL	SYSREADADBYTE
 SYSREADADBYTE                    EQU 189
GLOBAL	SYSSCALEWORD
 SYSSCALEWORD                     EQU 191
GLOBAL	SYSSCALEWORD_H
 SYSSCALEWORD_H                   EQU 192
GLOBAL	SYSSTR_0
 SYSSTR_0                         EQU 1479

;********************************************************************************

 PSECT   PROGMEM0,delta=2, abs
 RESETVEC:
;VECTORS
	ORG	0
	PAGESEL	BASPROGRAMSTART
	GOTO	BASPROGRAMSTART
	ORG	4
	RETFIE

;********************************************************************************

;START OF PROGRAM MEMORY PAGE 0
	ORG	5
GLOBAL	BASPROGRAMSTART
BASPROGRAMSTART:
;CALL INITIALISATION ROUTINES
	CALL	INITSYS
	CALL	INITPPS
	CALL	HI2CINIT
	CALL	INITGLCD_SSD1306
	PAGESEL	$

;START OF THE MAIN PROGRAM
;''
;''This demonstration program is a simple GLCD demonstration of the SSD1306 GLCD capabilities and Maths/Trig capabilities.
;''
;''This program demonstrates the basic primatives a voltmeter on a Graphical LCD (GLCD)
;'':
;''You can change the microcontroller, the GLCD and the analogue port.
;''
;''To change the microcontroller simply change the #chip statement
;''To change the GLCD replace GLCD definition
;''To change the analogue port change the ADCChannelSelected constant
;''
;''************************************************************************
;''@author  StanC & EvanV
;''@licence GPL
;''@version 1.00
;''@date    31.10.2022
;----- Configuration
;Chip Settings.
;Template comment at the start of the config file
;
;Template comment at the end of the config file
;' -------------------PORTA----------------
;' Bit#:  -7---6---5---4---3---2---1---0---
;' IO:   -------------SDA-SW------SCL-ADC--
;'-----------------------------------------
;'
;' -------------------PORTB----------------
;' Bit#:  -7---6---5---4---3---2---1---0---
;' IO:    ---------------------------------
;'-----------------------------------------
;'
;' ------------------PORTC-----------------
;' Bit#:  -7---6---5---4---3---2---1---0---
;' IO:    ----TX---------LED--LED-LED LED--
;'-----------------------------------------
;Define constants to make things easier. We can reuse these at any time.
;Dir     RC0         Out
	BCF	TRISC,0
;Dir     RC1         Out
	BCF	TRISC,1
;Dir     RC2         Out
	BCF	TRISC,2
;Dir     RC3         Out
	BCF	TRISC,3
;Dir     POTENTIOMETER In
	BSF	TRISA,0
;Dir     SWITCHIN      In
	BSF	TRISA,3
;Setup Serial port
;Define I2C settings
;Initialise I2C - note for the I2C module the ports need to be set to IN
;Dir HI2C_DATA In
	BSF	TRISA,4
;Dir HI2C_CLOCK In
	BSF	TRISA,1
;*****************************************************************************************************
;Main program commences here.. everything before this is setup for the board.
;analogue port selection
;These constants allow you to change the GLCD memory usage.
;*******************************************************************************************
;Dim radius,xcentre,ycentre,xend,old_xend,yend,old_yend As Byte
;Dim angle,old_angle,adcval As Word
;Dim volts As String * 4
;xcentre=63
	MOVLW	63
	BANKSEL	XCENTRE
	MOVWF	XCENTRE
;ycentre=58
	MOVLW	58
	MOVWF	YCENTRE
;draw dial
;GLCDCLS
	BANKSEL	STATUS
	FCALL	GLCDCLS_SSD1306
;Box 0,0,127,63
	CLRF	LINEX1
	CLRF	LINEX1_H
	CLRF	LINEY1
	CLRF	LINEY1_H
	MOVLW	127
	MOVWF	LINEX2
	CLRF	LINEX2_H
	MOVLW	63
	MOVWF	LINEY2
	CLRF	LINEY2_H
	MOVF	GLCDFOREGROUND,W
	MOVWF	LINECOLOUR
	MOVF	GLCDFOREGROUND_H,W
	MOVWF	LINECOLOUR_H
	FCALL	BOX
;For radius=144 To 141 step -1
	MOVLW	144
	BANKSEL	RADIUS
	MOVWF	RADIUS
GLOBAL	SYSFORLOOP1
SYSFORLOOP1:
;INIT SYSFORLOOPSTEP0 :#0
	MOVLW	255
	MOVWF	SYSFORLOOPSTEP0
	MOVWF	SYSFORLOOPSTEP0_H
;dial
	BANKSEL	STATUS
	FCALL	DIAL
;Next radius
;INTEGER NEGATIVE STEP HANDLER IN FOR-NEXT STATEMENT
	BANKSEL	SYSFORLOOPSTEP0_H
	BTFSS	SYSFORLOOPSTEP0_H,7
	GOTO	ELSE1_1
;IF ( RADIUS - 141) } -SYSFORLOOPSTEP0 THEN :#3N
	MOVLW	141
	SUBWF	RADIUS,W
	MOVWF	SYSTEMP1
	COMF	SYSFORLOOPSTEP0,W
	MOVWF	SYSTEMP2
	COMF	SYSFORLOOPSTEP0_H,W
	MOVWF	SYSTEMP2_H
	INCF	SYSTEMP2,F
	BTFSC	STATUS,2
	INCF	SYSTEMP2_H,F
	MOVF	SYSTEMP1,W
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	MOVF	SYSTEMP2,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	SYSTEMP2_H,W
	MOVWF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHANINT
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF5
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A NEGATIVE VALUE
	BANKSEL	SYSFORLOOPSTEP0
	MOVF	SYSFORLOOPSTEP0,W
	ADDWF	RADIUS,F
	GOTO	SYSFORLOOP1
;END IF
GLOBAL	ENDIF5
ENDIF5:
	GOTO	ENDIF1
GLOBAL	ELSE1_1
ELSE1_1:
;INTEGER POSITIVE STEP HANDLER IN FOR-NEXT STATEMENT
;IF (141 - RADIUS) } SYSFORLOOPSTEP0 THEN :#3P
	MOVF	RADIUS,W
	SUBLW	141
	MOVWF	SYSTEMP1
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	MOVF	SYSFORLOOPSTEP0,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	SYSFORLOOPSTEP0_H,W
	MOVWF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHANINT
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF6
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	BANKSEL	SYSFORLOOPSTEP0
	MOVF	SYSFORLOOPSTEP0,W
	ADDWF	RADIUS,F
	GOTO	SYSFORLOOP1
;END IF
GLOBAL	ENDIF6
ENDIF6:
;END IF
GLOBAL	ENDIF1
ENDIF1:
GLOBAL	SYSFORLOOPEND1
SYSFORLOOPEND1:
;GLCDDrawChar (5,40,Asc("0")):GLCDDrawChar (115,40,Asc("5"))
	MOVLW	5
	MOVWF	CHARLOCX
	CLRF	CHARLOCX_H
	MOVLW	40
	MOVWF	CHARLOCY
	CLRF	CHARLOCY_H
	MOVLW	LOW STRINGTABLE1
	BANKSEL	SYSSYSINSTRINGAHANDLER
	MOVWF	SYSSYSINSTRINGAHANDLER
	MOVLW	(HIGH STRINGTABLE1) | 128
	MOVWF	SYSSYSINSTRINGAHANDLER_H
	MOVLW	1
	MOVWF	SYSCHAR
	BANKSEL	STATUS
	FCALL	FN_ASC
	MOVF	ASC,W
	MOVWF	CHARCODE
	MOVF	GLCDFOREGROUND,W
	MOVWF	LINECOLOUR
	MOVF	GLCDFOREGROUND_H,W
	MOVWF	LINECOLOUR_H
	CALL	GLCDDRAWCHAR_SSD1306
;GLCDDrawChar (5,40,Asc("0")):GLCDDrawChar (115,40,Asc("5"))
	MOVLW	115
	MOVWF	CHARLOCX
	CLRF	CHARLOCX_H
	MOVLW	40
	MOVWF	CHARLOCY
	CLRF	CHARLOCY_H
	MOVLW	LOW STRINGTABLE2
	BANKSEL	SYSSYSINSTRINGAHANDLER
	MOVWF	SYSSYSINSTRINGAHANDLER
	MOVLW	(HIGH STRINGTABLE2) | 128
	MOVWF	SYSSYSINSTRINGAHANDLER_H
	MOVLW	1
	MOVWF	SYSCHAR
	BANKSEL	STATUS
	FCALL	FN_ASC
	MOVF	ASC,W
	MOVWF	CHARCODE
	MOVF	GLCDFOREGROUND,W
	MOVWF	LINECOLOUR
	MOVF	GLCDFOREGROUND_H,W
	MOVWF	LINECOLOUR_H
	CALL	GLCDDRAWCHAR_SSD1306
;radius=120
	MOVLW	120
	BANKSEL	RADIUS
	MOVWF	RADIUS
;angle=1
	MOVLW	1
	BANKSEL	ANGLE
	MOVWF	ANGLE
	CLRF	ANGLE_H
;anglecheck
	FCALL	ANGLECHECK
;Do
GLOBAL	SYSDOLOOP_S1
SYSDOLOOP_S1:
;old_angle=angle
	MOVF	ANGLE,W
	BANKSEL	OLD_ANGLE
	MOVWF	OLD_ANGLE
	BANKSEL	ANGLE_H
	MOVF	ANGLE_H,W
	BANKSEL	OLD_ANGLE_H
	MOVWF	OLD_ANGLE_H
;--- DVM
;adcval=ReadAD(ADCChannelSelected)
	BANKSEL	ADREADPORT
	CLRF	ADREADPORT
	CALL	FN_READAD463
	BANKSEL	SYSREADADBYTE
	MOVF	SYSREADADBYTE,W
	BANKSEL	ADCVAL
	MOVWF	ADCVAL
	CLRF	ADCVAL_H
;Calicabrate to 4.08V
;adcval = scale( adcval, 0, 220, 0, 255 )
	MOVF	ADCVAL,W
	BANKSEL	L_MAP
	MOVWF	L_MAP
	BANKSEL	ADCVAL_H
	MOVF	ADCVAL_H,W
	BANKSEL	L_MAP_H
	MOVWF	L_MAP_H
	CLRF	L_FROMLOW
	CLRF	L_FROMLOW_H
	MOVLW	220
	MOVWF	L_FROMHIGH
	CLRF	L_FROMHIGH_H
	CLRF	L_TOLOW
	CLRF	L_TOLOW_H
	MOVLW	255
	MOVWF	L_TOHIGH
	CLRF	L_TOHIGH_H
	CLRF	L_CALIBRATE
	CLRF	L_CALIBRATE_H
	BANKSEL	STATUS
	FCALL	FN_SCALE531
	BANKSEL	SYSSCALEWORD
	MOVF	SYSSCALEWORD,W
	BANKSEL	ADCVAL
	MOVWF	ADCVAL
	BANKSEL	SYSSCALEWORD_H
	MOVF	SYSSCALEWORD_H,W
	BANKSEL	ADCVAL_H
	MOVWF	ADCVAL_H
;angle=adcval/2
	MOVF	ADCVAL,W
	MOVWF	SYSWORDTEMPA
	MOVF	ADCVAL_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	2
	MOVWF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	FCALL	SYSDIVSUB16
	MOVF	SYSWORDTEMPA,W
	MOVWF	ANGLE
	MOVF	SYSWORDTEMPA_H,W
	MOVWF	ANGLE_H
;
;adcval=adcval*100
	MOVF	ADCVAL,W
	MOVWF	SYSWORDTEMPA
	MOVF	ADCVAL_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	100
	MOVWF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	FCALL	SYSMULTSUB16
	MOVF	SYSWORDTEMPX,W
	MOVWF	ADCVAL
	MOVF	SYSWORDTEMPX_H,W
	MOVWF	ADCVAL_H
;adcval=adcval/51
	MOVF	ADCVAL,W
	MOVWF	SYSWORDTEMPA
	MOVF	ADCVAL_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	51
	MOVWF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	FCALL	SYSDIVSUB16
	MOVF	SYSWORDTEMPA,W
	MOVWF	ADCVAL
	MOVF	SYSWORDTEMPA_H,W
	MOVWF	ADCVAL_H
;volts=Str(adcval)
	MOVF	ADCVAL,W
	BANKSEL	SYSVALTEMP
	MOVWF	SYSVALTEMP
	BANKSEL	ADCVAL_H
	MOVF	ADCVAL_H,W
	BANKSEL	SYSVALTEMP_H
	MOVWF	SYSVALTEMP_H
	BANKSEL	STATUS
	CALL	FN_STR
	MOVLW	LOW VOLTS
	MOVWF	FSR1L
	MOVLW	HIGH VOLTS
	MOVWF	FSR1H
	MOVLW	LOW STR
	MOVWF	FSR0L
	MOVLW	HIGH STR
	MOVWF	FSR0H
	FCALL	SYSCOPYSTRING
;If adcval<10 Then
	MOVF	ADCVAL,W
	MOVWF	SYSWORDTEMPA
	MOVF	ADCVAL_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	10
	MOVWF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	FCALL	SYSCOMPLESSTHAN16
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF2
;volts="0.0"+Left(volts,1,1)
	MOVLW	LOW VOLTS
	BANKSEL	SYSSYSINSTRINGHANDLER
	MOVWF	SYSSYSINSTRINGHANDLER
	MOVLW	HIGH VOLTS
	MOVWF	SYSSYSINSTRINGHANDLER_H
	MOVLW	1
	MOVWF	SYSCHARCOUNT
	BANKSEL	STATUS
	FCALL	FN_LEFT
	MOVLW	LOW VOLTS
	MOVWF	FSR1L
	MOVLW	HIGH VOLTS
	MOVWF	FSR1H
	CLRF	SYSSTRINGLENGTH
	MOVLW	LOW STRINGTABLE3
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH STRINGTABLE3) & 127
	MOVWF	SYSSTRINGA_H
	FCALL	SYSREADSTRINGPART
	MOVLW	LOW LEFT
	MOVWF	FSR0L
	MOVLW	HIGH LEFT
	MOVWF	FSR0H
	FCALL	SYSCOPYSTRINGPART
	MOVLW	LOW VOLTS
	MOVWF	FSR0L
	MOVLW	HIGH VOLTS
	MOVWF	FSR0H
	MOVF	SYSSTRINGLENGTH,W
	MOVWF	INDF0
;Goto volt_format_done
	GOTO	VOLT_FORMAT_DONE
;End If
GLOBAL	ENDIF2
ENDIF2:
;If adcval<100 Then
	MOVF	ADCVAL,W
	MOVWF	SYSWORDTEMPA
	MOVF	ADCVAL_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	100
	MOVWF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	FCALL	SYSCOMPLESSTHAN16
	BTFSS	SYSBYTETEMPX,0
	GOTO	ELSE3_1
;volts="0."+Mid(volts,1,2)
	MOVLW	LOW VOLTS
	BANKSEL	SYSSYSINSTRINGHANDLER
	MOVWF	SYSSYSINSTRINGHANDLER
	MOVLW	HIGH VOLTS
	MOVWF	SYSSYSINSTRINGHANDLER_H
	MOVLW	1
	MOVWF	SYSCHARSTART
	MOVLW	2
	MOVWF	SYSCHARCOUNT
	BANKSEL	STATUS
	FCALL	FN_MID
	MOVLW	LOW VOLTS
	MOVWF	FSR1L
	MOVLW	HIGH VOLTS
	MOVWF	FSR1H
	CLRF	SYSSTRINGLENGTH
	MOVLW	LOW STRINGTABLE4
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH STRINGTABLE4) & 127
	MOVWF	SYSSTRINGA_H
	FCALL	SYSREADSTRINGPART
	MOVLW	LOW MID
	MOVWF	FSR0L
	MOVLW	HIGH MID
	MOVWF	FSR0H
	FCALL	SYSCOPYSTRINGPART
	MOVLW	LOW VOLTS
	MOVWF	FSR0L
	MOVLW	HIGH VOLTS
	MOVWF	FSR0H
	MOVF	SYSSTRINGLENGTH,W
	MOVWF	INDF0
;Else
	GOTO	ENDIF3
GLOBAL	ELSE3_1
ELSE3_1:
;volts=Left(volts,1,1)+"."+Mid(volts,2,2)
	MOVLW	LOW VOLTS
	BANKSEL	SYSSYSINSTRINGHANDLER
	MOVWF	SYSSYSINSTRINGHANDLER
	MOVLW	HIGH VOLTS
	MOVWF	SYSSYSINSTRINGHANDLER_H
	MOVLW	1
	MOVWF	SYSCHARCOUNT
	BANKSEL	STATUS
	FCALL	FN_LEFT
	MOVLW	LOW VOLTS
	BANKSEL	SYSSYSINSTRINGHANDLER
	MOVWF	SYSSYSINSTRINGHANDLER
	MOVLW	HIGH VOLTS
	MOVWF	SYSSYSINSTRINGHANDLER_H
	MOVLW	2
	MOVWF	SYSCHARSTART
	MOVLW	2
	MOVWF	SYSCHARCOUNT
	BANKSEL	STATUS
	FCALL	FN_MID
	MOVLW	LOW VOLTS
	MOVWF	FSR1L
	MOVLW	HIGH VOLTS
	MOVWF	FSR1H
	CLRF	SYSSTRINGLENGTH
	MOVLW	LOW LEFT
	MOVWF	FSR0L
	MOVLW	HIGH LEFT
	MOVWF	FSR0H
	FCALL	SYSCOPYSTRINGPART
	MOVLW	LOW STRINGTABLE5
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH STRINGTABLE5) & 127
	MOVWF	SYSSTRINGA_H
	FCALL	SYSREADSTRINGPART
	MOVLW	LOW MID
	MOVWF	FSR0L
	MOVLW	HIGH MID
	MOVWF	FSR0H
	FCALL	SYSCOPYSTRINGPART
	MOVLW	LOW VOLTS
	MOVWF	FSR0L
	MOVLW	HIGH VOLTS
	MOVWF	FSR0H
	MOVF	SYSSTRINGLENGTH,W
	MOVWF	INDF0
;End If
GLOBAL	ENDIF3
ENDIF3:
GLOBAL	VOLT_FORMAT_DONE
VOLT_FORMAT_DONE:
;---
;anglecheck
	FCALL	ANGLECHECK
;old_xend = xcentre + radius  * sin (old_angle)/255
	BANKSEL	OLD_ANGLE
	MOVF	OLD_ANGLE,W
	BANKSEL	TRIG_ARG2
	MOVWF	TRIG_ARG2
	BANKSEL	OLD_ANGLE_H
	MOVF	OLD_ANGLE_H,W
	BANKSEL	TRIG_ARG2_H
	MOVWF	TRIG_ARG2_H
	BANKSEL	STATUS
	FCALL	FN_SIN
	BANKSEL	RADIUS
	MOVF	RADIUS,W
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	MOVF	SIN,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	SIN_H,W
	MOVWF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	BANKSEL	SYSTEMP2
	MOVWF	SYSTEMP2
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	SYSTEMP2_H
	MOVF	SYSTEMP2,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	SYSTEMP2_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	255
	MOVWF	SYSINTEGERTEMPB
	CLRF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSDIVSUBINT
	MOVF	SYSINTEGERTEMPA,W
	BANKSEL	XCENTRE
	ADDWF	XCENTRE,W
	BANKSEL	OLD_XEND
	MOVWF	OLD_XEND
;old_yend = ycentre - radius  * cos (old_angle)/255
	BANKSEL	OLD_ANGLE
	MOVF	OLD_ANGLE,W
	BANKSEL	TRIG_ARG2
	MOVWF	TRIG_ARG2
	BANKSEL	OLD_ANGLE_H
	MOVF	OLD_ANGLE_H,W
	BANKSEL	TRIG_ARG2_H
	MOVWF	TRIG_ARG2_H
	BANKSEL	STATUS
	FCALL	FN_COS
	BANKSEL	RADIUS
	MOVF	RADIUS,W
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	BANKSEL	COS
	MOVF	COS,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	COS_H,W
	MOVWF	SYSINTEGERTEMPB_H
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	BANKSEL	SYSTEMP1
	MOVWF	SYSTEMP1
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	SYSTEMP1_H
	MOVF	SYSTEMP1,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	SYSTEMP1_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	255
	MOVWF	SYSINTEGERTEMPB
	CLRF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSDIVSUBINT
	MOVF	SYSINTEGERTEMPA,W
	BANKSEL	YCENTRE
	SUBWF	YCENTRE,W
	BANKSEL	OLD_YEND
	MOVWF	OLD_YEND
;xend = xcentre + radius  * sin (angle)/255
	BANKSEL	ANGLE
	MOVF	ANGLE,W
	BANKSEL	TRIG_ARG2
	MOVWF	TRIG_ARG2
	BANKSEL	ANGLE_H
	MOVF	ANGLE_H,W
	BANKSEL	TRIG_ARG2_H
	MOVWF	TRIG_ARG2_H
	BANKSEL	STATUS
	FCALL	FN_SIN
	BANKSEL	RADIUS
	MOVF	RADIUS,W
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	MOVF	SIN,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	SIN_H,W
	MOVWF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	BANKSEL	SYSTEMP1
	MOVWF	SYSTEMP1
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	SYSTEMP1_H
	MOVF	SYSTEMP1,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	SYSTEMP1_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	255
	MOVWF	SYSINTEGERTEMPB
	CLRF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSDIVSUBINT
	MOVF	SYSINTEGERTEMPA,W
	BANKSEL	XCENTRE
	ADDWF	XCENTRE,W
	MOVWF	XEND
;yend = ycentre - radius  * cos (angle)/255
	BANKSEL	ANGLE
	MOVF	ANGLE,W
	BANKSEL	TRIG_ARG2
	MOVWF	TRIG_ARG2
	BANKSEL	ANGLE_H
	MOVF	ANGLE_H,W
	BANKSEL	TRIG_ARG2_H
	MOVWF	TRIG_ARG2_H
	BANKSEL	STATUS
	FCALL	FN_COS
	BANKSEL	RADIUS
	MOVF	RADIUS,W
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	BANKSEL	COS
	MOVF	COS,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	COS_H,W
	MOVWF	SYSINTEGERTEMPB_H
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	BANKSEL	SYSTEMP1
	MOVWF	SYSTEMP1
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	SYSTEMP1_H
	MOVF	SYSTEMP1,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	SYSTEMP1_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	255
	MOVWF	SYSINTEGERTEMPB
	CLRF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSDIVSUBINT
	MOVF	SYSINTEGERTEMPA,W
	BANKSEL	YCENTRE
	SUBWF	YCENTRE,W
	MOVWF	YEND
;If old_angle<>angle Then
	BANKSEL	OLD_ANGLE
	MOVF	OLD_ANGLE,W
	MOVWF	SYSWORDTEMPA
	MOVF	OLD_ANGLE_H,W
	MOVWF	SYSWORDTEMPA_H
	BANKSEL	ANGLE
	MOVF	ANGLE,W
	MOVWF	SYSWORDTEMPB
	MOVF	ANGLE_H,W
	MOVWF	SYSWORDTEMPB_H
	FCALL	SYSCOMPEQUAL16
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF4
;-- update screen if volts has changed
;erase old needle
;Line (xcentre,ycentre,old_xend,old_yend,0)
	BANKSEL	XCENTRE
	MOVF	XCENTRE,W
	BANKSEL	LINEX1
	MOVWF	LINEX1
	CLRF	LINEX1_H
	BANKSEL	YCENTRE
	MOVF	YCENTRE,W
	BANKSEL	LINEY1
	MOVWF	LINEY1
	CLRF	LINEY1_H
	MOVF	OLD_XEND,W
	MOVWF	LINEX2
	CLRF	LINEX2_H
	BANKSEL	OLD_YEND
	MOVF	OLD_YEND,W
	BANKSEL	LINEY2
	MOVWF	LINEY2
	CLRF	LINEY2_H
	CLRF	LINECOLOUR
	CLRF	LINECOLOUR_H
	CALL	_LINE
;draw V
;Line (55,22,63,38):Line (63,38,71,22)
	MOVLW	55
	MOVWF	LINEX1
	CLRF	LINEX1_H
	MOVLW	22
	MOVWF	LINEY1
	CLRF	LINEY1_H
	MOVLW	63
	MOVWF	LINEX2
	CLRF	LINEX2_H
	MOVLW	38
	MOVWF	LINEY2
	CLRF	LINEY2_H
	MOVF	GLCDFOREGROUND,W
	MOVWF	LINECOLOUR
	MOVF	GLCDFOREGROUND_H,W
	MOVWF	LINECOLOUR_H
	CALL	_LINE
;Line (55,22,63,38):Line (63,38,71,22)
	MOVLW	63
	MOVWF	LINEX1
	CLRF	LINEX1_H
	MOVLW	38
	MOVWF	LINEY1
	CLRF	LINEY1_H
	MOVLW	71
	MOVWF	LINEX2
	CLRF	LINEX2_H
	MOVLW	22
	MOVWF	LINEY2
	CLRF	LINEY2_H
	MOVF	GLCDFOREGROUND,W
	MOVWF	LINECOLOUR
	MOVF	GLCDFOREGROUND_H,W
	MOVWF	LINECOLOUR_H
	CALL	_LINE
;print new voltage
;print Voltage
;GLCDPrint (50,10,volts,1)
	MOVLW	50
	BANKSEL	PRINTLOCX
	MOVWF	PRINTLOCX
	CLRF	PRINTLOCX_H
	MOVLW	10
	MOVWF	PRINTLOCY
	CLRF	PRINTLOCY_H
	MOVLW	LOW VOLTS
	MOVWF	SYSLCDPRINTDATAHANDLER
	MOVLW	HIGH VOLTS
	MOVWF	SYSLCDPRINTDATAHANDLER_H
	MOVLW	1
	BANKSEL	LINECOLOUR
	MOVWF	LINECOLOUR
	CLRF	LINECOLOUR_H
	FCALL	GLCDPRINT12
;draw new needle
;Line (xcentre,ycentre,xend,yend,1)
	BANKSEL	XCENTRE
	MOVF	XCENTRE,W
	BANKSEL	LINEX1
	MOVWF	LINEX1
	CLRF	LINEX1_H
	BANKSEL	YCENTRE
	MOVF	YCENTRE,W
	BANKSEL	LINEY1
	MOVWF	LINEY1
	CLRF	LINEY1_H
	BANKSEL	XEND
	MOVF	XEND,W
	BANKSEL	LINEX2
	MOVWF	LINEX2
	CLRF	LINEX2_H
	BANKSEL	YEND
	MOVF	YEND,W
	BANKSEL	LINEY2
	MOVWF	LINEY2
	CLRF	LINEY2_H
	MOVLW	1
	MOVWF	LINECOLOUR
	CLRF	LINECOLOUR_H
	CALL	_LINE
;Wait 20 ms
	MOVLW	20
	MOVWF	SYSWAITTEMPMS
	CLRF	SYSWAITTEMPMS_H
	FCALL	DELAY_MS
;End If
GLOBAL	ENDIF4
ENDIF4:
;Loop
	GOTO	SYSDOLOOP_S1
GLOBAL	SYSDOLOOP_E1
SYSDOLOOP_E1:
;end main
;
;
;asm showdebug  GGLCD SSD1306 buffer is 1024bytes
GLOBAL	BASPROGRAMEND
BASPROGRAMEND:
	SLEEP
	GOTO	BASPROGRAMEND

;********************************************************************************

;SOURCE: GLCD_SSD1306.H (475)
GLOBAL	GLCDDRAWCHAR_SSD1306
GLCDDRAWCHAR_SSD1306:
;This is now in four parts
;1. Handler for GLCD LM mode
;2. Preamble
;3. GCB Font set handler
;4. OLED Font set handler
;***** Handler for GLCD LM mode
;****** Preamble
;invert colors if required
;if LineColour <> GLCDForeground  then
	MOVF	LINECOLOUR,W
	MOVWF	SYSWORDTEMPA
	MOVF	LINECOLOUR_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVF	GLCDFOREGROUND,W
	MOVWF	SYSWORDTEMPB
	MOVF	GLCDFOREGROUND_H,W
	MOVWF	SYSWORDTEMPB_H
	FCALL	SYSCOMPEQUAL16
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF25
;Inverted Colours
;GLCDBackground = 1
	MOVLW	1
	MOVWF	GLCDBACKGROUND
	CLRF	GLCDBACKGROUND_H
;GLCDForeground = 0
	CLRF	GLCDFOREGROUND
	CLRF	GLCDFOREGROUND_H
;end if
GLOBAL	ENDIF25
ENDIF25:
;dim CharCol, CharRow as word
;CharCode -= 15
	MOVLW	15
	SUBWF	CHARCODE,F
;CharCol=0
	CLRF	CHARCOL
	CLRF	CHARCOL_H
;Cursor_Position_SSD1306 ( CharLocX , CharLocY )
	MOVF	CHARLOCX,W
	MOVWF	LOCX
	MOVF	CHARLOCY,W
	MOVWF	LOCY
	FCALL	CURSOR_POSITION_SSD1306
;1.14 Added transaction
;****** GCB Font set handler
;if CharCode>=178 and CharCode<=202 then
	MOVF	CHARCODE,W
	MOVWF	SYSBYTETEMPA
	MOVLW	178
	MOVWF	SYSBYTETEMPB
	FCALL	SYSCOMPLESSTHAN
	COMF	SYSBYTETEMPX,F
	MOVF	SYSBYTETEMPX,W
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	BANKSEL	CHARCODE
	MOVF	CHARCODE,W
	MOVWF	SYSBYTETEMPB
	MOVLW	202
	MOVWF	SYSBYTETEMPA
	FCALL	SYSCOMPLESSTHAN
	COMF	SYSBYTETEMPX,F
	BANKSEL	SYSTEMP3
	MOVF	SYSTEMP3,W
	ANDWF	SYSBYTETEMPX,W
	MOVWF	SYSTEMP1
	BTFSS	SYSTEMP1,0
	GOTO	ENDIF26
;CharLocY=CharLocY-1
	MOVLW	1
	BANKSEL	CHARLOCY
	SUBWF	CHARLOCY,F
	MOVLW	0
	SUBWFB	CHARLOCY_H,F
;end if
GLOBAL	ENDIF26
ENDIF26:
;For CurrCharCol = 1 to 5
;LEGACY METHOD
	BANKSEL	CURRCHARCOL
	CLRF	CURRCHARCOL
GLOBAL	SYSFORLOOP10
SYSFORLOOP10:
	INCF	CURRCHARCOL,F
;Select Case CurrCharCol
;Case 1: ReadTable GLCDCharCol3, CharCode, CurrCharVal
GLOBAL	SYSSELECT1CASE1
SYSSELECT1CASE1:
	DECF	CURRCHARCOL,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT1CASE2
;Case 1: ReadTable GLCDCharCol3, CharCode, CurrCharVal
	MOVF	CHARCODE,W
	MOVWF	SYSSTRINGA
	FCALL	GLCDCHARCOL3
	MOVWF	CURRCHARVAL
;Case 2: ReadTable GLCDCharCol4, CharCode, CurrCharVal
	GOTO	SYSSELECTEND1
GLOBAL	SYSSELECT1CASE2
SYSSELECT1CASE2:
	MOVLW	2
	SUBWF	CURRCHARCOL,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT1CASE3
;Case 2: ReadTable GLCDCharCol4, CharCode, CurrCharVal
	MOVF	CHARCODE,W
	MOVWF	SYSSTRINGA
	FCALL	GLCDCHARCOL4
	MOVWF	CURRCHARVAL
;Case 3: ReadTable GLCDCharCol5, CharCode, CurrCharVal
	GOTO	SYSSELECTEND1
GLOBAL	SYSSELECT1CASE3
SYSSELECT1CASE3:
	MOVLW	3
	SUBWF	CURRCHARCOL,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT1CASE4
;Case 3: ReadTable GLCDCharCol5, CharCode, CurrCharVal
	MOVF	CHARCODE,W
	MOVWF	SYSSTRINGA
	FCALL	GLCDCHARCOL5
	MOVWF	CURRCHARVAL
;Case 4: ReadTable GLCDCharCol6, CharCode, CurrCharVal
	GOTO	SYSSELECTEND1
GLOBAL	SYSSELECT1CASE4
SYSSELECT1CASE4:
	MOVLW	4
	SUBWF	CURRCHARCOL,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT1CASE5
;Case 4: ReadTable GLCDCharCol6, CharCode, CurrCharVal
	MOVF	CHARCODE,W
	MOVWF	SYSSTRINGA
	FCALL	GLCDCHARCOL6
	MOVWF	CURRCHARVAL
;Case 5: ReadTable GLCDCharCol7, CharCode, CurrCharVal
	GOTO	SYSSELECTEND1
GLOBAL	SYSSELECT1CASE5
SYSSELECT1CASE5:
	MOVLW	5
	SUBWF	CURRCHARCOL,W
	BTFSS	STATUS,2
	GOTO	SYSSELECTEND1
;Case 5: ReadTable GLCDCharCol7, CharCode, CurrCharVal
	MOVF	CHARCODE,W
	MOVWF	SYSSTRINGA
	FCALL	GLCDCHARCOL7
	MOVWF	CURRCHARVAL
;End Select
GLOBAL	SYSSELECTEND1
SYSSELECTEND1:
;Full Memory GLCD mode
;CharRow=0
	CLRF	CHARROW
	CLRF	CHARROW_H
;For CurrCharRow = 1 to 8
;LEGACY METHOD
	CLRF	CURRCHARROW
GLOBAL	SYSFORLOOP11
SYSFORLOOP11:
	INCF	CURRCHARROW,F
;CharColS=0
	CLRF	CHARCOLS
;For Col=1 to GLCDfntDefaultsize
	MOVLW	1
	MOVWF	COL
GLOBAL	SYSFORLOOP12
SYSFORLOOP12:
;CharRowS=0
	CLRF	CHARROWS
;For Row=1 to GLCDfntDefaultsize
	MOVLW	1
	BANKSEL	ROW
	MOVWF	ROW
GLOBAL	SYSFORLOOP13
SYSFORLOOP13:
;if CurrCharVal.0=1 then
	BANKSEL	CURRCHARVAL
	BTFSS	CURRCHARVAL,0
	GOTO	ELSE27_1
;PSet [word]CharLocX + CharCol + CharColS, [word]CharLocY + CharRow + CharRowS, LineColour
	MOVF	CHARCOL,W
	ADDWF	CHARLOCX,W
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	BANKSEL	CHARCOLS
	MOVF	CHARCOLS,W
	BANKSEL	SYSTEMP3
	ADDWF	SYSTEMP3,W
	BANKSEL	GLCDX
	MOVWF	GLCDX
	MOVF	CHARROW,W
	ADDWF	CHARLOCY,W
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	BANKSEL	CHARROWS
	MOVF	CHARROWS,W
	BANKSEL	SYSTEMP3
	ADDWF	SYSTEMP3,W
	BANKSEL	GLCDY
	MOVWF	GLCDY
	MOVF	LINECOLOUR,W
	MOVWF	GLCDCOLOUR
	MOVF	LINECOLOUR_H,W
	MOVWF	GLCDCOLOUR_H
	FCALL	PSET_SSD1306
;Else
	GOTO	ENDIF27
GLOBAL	ELSE27_1
ELSE27_1:
;PSet [word]CharLocX + CharCol + CharColS, [word]CharLocY + CharRow + CharRowS, GLCDBackground
	MOVF	CHARCOL,W
	ADDWF	CHARLOCX,W
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	BANKSEL	CHARCOLS
	MOVF	CHARCOLS,W
	BANKSEL	SYSTEMP3
	ADDWF	SYSTEMP3,W
	BANKSEL	GLCDX
	MOVWF	GLCDX
	MOVF	CHARROW,W
	ADDWF	CHARLOCY,W
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	BANKSEL	CHARROWS
	MOVF	CHARROWS,W
	BANKSEL	SYSTEMP3
	ADDWF	SYSTEMP3,W
	BANKSEL	GLCDY
	MOVWF	GLCDY
	MOVF	GLCDBACKGROUND,W
	MOVWF	GLCDCOLOUR
	MOVF	GLCDBACKGROUND_H,W
	MOVWF	GLCDCOLOUR_H
	FCALL	PSET_SSD1306
;End if
GLOBAL	ENDIF27
ENDIF27:
;Put out a white intercharacter pixel/space
;PSet [word]CharLocX + ( GLCDFontWidth * GLCDfntDefaultsize) , [word]CharLocY + CharRow + CharRowS , GLCDBackground
	MOVF	GLCDFONTWIDTH,W
	MOVWF	SYSBYTETEMPA
	MOVF	GLCDFNTDEFAULTSIZE,W
	MOVWF	SYSBYTETEMPB
	FCALL	SYSMULTSUB
	MOVF	SYSBYTETEMPX,W
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	BANKSEL	CHARLOCX
	ADDWF	CHARLOCX,W
	MOVWF	GLCDX
	MOVF	CHARROW,W
	ADDWF	CHARLOCY,W
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	BANKSEL	CHARROWS
	MOVF	CHARROWS,W
	BANKSEL	SYSTEMP3
	ADDWF	SYSTEMP3,W
	BANKSEL	GLCDY
	MOVWF	GLCDY
	MOVF	GLCDBACKGROUND,W
	MOVWF	GLCDCOLOUR
	MOVF	GLCDBACKGROUND_H,W
	MOVWF	GLCDCOLOUR_H
	FCALL	PSET_SSD1306
;CharRowS +=1
	INCF	CHARROWS,F
;Next Row
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	BANKSEL	ROW
	MOVF	ROW,W
	BANKSEL	GLCDFNTDEFAULTSIZE
	SUBWF	GLCDFNTDEFAULTSIZE,W
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	MOVWF	SYSBYTETEMPA
	CLRF	SYSBYTETEMPB
	BANKSEL	STATUS
	FCALL	SYSCOMPEQUAL
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF28
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	BANKSEL	ROW
	INCF	ROW,F
	GOTO	SYSFORLOOP13
;END IF
GLOBAL	ENDIF28
ENDIF28:
GLOBAL	SYSFORLOOPEND13
SYSFORLOOPEND13:
;CharColS +=1
	INCF	CHARCOLS,F
;Next Col
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	COL,W
	SUBWF	GLCDFNTDEFAULTSIZE,W
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	MOVWF	SYSBYTETEMPA
	CLRF	SYSBYTETEMPB
	BANKSEL	STATUS
	FCALL	SYSCOMPEQUAL
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF29
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	INCF	COL,F
	GOTO	SYSFORLOOP12
;END IF
GLOBAL	ENDIF29
ENDIF29:
GLOBAL	SYSFORLOOPEND12
SYSFORLOOPEND12:
;Rotate CurrCharVal Right
	RRF	CURRCHARVAL,F
;CharRow +=GLCDfntDefaultsize
	MOVF	GLCDFNTDEFAULTSIZE,W
	ADDWF	CHARROW,F
	MOVLW	0
	ADDWFC	CHARROW_H,F
;Next
	MOVLW	8
	SUBWF	CURRCHARROW,W
	BTFSS	STATUS,0
	GOTO	SYSFORLOOP11
GLOBAL	SYSFORLOOPEND11
SYSFORLOOPEND11:
;CharCol +=GLCDfntDefaultsize
	MOVF	GLCDFNTDEFAULTSIZE,W
	ADDWF	CHARCOL,F
	MOVLW	0
	ADDWFC	CHARCOL_H,F
;1.14 Low Memory GLCD mode
;1.12 Character GLCD mode
;Handles specific draw sequence. This caters for write only of a bit value. No read operation.
;Next
	MOVLW	5
	SUBWF	CURRCHARCOL,W
	BTFSS	STATUS,0
	GOTO	SYSFORLOOP10
GLOBAL	SYSFORLOOPEND10
SYSFORLOOPEND10:
;****** OLED Font set handler
;1.14 Added transaction
;Restore
;GLCDBackground = 0
	CLRF	GLCDBACKGROUND
	CLRF	GLCDBACKGROUND_H
;GLCDForeground = 1
	MOVLW	1
	MOVWF	GLCDFOREGROUND
	CLRF	GLCDFOREGROUND_H
	RETURN

;********************************************************************************

;SOURCE: HWI2C.H (709)
GLOBAL	HI2CINIT
HI2CINIT:
;asm showdebug  This method sets the variable `HI2CCurrentMode`, and, if required calls the method `SI2CInit` to set up new MSSP modules - aka K42s family chips
;HI2CCurrentMode = 0
	CLRF	HI2CCURRENTMODE
;Initialise the I2C module
	RETURN

;********************************************************************************

;SOURCE: GLCD_SSD1306.H (317)
GLOBAL	INITGLCD_SSD1306
INITGLCD_SSD1306:
;Colours //Set these first
;GLCDBackground = 0
	CLRF	GLCDBACKGROUND
	CLRF	GLCDBACKGROUND_H
;GLCDForeground = 1
	MOVLW	1
	MOVWF	GLCDFOREGROUND
	CLRF	GLCDFOREGROUND_H
;GLCDFontWidth = 5
	MOVLW	5
	MOVWF	GLCDFONTWIDTH
;GLCDfntDefaultHeight = 7  'used by GLCDPrintString and GLCDPrintStringLn
	MOVLW	7
	MOVWF	GLCDFNTDEFAULTHEIGHT
;dim PrintLocX, PrintLocY as word
;GLCDfntDefault = 0
	CLRF	GLCDFNTDEFAULT
;GLCDfntDefaultsize = 1
	MOVLW	1
	MOVWF	GLCDFNTDEFAULTSIZE
;wait 255 ms             'added to ensure the charge pump and power is operational.
	MOVLW	255
	MOVWF	SYSWAITTEMPMS
	CLRF	SYSWAITTEMPMS_H
	FCALL	DELAY_MS
;HI2CMode Master
	MOVLW	12
	MOVWF	HI2CCURRENTMODE
	FCALL	HI2CMODE
;Wait 15 ms  'wait for power-up and reset
	MOVLW	15
	MOVWF	SYSWAITTEMPMS
	CLRF	SYSWAITTEMPMS_H
	FCALL	DELAY_MS
;Setup code for SSD1306 controllers
;Init sequence for 128x64 OLED module
;Write_Command_SSD1306(SSD1306_DISPLAYOFF)                    ' 0xAE
	MOVLW	174
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(SSD1306_DEACTIVATE_SCROLL)
	MOVLW	46
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(SSD1306_SETDISPLAYCLOCKDIV)            ' 0xD5
	MOVLW	213
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(0x80)                                  ' the suggested ratio 0x80
	MOVLW	128
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(SSD1306_SETMULTIPLEX)                  ' 0xA8
	MOVLW	168
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(0x3f)                                 '64 pixels
	MOVLW	63
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(SSD1306_SETDISPLAYOFFSET)              ' 0xD3
	MOVLW	211
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(0x00)                                   ' no offset
	BANKSEL	SSD1306SENDBYTE
	CLRF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(SSD1306_SETSTARTLINE | 0x00)            ' line #0
	MOVLW	64
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(SSD1306_CHARGEPUMP)                    ' 0x8D
	MOVLW	141
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;if (SSD1306_vccstate = SSD1306_EXTERNALVCC) then
;Write_Command_SSD1306(0x14)
	MOVLW	20
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;end if
;Write_Command_SSD1306(SSD1306_MEMORYMODE)                    ' 0x20
	MOVLW	32
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(0x00)                                  ' 0x00 act like ks0108 - DO NOT SELECT!!
;Write_Command_SSD1306(0x10)                                  ' 0x01 act like PCD8544
	MOVLW	16
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(SSD1306_SEGREMAP | 0x1)
	MOVLW	161
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(SSD1306_COMSCANDEC)
	MOVLW	200
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(SSD1306_SETCOMPINS)                    ' 0xDA
	MOVLW	218
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(0x12)                                 '64 pixels
	MOVLW	18
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(SSD1306_SETCONTRAST)                   ' 0x81
	MOVLW	129
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;if SSD1306_vccstate = SSD1306_EXTERNALVCC then
;Write_Command_SSD1306(0xCF)
	MOVLW	207
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;end if
;Write_Command_SSD1306(SSD1306_SETPRECHARGE)                  ' 0xd9
	MOVLW	217
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;if SSD1306_vccstate = SSD1306_EXTERNALVCC then
;Write_Command_SSD1306(0xF1)
	MOVLW	241
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;end if
;Write_Command_SSD1306(SSD1306_SETVCOMDETECT)                 ' 0xDB
	MOVLW	219
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(0x40)
	MOVLW	64
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(SSD1306_DISPLAYALLON_RESUME)           ' 0xA4
	MOVLW	164
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Write_Command_SSD1306(SSD1306_NORMALDISPLAY)                 ' 0xA6
	MOVLW	166
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;Clear screen Here
;GLCDCLS_SSD1306
	FCALL	GLCDCLS_SSD1306
;Write_Command_SSD1306(SSD1306_DISPLAYON)                     '--turn on oled panel
	MOVLW	175
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	LJMP	WRITE_COMMAND_SSD1306

;********************************************************************************

;SOURCE: 230_I2C_GLCD_VOLTMETER_USING_SSD1306.GCB (30)
GLOBAL	INITPPS
INITPPS:
;SSP1CLKPPS = 0x1;   'RA1->MSSP1:SCL1;
	MOVLW	1
	BANKSEL	SSP1CLKPPS
	MOVWF	SSP1CLKPPS
;RA1PPS = 0x1B;      'RA1->MSSP1:SCL1;
	MOVLW	27
	BANKSEL	RA1PPS
	MOVWF	RA1PPS
;SSP1DATPPS = 0x4;   'RA4->MSSP1:SDA1;
	MOVLW	4
	BANKSEL	SSP1DATPPS
	MOVWF	SSP1DATPPS
;RA4PPS = 0x1C;      'RA4->MSSP1:SDA1;
	MOVLW	28
	BANKSEL	RA4PPS
	MOVWF	RA4PPS
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (159)
GLOBAL	INITSYS
INITSYS:
;asm showdebug This code block sets the internal oscillator to ChipMHz
;asm showdebug Default settings for microcontrollers with _OSCCON1_
;Default OSCCON1 typically, NOSC HFINTOSC; NDIV 1 - Common as this simply sets the HFINTOSC
;OSCCON1 = 0x60
	MOVLW	96
	BANKSEL	OSCCON1
	MOVWF	OSCCON1
;Default value typically, CSWHOLD may proceed; SOSCPWR Low power
;OSCCON3 = 0x00
	CLRF	OSCCON3
;Default value typically, MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled
;OSCEN = 0x00
	CLRF	OSCEN
;Default value
;OSCTUNE = 0x00
	CLRF	OSCTUNE
;asm showdebug The MCU is a chip family ChipFamily
;asm showdebug OSCCON type is 102
;Set OSCFRQ values for MCUs with OSCSTAT... the 16F171xx MCU family
;OSCFRQ = 0b00000101
	MOVLW	5
	MOVWF	OSCFRQ
;asm showdebug _Complete_the_chip_setup_of_BSR,ADCs,ANSEL_and_other_key_setup_registers_or_register_bits
;Ensure all ports are set for digital I/O and, turn off A/D
;SET ADFM OFF
	BANKSEL	ADCON0
	BCF	ADCON0,2
;Switch off A/D Var(ADCON0)
;SET ADCON0.ADON OFF
	BCF	ADCON0,7
;ANSELA = 0
	BANKSEL	ANSELA
	CLRF	ANSELA
;ANSELC = 0
	CLRF	ANSELC
;Set comparator register bits for many MCUs with register CM2CON0
;C2EN = 0
	BANKSEL	CM2CON0
	BCF	CM2CON0,7
;C1EN = 0
	BCF	CM1CON0,7
;
;'Turn off all ports
;PORTA = 0
	BANKSEL	PORTA
	CLRF	PORTA
;PORTC = 0
	CLRF	PORTC
	RETURN

;********************************************************************************

;SOURCE: STRING.H (355)
GLOBAL	FN_LEFT
FN_LEFT:
;Empty input?
;If SysInString(0) = 0 Then
	BANKSEL	SYSSYSINSTRINGHANDLER
	MOVF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,F
	BTFSS	STATUS,2
	GOTO	ENDIF64
;Left(0) = 0
	BANKSEL	SYSLEFT_0
	CLRF	SYSLEFT_0
;Exit Function
	BANKSEL	STATUS
	RETURN
;End If
GLOBAL	ENDIF64
ENDIF64:
;Input length too high?
;If SysInString(0) < SysCharCount Then
	MOVF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	SYSCHARCOUNT,W
	SUBWF	INDF0,W
	BTFSC	STATUS,0
	GOTO	ENDIF65
;SysCharCount = SysInString(0)
	MOVF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	MOVWF	SYSCHARCOUNT
;End If
GLOBAL	ENDIF65
ENDIF65:
;Copy leftmost characters
;For SysStringTemp = 1 To SysCharCount
	MOVLW	1
	MOVWF	SYSSTRINGTEMP
GLOBAL	SYSFORLOOP14
SYSFORLOOP14:
;Left(SysStringTemp) = SysInString(SysStringTemp)
	MOVF	SYSSTRINGTEMP,W
	ADDWF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVLW	0
	ADDWFC	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	MOVWF	SYSARRAYTEMP2
	MOVWF	SYSARRAYTEMP1
	MOVLW	LOW(LEFT)
	ADDWF	SYSSTRINGTEMP,W
	MOVWF	FSR0L
	CLRF	SYSTEMP3
	MOVLW	HIGH(LEFT)
	ADDWFC	SYSTEMP3,W
	MOVWF	FSR0H
	MOVF	SYSARRAYTEMP1,W
	MOVWF	INDF0
;Next
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	SYSSTRINGTEMP,W
	SUBWF	SYSCHARCOUNT,W
	MOVWF	SYSTEMP3
	MOVWF	SYSBYTETEMPA
	CLRF	SYSBYTETEMPB
	BANKSEL	STATUS
	FCALL	SYSCOMPEQUAL
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF66
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	BANKSEL	SYSSTRINGTEMP
	INCF	SYSSTRINGTEMP,F
	GOTO	SYSFORLOOP14
;END IF
GLOBAL	ENDIF66
ENDIF66:
GLOBAL	SYSFORLOOPEND14
SYSFORLOOPEND14:
;Left(0) = SysCharCount
	BANKSEL	SYSCHARCOUNT
	MOVF	SYSCHARCOUNT,W
	BANKSEL	SYSLEFT_0
	MOVWF	SYSLEFT_0
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;OVERLOADED SIGNATURE: BYTE:, SOURCE: A-D.H (2091)
GLOBAL	FN_READAD463
FN_READAD463:
;ADFM should configured to ensure LEFT justified
;SET ADFM OFF
	BANKSEL	ADCON0
	BCF	ADCON0,2
;for 16F1885x and possibly future others
;ADPCH = ADReadPort
	BANKSEL	ADREADPORT
	MOVF	ADREADPORT,W
	BANKSEL	ADPCH
	MOVWF	ADPCH
;SetNegativeChannelSelectbits
;Macro Source: a-d.h (2867)
;ADCON0.ADIC = 0
	BCF	ADCON0,1
;ADNCH = 0x00
	CLRF	ADNCH
;***************************************
;Perform conversion
;LLReadAD 1
;Macro Source: a-d.h (567)
;Configure ANSELA/B/C/D @DebugADC_H
;Select Case ADReadPort
;Case 0: Set ANSELA.0 On
GLOBAL	SYSSELECT2CASE1
SYSSELECT2CASE1:
	BANKSEL	ADREADPORT
	MOVF	ADREADPORT,F
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE2
;Case 0: Set ANSELA.0 On
	BANKSEL	ANSELA
	BSF	ANSELA,0
;Case 1: Set ANSELA.1 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE2
SYSSELECT2CASE2:
	DECF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE3
;Case 1: Set ANSELA.1 On
	BANKSEL	ANSELA
	BSF	ANSELA,1
;Case 2: Set ANSELA.2 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE3
SYSSELECT2CASE3:
	MOVLW	2
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE4
;Case 2: Set ANSELA.2 On
	BANKSEL	ANSELA
	BSF	ANSELA,2
;Case 3: Set ANSELA.3 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE4
SYSSELECT2CASE4:
	MOVLW	3
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE5
;Case 3: Set ANSELA.3 On
	BANKSEL	ANSELA
	BSF	ANSELA,3
;Case 4: Set ANSELA.4 ON
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE5
SYSSELECT2CASE5:
	MOVLW	4
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE6
;Case 4: Set ANSELA.4 ON
	BANKSEL	ANSELA
	BSF	ANSELA,4
;Case 5: Set ANSELA.5 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE6
SYSSELECT2CASE6:
	MOVLW	5
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE7
;Case 5: Set ANSELA.5 On
	BANKSEL	ANSELA
	BSF	ANSELA,5
;Case 6: Set ANSELA.6 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE7
SYSSELECT2CASE7:
	MOVLW	6
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE8
;Case 6: Set ANSELA.6 On
	BANKSEL	ANSELA
	BSF	ANSELA,6
;Case 7: Set ANSELA.7 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE8
SYSSELECT2CASE8:
	MOVLW	7
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE9
;Case 7: Set ANSELA.7 On
	BANKSEL	ANSELA
	BSF	ANSELA,7
;Case 8: Set ANSELB.0 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE9
SYSSELECT2CASE9:
	MOVLW	8
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE10
;Case 8: Set ANSELB.0 On
	BSF	ANSELB,0
;Case 9: Set ANSELB.1 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE10
SYSSELECT2CASE10:
	MOVLW	9
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE11
;Case 9: Set ANSELB.1 On
	BSF	ANSELB,1
;Case 10: Set ANSELB.2 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE11
SYSSELECT2CASE11:
	MOVLW	10
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE12
;Case 10: Set ANSELB.2 On
	BSF	ANSELB,2
;Case 11: Set ANSELB.3 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE12
SYSSELECT2CASE12:
	MOVLW	11
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE13
;Case 11: Set ANSELB.3 On
	BSF	ANSELB,3
;Case 12: Set ANSELB.4 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE13
SYSSELECT2CASE13:
	MOVLW	12
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE14
;Case 12: Set ANSELB.4 On
	BSF	ANSELB,4
;Case 13: Set ANSELB.5 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE14
SYSSELECT2CASE14:
	MOVLW	13
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE15
;Case 13: Set ANSELB.5 On
	BSF	ANSELB,5
;Case 14: Set ANSELB.6 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE15
SYSSELECT2CASE15:
	MOVLW	14
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE16
;Case 14: Set ANSELB.6 On
	BSF	ANSELB,6
;Case 15: Set ANSELB.7 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE16
SYSSELECT2CASE16:
	MOVLW	15
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE17
;Case 15: Set ANSELB.7 On
	BSF	ANSELB,7
;Case 16: Set ANSELC.0 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE17
SYSSELECT2CASE17:
	MOVLW	16
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE18
;Case 16: Set ANSELC.0 On
	BANKSEL	ANSELC
	BSF	ANSELC,0
;Case 17: Set ANSELC.1 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE18
SYSSELECT2CASE18:
	MOVLW	17
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE19
;Case 17: Set ANSELC.1 On
	BANKSEL	ANSELC
	BSF	ANSELC,1
;Case 18: Set ANSELC.2 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE19
SYSSELECT2CASE19:
	MOVLW	18
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE20
;Case 18: Set ANSELC.2 On
	BANKSEL	ANSELC
	BSF	ANSELC,2
;Case 19: Set ANSELC.3 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE20
SYSSELECT2CASE20:
	MOVLW	19
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE21
;Case 19: Set ANSELC.3 On
	BANKSEL	ANSELC
	BSF	ANSELC,3
;Case 20: Set ANSELC.4 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE21
SYSSELECT2CASE21:
	MOVLW	20
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE22
;Case 20: Set ANSELC.4 On
	BANKSEL	ANSELC
	BSF	ANSELC,4
;Case 21: Set ANSELC.5 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE22
SYSSELECT2CASE22:
	MOVLW	21
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE23
;Case 21: Set ANSELC.5 On
	BANKSEL	ANSELC
	BSF	ANSELC,5
;Case 22: Set ANSELC.6 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE23
SYSSELECT2CASE23:
	MOVLW	22
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECT2CASE24
;Case 22: Set ANSELC.6 On
	BANKSEL	ANSELC
	BSF	ANSELC,6
;Case 23: Set ANSELC.7 On
	GOTO	SYSSELECTEND2
GLOBAL	SYSSELECT2CASE24
SYSSELECT2CASE24:
	MOVLW	23
	SUBWF	ADREADPORT,W
	BTFSS	STATUS,2
	GOTO	SYSSELECTEND2
;Case 23: Set ANSELC.7 On
	BANKSEL	ANSELC
	BSF	ANSELC,7
;End Select  '*** ANSEL Bits should now be set ***
GLOBAL	SYSSELECTEND2
SYSSELECTEND2:
;*** ANSEL Bits are now set ***
;Set voltage reference
;ADREF = 0  'Default = 0 /Vref+ = Vdd/ Vref-  = Vss
;Configure AD clock defaults
;Set ADCS off 'Clock source = FOSC/ADCLK
	BANKSEL	ADCON0
	BCF	ADCON0,4
;ADCLK = 1 ' default to FOSC/2
	MOVLW	1
	MOVWF	ADCLK
;Conversion Clock Speed
;SET ADCS OFF  ' ADCON0.4
	BCF	ADCON0,4
;ADCLK = 31    ' FOSC/32
	MOVLW	31
	MOVWF	ADCLK
;Result formatting
;if ADLeftadjust = 0 then
;Set ADCON.2 off     '8-bit
;Set ADFM OFF
	BCF	ADCON0,2
;Set ADFM0 OFF
	BCF	ADCON0,2
;End if
;Select Channel
;ADPCH = ADReadPort  'Configure AD read Channel
	BANKSEL	ADREADPORT
	MOVF	ADREADPORT,W
	BANKSEL	ADPCH
	MOVWF	ADPCH
;Enable AD Operations
;SET ADON ON
	BSF	ADCON0,7
;Acquisition Delay
;Wait AD_Delay
	MOVLW	2
	MOVWF	SYSWAITTEMP10US
	BANKSEL	STATUS
	FCALL	DELAY_10US
;Read A/D @1
;SET GO_NOT_DONE ON
	BANKSEL	ADCON0
	BSF	ADCON0,0
;nop
	NOP
;Wait While GO_NOT_DONE ON
GLOBAL	SYSWAITLOOP1
SYSWAITLOOP1:
	BTFSC	ADCON0,0
	GOTO	SYSWAITLOOP1
;Switch off A/D
;SET ADCON0.ADON OFF
	BCF	ADCON0,7
;ANSELA = 0
	BANKSEL	ANSELA
	CLRF	ANSELA
;ANSELC = 0
	CLRF	ANSELC
;ReadAD = ADRESH
	BANKSEL	ADRESH
	MOVF	ADRESH,W
	BANKSEL	READAD
	MOVWF	READAD
;SET ADFM OFF
	BANKSEL	ADCON0
	BCF	ADCON0,2
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: STRING.H (76)
GLOBAL	FN_STR
FN_STR:
;SysCharCount = 0
	BANKSEL	SYSCHARCOUNT
	CLRF	SYSCHARCOUNT
;Dim SysCalcTempX As Word
;Ten Thousands
;IF SysValTemp >= 10000 then
	BANKSEL	SYSVALTEMP
	MOVF	SYSVALTEMP,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSVALTEMP_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	16
	MOVWF	SYSWORDTEMPB
	MOVLW	39
	MOVWF	SYSWORDTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHAN16
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF60
;SysStrData = SysValTemp / 10000
	BANKSEL	SYSVALTEMP
	MOVF	SYSVALTEMP,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSVALTEMP_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	16
	MOVWF	SYSWORDTEMPB
	MOVLW	39
	MOVWF	SYSWORDTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSDIVSUB16
	MOVF	SYSWORDTEMPA,W
	BANKSEL	SYSSTRDATA
	MOVWF	SYSSTRDATA
;SysValTemp = SysCalcTempX
	MOVF	SYSCALCTEMPX,W
	BANKSEL	SYSVALTEMP
	MOVWF	SYSVALTEMP
	MOVF	SYSCALCTEMPX_H,W
	MOVWF	SYSVALTEMP_H
;SysCharCount += 1
	BANKSEL	SYSCHARCOUNT
	INCF	SYSCHARCOUNT,F
;Str(SysCharCount) = SysStrData + 48
	MOVLW	LOW(STR)
	ADDWF	SYSCHARCOUNT,W
	MOVWF	FSR0L
	CLRF	SYSTEMP3
	MOVLW	HIGH(STR)
	ADDWFC	SYSTEMP3,W
	MOVWF	FSR0H
	MOVLW	48
	ADDWF	SYSSTRDATA,W
	MOVWF	INDF0
;Goto SysValThousands
	GOTO	SYSVALTHOUSANDS
;End If
GLOBAL	ENDIF60
ENDIF60:
;Thousands
;IF SysValTemp >= 1000 then
	BANKSEL	SYSVALTEMP
	MOVF	SYSVALTEMP,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSVALTEMP_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	232
	MOVWF	SYSWORDTEMPB
	MOVLW	3
	MOVWF	SYSWORDTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHAN16
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF61
GLOBAL	SYSVALTHOUSANDS
SYSVALTHOUSANDS:
;SysStrData = SysValTemp / 1000
	BANKSEL	SYSVALTEMP
	MOVF	SYSVALTEMP,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSVALTEMP_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	232
	MOVWF	SYSWORDTEMPB
	MOVLW	3
	MOVWF	SYSWORDTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSDIVSUB16
	MOVF	SYSWORDTEMPA,W
	BANKSEL	SYSSTRDATA
	MOVWF	SYSSTRDATA
;SysValTemp = SysCalcTempX
	MOVF	SYSCALCTEMPX,W
	BANKSEL	SYSVALTEMP
	MOVWF	SYSVALTEMP
	MOVF	SYSCALCTEMPX_H,W
	MOVWF	SYSVALTEMP_H
;SysCharCount += 1
	BANKSEL	SYSCHARCOUNT
	INCF	SYSCHARCOUNT,F
;Str(SysCharCount) = SysStrData + 48
	MOVLW	LOW(STR)
	ADDWF	SYSCHARCOUNT,W
	MOVWF	FSR0L
	CLRF	SYSTEMP3
	MOVLW	HIGH(STR)
	ADDWFC	SYSTEMP3,W
	MOVWF	FSR0H
	MOVLW	48
	ADDWF	SYSSTRDATA,W
	MOVWF	INDF0
;Goto SysValHundreds
	GOTO	SYSVALHUNDREDS
;End If
GLOBAL	ENDIF61
ENDIF61:
;Hundreds
;IF SysValTemp >= 100 then
	BANKSEL	SYSVALTEMP
	MOVF	SYSVALTEMP,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSVALTEMP_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	100
	MOVWF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHAN16
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF62
GLOBAL	SYSVALHUNDREDS
SYSVALHUNDREDS:
;SysStrData = SysValTemp / 100
	BANKSEL	SYSVALTEMP
	MOVF	SYSVALTEMP,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSVALTEMP_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	100
	MOVWF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSDIVSUB16
	MOVF	SYSWORDTEMPA,W
	BANKSEL	SYSSTRDATA
	MOVWF	SYSSTRDATA
;SysValTemp = SysCalcTempX
	MOVF	SYSCALCTEMPX,W
	BANKSEL	SYSVALTEMP
	MOVWF	SYSVALTEMP
	MOVF	SYSCALCTEMPX_H,W
	MOVWF	SYSVALTEMP_H
;SysCharCount += 1
	BANKSEL	SYSCHARCOUNT
	INCF	SYSCHARCOUNT,F
;Str(SysCharCount) = SysStrData + 48
	MOVLW	LOW(STR)
	ADDWF	SYSCHARCOUNT,W
	MOVWF	FSR0L
	CLRF	SYSTEMP3
	MOVLW	HIGH(STR)
	ADDWFC	SYSTEMP3,W
	MOVWF	FSR0H
	MOVLW	48
	ADDWF	SYSSTRDATA,W
	MOVWF	INDF0
;Goto SysValTens
	GOTO	SYSVALTENS
;End If
GLOBAL	ENDIF62
ENDIF62:
;Tens
;IF SysValTemp >= 10 Then
	BANKSEL	SYSVALTEMP
	MOVF	SYSVALTEMP,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSVALTEMP_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	10
	MOVWF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHAN16
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF63
GLOBAL	SYSVALTENS
SYSVALTENS:
;SysStrData = SysValTemp / 10
	BANKSEL	SYSVALTEMP
	MOVF	SYSVALTEMP,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSVALTEMP_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	10
	MOVWF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSDIVSUB16
	MOVF	SYSWORDTEMPA,W
	BANKSEL	SYSSTRDATA
	MOVWF	SYSSTRDATA
;SysValTemp = SysCalcTempX
	MOVF	SYSCALCTEMPX,W
	BANKSEL	SYSVALTEMP
	MOVWF	SYSVALTEMP
	MOVF	SYSCALCTEMPX_H,W
	MOVWF	SYSVALTEMP_H
;SysCharCount += 1
	BANKSEL	SYSCHARCOUNT
	INCF	SYSCHARCOUNT,F
;Str(SysCharCount) = SysStrData + 48
	MOVLW	LOW(STR)
	ADDWF	SYSCHARCOUNT,W
	MOVWF	FSR0L
	CLRF	SYSTEMP3
	MOVLW	HIGH(STR)
	ADDWFC	SYSTEMP3,W
	MOVWF	FSR0H
	MOVLW	48
	ADDWF	SYSSTRDATA,W
	MOVWF	INDF0
;End If
GLOBAL	ENDIF63
ENDIF63:
;Ones
;SysCharCount += 1
	BANKSEL	SYSCHARCOUNT
	INCF	SYSCHARCOUNT,F
;Str(SysCharCount) = SysValTemp + 48
	MOVLW	LOW(STR)
	ADDWF	SYSCHARCOUNT,W
	MOVWF	FSR0L
	CLRF	SYSTEMP3
	MOVLW	HIGH(STR)
	ADDWFC	SYSTEMP3,W
	MOVWF	FSR0H
	MOVLW	48
	BANKSEL	SYSVALTEMP
	ADDWF	SYSVALTEMP,W
	MOVWF	INDF0
;SysValTemp = SysCalcTempX
	MOVF	SYSCALCTEMPX,W
	MOVWF	SYSVALTEMP
	MOVF	SYSCALCTEMPX_H,W
	MOVWF	SYSVALTEMP_H
;Str(0) = SysCharCount
	BANKSEL	SYSCHARCOUNT
	MOVF	SYSCHARCOUNT,W
	BANKSEL	SYSSTR_0
	MOVWF	SYSSTR_0
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: PICAS.H (26)
GLOBAL	_LINE
_LINE:
;dim LineStepX as integer
;dim LineStepY as integer
;dim LineDiffX, LineDiffY as integer
;dim LineDiffX_x2, LineDiffY_x2 as integer
;dim LineErr as integer
;LineDiffX = 0
	CLRF	LINEDIFFX
	CLRF	LINEDIFFX_H
;LineDiffY = 0
	CLRF	LINEDIFFY
	CLRF	LINEDIFFY_H
;LineStepX = 0
	CLRF	LINESTEPX
	CLRF	LINESTEPX_H
;LineStepY = 0
	CLRF	LINESTEPY
	CLRF	LINESTEPY_H
;LineDiffX_x2 = 0
	CLRF	LINEDIFFX_X2
	CLRF	LINEDIFFX_X2_H
;LineDiffY_x2 = 0
	CLRF	LINEDIFFY_X2
	CLRF	LINEDIFFY_X2_H
;LineErr = 0
	CLRF	LINEERR
	CLRF	LINEERR_H
;LineDiffX =  LineX2 -   LineX1
	MOVF	LINEX1,W
	SUBWF	LINEX2,W
	MOVWF	LINEDIFFX
	MOVF	LINEX1_H,W
	SUBWFB	LINEX2_H,W
	MOVWF	LINEDIFFX_H
;LineDiffY =  LineY2 -   LineY1
	MOVF	LINEY1,W
	SUBWF	LINEY2,W
	MOVWF	LINEDIFFY
	MOVF	LINEY1_H,W
	SUBWFB	LINEY2_H,W
	MOVWF	LINEDIFFY_H
;if (LineDiffX > 0) then
	MOVF	LINEDIFFX,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	LINEDIFFX_H,W
	MOVWF	SYSINTEGERTEMPB_H
	CLRF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	FCALL	SYSCOMPLESSTHANINT
	BTFSS	SYSBYTETEMPX,0
	GOTO	ELSE37_1
;LineStepX = 1
	MOVLW	1
	MOVWF	LINESTEPX
	CLRF	LINESTEPX_H
;else
	GOTO	ENDIF37
GLOBAL	ELSE37_1
ELSE37_1:
;LineStepX = -1
	MOVLW	255
	MOVWF	LINESTEPX
	MOVWF	LINESTEPX_H
;end if
GLOBAL	ENDIF37
ENDIF37:
;if (LineDiffY > 0) then
	MOVF	LINEDIFFY,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	LINEDIFFY_H,W
	MOVWF	SYSINTEGERTEMPB_H
	CLRF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	FCALL	SYSCOMPLESSTHANINT
	BTFSS	SYSBYTETEMPX,0
	GOTO	ELSE38_1
;LineStepY = 1
	MOVLW	1
	MOVWF	LINESTEPY
	CLRF	LINESTEPY_H
;else
	GOTO	ENDIF38
GLOBAL	ELSE38_1
ELSE38_1:
;LineStepY = -1
	MOVLW	255
	MOVWF	LINESTEPY
	MOVWF	LINESTEPY_H
;end if
GLOBAL	ENDIF38
ENDIF38:
;LineDiffX = LineStepX * LineDiffX
	MOVF	LINESTEPX,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	LINESTEPX_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVF	LINEDIFFX,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	LINEDIFFX_H,W
	MOVWF	SYSINTEGERTEMPB_H
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	MOVWF	LINEDIFFX
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	LINEDIFFX_H
;LineDiffY = LineStepY * LineDiffY
	MOVF	LINESTEPY,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	LINESTEPY_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVF	LINEDIFFY,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	LINEDIFFY_H,W
	MOVWF	SYSINTEGERTEMPB_H
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	MOVWF	LINEDIFFY
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	LINEDIFFY_H
;LineDiffX_x2 = LineDiffX*2
	MOVF	LINEDIFFX,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	LINEDIFFX_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	2
	MOVWF	SYSINTEGERTEMPB
	CLRF	SYSINTEGERTEMPB_H
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	MOVWF	LINEDIFFX_X2
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	LINEDIFFX_X2_H
;LineDiffY_x2 = LineDiffY*2
	MOVF	LINEDIFFY,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	LINEDIFFY_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	2
	MOVWF	SYSINTEGERTEMPB
	CLRF	SYSINTEGERTEMPB_H
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	MOVWF	LINEDIFFY_X2
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	LINEDIFFY_X2_H
;if ( LineDiffX >= LineDiffY) then
	MOVF	LINEDIFFX,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	LINEDIFFX_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVF	LINEDIFFY,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	LINEDIFFY_H,W
	MOVWF	SYSINTEGERTEMPB_H
	FCALL	SYSCOMPLESSTHANINT
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ELSE39_1
;LineErr = LineDiffY_x2 - LineDiffX
	MOVF	LINEDIFFX,W
	SUBWF	LINEDIFFY_X2,W
	MOVWF	LINEERR
	MOVF	LINEDIFFX_H,W
	SUBWFB	LINEDIFFY_X2_H,W
	MOVWF	LINEERR_H
;do while (   LineX1 <>  LineX2 )
GLOBAL	SYSDOLOOP_S2
SYSDOLOOP_S2:
	MOVF	LINEX1,W
	MOVWF	SYSWORDTEMPA
	MOVF	LINEX1_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVF	LINEX2,W
	MOVWF	SYSWORDTEMPB
	MOVF	LINEX2_H,W
	MOVWF	SYSWORDTEMPB_H
	FCALL	SYSCOMPEQUAL16
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	SYSDOLOOP_E2
;PSet (   LineX1,   LineY1, LineColour )
	MOVF	LINEX1,W
	MOVWF	GLCDX
	MOVF	LINEY1,W
	MOVWF	GLCDY
	MOVF	LINECOLOUR,W
	MOVWF	GLCDCOLOUR
	MOVF	LINECOLOUR_H,W
	MOVWF	GLCDCOLOUR_H
	FCALL	PSET_SSD1306
;LineX1 += LineStepX
	MOVF	LINESTEPX,W
	ADDWF	LINEX1,F
	MOVF	LINESTEPX_H,W
	ADDWFC	LINEX1_H,F
;if ( LineErr < 0) then
	MOVF	LINEERR,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	LINEERR_H,W
	MOVWF	SYSINTEGERTEMPA_H
	CLRF	SYSINTEGERTEMPB
	CLRF	SYSINTEGERTEMPB_H
	FCALL	SYSCOMPLESSTHANINT
	BTFSS	SYSBYTETEMPX,0
	GOTO	ELSE40_1
;LineErr += LineDiffY_x2
	MOVF	LINEDIFFY_X2,W
	ADDWF	LINEERR,F
	MOVF	LINEDIFFY_X2_H,W
	ADDWFC	LINEERR_H,F
;else
	GOTO	ENDIF40
GLOBAL	ELSE40_1
ELSE40_1:
;LineErr += ( LineDiffY_x2 - LineDiffX_x2 )
	MOVF	LINEDIFFX_X2,W
	SUBWF	LINEDIFFY_X2,W
	BANKSEL	SYSTEMP1
	MOVWF	SYSTEMP1
	BANKSEL	LINEDIFFX_X2_H
	MOVF	LINEDIFFX_X2_H,W
	SUBWFB	LINEDIFFY_X2_H,W
	BANKSEL	SYSTEMP1_H
	MOVWF	SYSTEMP1_H
	MOVF	SYSTEMP1,W
	BANKSEL	LINEERR
	ADDWF	LINEERR,F
	BANKSEL	SYSTEMP1_H
	MOVF	SYSTEMP1_H,W
	BANKSEL	LINEERR_H
	ADDWFC	LINEERR_H,F
;LineY1 += LineStepY
	MOVF	LINESTEPY,W
	ADDWF	LINEY1,F
	MOVF	LINESTEPY_H,W
	ADDWFC	LINEY1_H,F
;end if
GLOBAL	ENDIF40
ENDIF40:
;loop
	GOTO	SYSDOLOOP_S2
GLOBAL	SYSDOLOOP_E2
SYSDOLOOP_E2:
;PSet (   LineX1,   LineY1, LineColour )
	MOVF	LINEX1,W
	MOVWF	GLCDX
	MOVF	LINEY1,W
	MOVWF	GLCDY
	MOVF	LINECOLOUR,W
	MOVWF	GLCDCOLOUR
	MOVF	LINECOLOUR_H,W
	MOVWF	GLCDCOLOUR_H
	FCALL	PSET_SSD1306
;else
	GOTO	ENDIF39
GLOBAL	ELSE39_1
ELSE39_1:
;LineErr = LineDiffX_x2 - LineDiffY
	MOVF	LINEDIFFY,W
	SUBWF	LINEDIFFX_X2,W
	MOVWF	LINEERR
	MOVF	LINEDIFFY_H,W
	SUBWFB	LINEDIFFX_X2_H,W
	MOVWF	LINEERR_H
;do while (   LineY1 <>  LineY2)
GLOBAL	SYSDOLOOP_S3
SYSDOLOOP_S3:
	MOVF	LINEY1,W
	MOVWF	SYSWORDTEMPA
	MOVF	LINEY1_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVF	LINEY2,W
	MOVWF	SYSWORDTEMPB
	MOVF	LINEY2_H,W
	MOVWF	SYSWORDTEMPB_H
	FCALL	SYSCOMPEQUAL16
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	SYSDOLOOP_E3
;PSet (   LineX1,   LineY1, LineColour )
	MOVF	LINEX1,W
	MOVWF	GLCDX
	MOVF	LINEY1,W
	MOVWF	GLCDY
	MOVF	LINECOLOUR,W
	MOVWF	GLCDCOLOUR
	MOVF	LINECOLOUR_H,W
	MOVWF	GLCDCOLOUR_H
	FCALL	PSET_SSD1306
;LineY1 += LineStepY
	MOVF	LINESTEPY,W
	ADDWF	LINEY1,F
	MOVF	LINESTEPY_H,W
	ADDWFC	LINEY1_H,F
;if ( LineErr < 0) then
	MOVF	LINEERR,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	LINEERR_H,W
	MOVWF	SYSINTEGERTEMPA_H
	CLRF	SYSINTEGERTEMPB
	CLRF	SYSINTEGERTEMPB_H
	FCALL	SYSCOMPLESSTHANINT
	BTFSS	SYSBYTETEMPX,0
	GOTO	ELSE41_1
;LineErr += LineDiffX_x2
	MOVF	LINEDIFFX_X2,W
	ADDWF	LINEERR,F
	MOVF	LINEDIFFX_X2_H,W
	ADDWFC	LINEERR_H,F
;else
	GOTO	ENDIF41
GLOBAL	ELSE41_1
ELSE41_1:
;LineErr += ( LineDiffX_x2 - LineDiffY_x2 )
	MOVF	LINEDIFFY_X2,W
	SUBWF	LINEDIFFX_X2,W
	BANKSEL	SYSTEMP1
	MOVWF	SYSTEMP1
	BANKSEL	LINEDIFFY_X2_H
	MOVF	LINEDIFFY_X2_H,W
	SUBWFB	LINEDIFFX_X2_H,W
	BANKSEL	SYSTEMP1_H
	MOVWF	SYSTEMP1_H
	MOVF	SYSTEMP1,W
	BANKSEL	LINEERR
	ADDWF	LINEERR,F
	BANKSEL	SYSTEMP1_H
	MOVF	SYSTEMP1_H,W
	BANKSEL	LINEERR_H
	ADDWFC	LINEERR_H,F
;LineX1 += LineStepX
	MOVF	LINESTEPX,W
	ADDWF	LINEX1,F
	MOVF	LINESTEPX_H,W
	ADDWFC	LINEX1_H,F
;end if
GLOBAL	ENDIF41
ENDIF41:
;loop
	GOTO	SYSDOLOOP_S3
GLOBAL	SYSDOLOOP_E3
SYSDOLOOP_E3:
;PSet (   LineX1,   LineY1, LineColour )
	MOVF	LINEX1,W
	MOVWF	GLCDX
	MOVF	LINEY1,W
	MOVWF	GLCDY
	MOVF	LINECOLOUR,W
	MOVWF	GLCDCOLOUR
	MOVF	LINECOLOUR_H,W
	MOVWF	GLCDCOLOUR_H
	FCALL	PSET_SSD1306
;end if
GLOBAL	ENDIF39
ENDIF39:
	RETURN

;********************************************************************************

;START OF PROGRAM MEMORY PAGE 1
	PSECT	PROGMEM1,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	2048
;SOURCE: STRING.H (524)
GLOBAL	FN_ASC
FN_ASC:
;Asc = 0
	CLRF	ASC
;Get length of string, don't try _asc ing if it's empty
;SysCharCount = SysInStringA(0)
	BANKSEL	SYSSYSINSTRINGAHANDLER
	MOVF	SYSSYSINSTRINGAHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRINGAHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	MOVWF	SYSCHARCOUNT
;If SysCharCount = 0 Then Exit Function
	MOVF	SYSCHARCOUNT,F
	BTFSS	STATUS,2
	GOTO	ENDIF72
;If SysCharCount = 0 Then Exit Function
	BANKSEL	STATUS
	RETURN
;If SysCharCount = 0 Then Exit Function
GLOBAL	ENDIF72
ENDIF72:
;if Syschar > SysCharCount Then Exit Function
	MOVF	SYSCHAR,W
	SUBWF	SYSCHARCOUNT,W
	BTFSC	STATUS,0
	GOTO	ENDIF73
;if Syschar > SysCharCount Then Exit Function
	BANKSEL	STATUS
	RETURN
;if Syschar > SysCharCount Then Exit Function
GLOBAL	ENDIF73
ENDIF73:
;Get first char of string, only first character is of interest, Syschar if provided
;Asc = SysInStringA( Syschar )
	MOVF	SYSCHAR,W
	ADDWF	SYSSYSINSTRINGAHANDLER,W
	MOVWF	FSR0L
	MOVLW	0
	ADDWFC	SYSSYSINSTRINGAHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	BANKSEL	ASC
	MOVWF	ASC
	RETURN

;********************************************************************************

;SOURCE: GLCD.H (1489)
GLOBAL	BOX
BOX:
;dim GLCDTemp as word
;Make sure that starting point (1) is always less than end point (2)
;If LineX1 > LineX2 Then
	MOVF	LINEX1,W
	MOVWF	SYSWORDTEMPB
	MOVF	LINEX1_H,W
	MOVWF	SYSWORDTEMPB_H
	MOVF	LINEX2,W
	MOVWF	SYSWORDTEMPA
	MOVF	LINEX2_H,W
	MOVWF	SYSWORDTEMPA_H
	FCALL	SYSCOMPLESSTHAN16
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF16
;GLCDTemp = LineX1
	MOVF	LINEX1,W
	MOVWF	GLCDTEMP
	MOVF	LINEX1_H,W
	MOVWF	GLCDTEMP_H
;LineX1 = LineX2
	MOVF	LINEX2,W
	MOVWF	LINEX1
	MOVF	LINEX2_H,W
	MOVWF	LINEX1_H
;LineX2 = GLCDTemp
	MOVF	GLCDTEMP,W
	MOVWF	LINEX2
	MOVF	GLCDTEMP_H,W
	MOVWF	LINEX2_H
;End If
GLOBAL	ENDIF16
ENDIF16:
;If LineY1 > LineY2 Then
	MOVF	LINEY1,W
	MOVWF	SYSWORDTEMPB
	MOVF	LINEY1_H,W
	MOVWF	SYSWORDTEMPB_H
	MOVF	LINEY2,W
	MOVWF	SYSWORDTEMPA
	MOVF	LINEY2_H,W
	MOVWF	SYSWORDTEMPA_H
	FCALL	SYSCOMPLESSTHAN16
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF17
;GLCDTemp = LineY1
	MOVF	LINEY1,W
	MOVWF	GLCDTEMP
	MOVF	LINEY1_H,W
	MOVWF	GLCDTEMP_H
;LineY1 = LineY2
	MOVF	LINEY2,W
	MOVWF	LINEY1
	MOVF	LINEY2_H,W
	MOVWF	LINEY1_H
;LineY2 = GLCDTemp
	MOVF	GLCDTEMP,W
	MOVWF	LINEY2
	MOVF	GLCDTEMP_H,W
	MOVWF	LINEY2_H
;End If
GLOBAL	ENDIF17
ENDIF17:
;dim DrawLine as word
;Draw lines going across
;For DrawLine = LineX1 To LineX2
	MOVF	LINEX1,W
	MOVWF	DRAWLINE
	MOVF	LINEX1_H,W
	MOVWF	DRAWLINE_H
GLOBAL	SYSFORLOOP5
SYSFORLOOP5:
;PSet DrawLine, LineY1, LineColour
	MOVF	DRAWLINE,W
	MOVWF	GLCDX
	MOVF	LINEY1,W
	MOVWF	GLCDY
	MOVF	LINECOLOUR,W
	MOVWF	GLCDCOLOUR
	MOVF	LINECOLOUR_H,W
	MOVWF	GLCDCOLOUR_H
	FCALL	PSET_SSD1306
;PSet DrawLine, LineY2, LineColour
	MOVF	DRAWLINE,W
	MOVWF	GLCDX
	MOVF	LINEY2,W
	MOVWF	GLCDY
	MOVF	LINECOLOUR,W
	MOVWF	GLCDCOLOUR
	MOVF	LINECOLOUR_H,W
	MOVWF	GLCDCOLOUR_H
	FCALL	PSET_SSD1306
;Next
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	DRAWLINE,W
	SUBWF	LINEX2,W
	BANKSEL	SYSTEMP1
	MOVWF	SYSTEMP1
	BANKSEL	DRAWLINE_H
	MOVF	DRAWLINE_H,W
	SUBWFB	LINEX2_H,W
	BANKSEL	SYSTEMP1_H
	MOVWF	SYSTEMP1_H
	MOVF	SYSTEMP1,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSTEMP1_H,W
	MOVWF	SYSWORDTEMPA_H
	CLRF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPEQUAL16
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF18
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	INCF	DRAWLINE,F
	BTFSC	STATUS,2
	INCF	DRAWLINE_H,F
	GOTO	SYSFORLOOP5
;END IF
GLOBAL	ENDIF18
ENDIF18:
GLOBAL	SYSFORLOOPEND5
SYSFORLOOPEND5:
;Draw lines going down
;For DrawLine = LineY1 To LineY2
	MOVF	LINEY1,W
	MOVWF	DRAWLINE
	MOVF	LINEY1_H,W
	MOVWF	DRAWLINE_H
GLOBAL	SYSFORLOOP6
SYSFORLOOP6:
;PSet LineX1, DrawLine, LineColour
	MOVF	LINEX1,W
	MOVWF	GLCDX
	MOVF	DRAWLINE,W
	MOVWF	GLCDY
	MOVF	LINECOLOUR,W
	MOVWF	GLCDCOLOUR
	MOVF	LINECOLOUR_H,W
	MOVWF	GLCDCOLOUR_H
	FCALL	PSET_SSD1306
;PSet LineX2, DrawLine, LineColour
	MOVF	LINEX2,W
	MOVWF	GLCDX
	MOVF	DRAWLINE,W
	MOVWF	GLCDY
	MOVF	LINECOLOUR,W
	MOVWF	GLCDCOLOUR
	MOVF	LINECOLOUR_H,W
	MOVWF	GLCDCOLOUR_H
	FCALL	PSET_SSD1306
;Next
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	DRAWLINE,W
	SUBWF	LINEY2,W
	BANKSEL	SYSTEMP1
	MOVWF	SYSTEMP1
	BANKSEL	DRAWLINE_H
	MOVF	DRAWLINE_H,W
	SUBWFB	LINEY2_H,W
	BANKSEL	SYSTEMP1_H
	MOVWF	SYSTEMP1_H
	MOVF	SYSTEMP1,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSTEMP1_H,W
	MOVWF	SYSWORDTEMPA_H
	CLRF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPEQUAL16
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF19
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	INCF	DRAWLINE,F
	BTFSC	STATUS,2
	INCF	DRAWLINE_H,F
	GOTO	SYSFORLOOP6
;END IF
GLOBAL	ENDIF19
ENDIF19:
GLOBAL	SYSFORLOOPEND6
SYSFORLOOPEND6:
	RETURN

;********************************************************************************

;SOURCE: TRIG2PLACES.H (74)
GLOBAL	FN_COS
FN_COS:
;return cosine of angle
;if trig_arg2 < 0 then               ;cosine is an even function,
	BANKSEL	TRIG_ARG2
	MOVF	TRIG_ARG2,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	TRIG_ARG2_H,W
	MOVWF	SYSINTEGERTEMPA_H
	CLRF	SYSINTEGERTEMPB
	CLRF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHANINT
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF12
;trig_arg2 = -1 * trig_arg2        ;so negate negative angle
	BANKSEL	TRIG_ARG2
	MOVF	TRIG_ARG2,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	TRIG_ARG2_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	255
	MOVWF	SYSINTEGERTEMPB
	MOVWF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	BANKSEL	TRIG_ARG2
	MOVWF	TRIG_ARG2
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	TRIG_ARG2_H
;end if
GLOBAL	ENDIF12
ENDIF12:
;trig_arg2 = trig_arg2 mod 360       ;reduce to 0 to 359 degrees
	BANKSEL	TRIG_ARG2
	MOVF	TRIG_ARG2,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	TRIG_ARG2_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	104
	MOVWF	SYSINTEGERTEMPB
	MOVLW	1
	MOVWF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSDIVSUBINT
	MOVF	SYSINTEGERTEMPX,W
	BANKSEL	TRIG_ARG2
	MOVWF	TRIG_ARG2
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	TRIG_ARG2_H
;trig_sign = 1                       ;assume result is positive
	MOVLW	1
	MOVWF	TRIG_SIGN
	CLRF	TRIG_SIGN_H
;if trig_arg2>90 and trig_arg2<270 then
	MOVF	TRIG_ARG2,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	TRIG_ARG2_H,W
	MOVWF	SYSINTEGERTEMPB_H
	MOVLW	90
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHANINT
	MOVF	SYSBYTETEMPX,W
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	BANKSEL	TRIG_ARG2
	MOVF	TRIG_ARG2,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	TRIG_ARG2_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	14
	MOVWF	SYSINTEGERTEMPB
	MOVLW	1
	MOVWF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHANINT
	BANKSEL	SYSTEMP3
	MOVF	SYSTEMP3,W
	ANDWF	SYSBYTETEMPX,W
	MOVWF	SYSTEMP1
	BTFSS	SYSTEMP1,0
	GOTO	ENDIF13
;trig_sign = -1                    ;but negative in II and III
	MOVLW	255
	BANKSEL	TRIG_SIGN
	MOVWF	TRIG_SIGN
	MOVWF	TRIG_SIGN_H
;end if
GLOBAL	ENDIF13
ENDIF13:
;trig_arg2 = trig_ref(trig_arg2)     ;get the trig_reference angle
	BANKSEL	TRIG_ARG2
	MOVF	TRIG_ARG2,W
	MOVWF	TRIG_ARG1
	MOVF	TRIG_ARG2_H,W
	MOVWF	TRIG_ARG1_H
	BANKSEL	STATUS
	CALL	FN_TRIG_REF
	BANKSEL	TRIG_REF
	MOVF	TRIG_REF,W
	MOVWF	TRIG_ARG2
	MOVF	TRIG_REF_H,W
	MOVWF	TRIG_ARG2_H
;trig_arg2 = [integer]90 - trig_arg2 ;use cofunction identity
	MOVF	TRIG_ARG2,W
	SUBLW	90
	MOVWF	TRIG_ARG2
	MOVLW	0
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	BANKSEL	TRIG_ARG2_H
	MOVF	TRIG_ARG2_H,W
	BANKSEL	SYSTEMP3
	SUBWFB	SYSTEMP3,W
	BANKSEL	TRIG_ARG2_H
	MOVWF	TRIG_ARG2_H
;trig_i = [byte]trig_arg2+1          ;index into the table
	INCF	TRIG_ARG2,W
	BANKSEL	TRIG_I
	MOVWF	TRIG_I
;readTable sineTab, trig_i, trig_val
	MOVWF	SYSSTRINGA
	BANKSEL	STATUS
	CALL	SINETAB
	BANKSEL	TRIG_VAL
	MOVWF	TRIG_VAL
	CLRF	TRIG_VAL_H
;cos = trig_sign * [integer]trig_val  ;create final result
	MOVF	TRIG_SIGN,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	TRIG_SIGN_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVF	TRIG_VAL,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	TRIG_VAL_H,W
	MOVWF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	MOVWF	COS
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	COS_H
	RETURN

;********************************************************************************

GLOBAL	GLCDCHARCOL3
GLCDCHARCOL3:
	MOVLW	113
	SUBWF	SYSSTRINGA, W
	BTFSC	STATUS,0
	RETLW	0
	MOVF	SYSSTRINGA, W
	ADDLW	LOW TABLEGLCDCHARCOL3
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH TABLEGLCDCHARCOL3) & 127
	BTFSC	STATUS,0
	ADDLW	1
	MOVWF	PCLATH
	MOVF	SYSSTRINGA, W
	MOVWF	PCL
GLOBAL	TABLEGLCDCHARCOL3
TABLEGLCDCHARCOL3:
	RETLW	112
	RETLW	0
	RETLW	16
	RETLW	12
	RETLW	10
	RETLW	136
	RETLW	34
	RETLW	56
	RETLW	32
	RETLW	8
	RETLW	32
	RETLW	16
	RETLW	16
	RETLW	128
	RETLW	128
	RETLW	64
	RETLW	4
	RETLW	0
	RETLW	0
	RETLW	0
	RETLW	40
	RETLW	72
	RETLW	70
	RETLW	108
	RETLW	0
	RETLW	0
	RETLW	0
	RETLW	40
	RETLW	16
	RETLW	0
	RETLW	16
	RETLW	0
	RETLW	64
	RETLW	124
	RETLW	0
	RETLW	132
	RETLW	130
	RETLW	48
	RETLW	78
	RETLW	120
	RETLW	6
	RETLW	108
	RETLW	12
	RETLW	0
	RETLW	0
	RETLW	16
	RETLW	40
	RETLW	0
	RETLW	4
	RETLW	100
	RETLW	248
	RETLW	254
	RETLW	124
	RETLW	254
	RETLW	254
	RETLW	254
	RETLW	124
	RETLW	254
	RETLW	0
	RETLW	64
	RETLW	254
	RETLW	254
	RETLW	254
	RETLW	254
	RETLW	124
	RETLW	254
	RETLW	124
	RETLW	254
	RETLW	76
	RETLW	2
	RETLW	126
	RETLW	62
	RETLW	126
	RETLW	198
	RETLW	14
	RETLW	194
	RETLW	0
	RETLW	4
	RETLW	0
	RETLW	8
	RETLW	128
	RETLW	0
	RETLW	64
	RETLW	254
	RETLW	112
	RETLW	112
	RETLW	112
	RETLW	16
	RETLW	16
	RETLW	254
	RETLW	0
	RETLW	64
	RETLW	254
	RETLW	0
	RETLW	248
	RETLW	248
	RETLW	112
	RETLW	248
	RETLW	16
	RETLW	248
	RETLW	144
	RETLW	16
	RETLW	120
	RETLW	56
	RETLW	120
	RETLW	136
	RETLW	24
	RETLW	136
	RETLW	0
	RETLW	0
	RETLW	0
	RETLW	32
	RETLW	120

;********************************************************************************

GLOBAL	GLCDCHARCOL4
GLCDCHARCOL4:
	MOVLW	113
	SUBWF	SYSSTRINGA, W
	BTFSC	STATUS,0
	RETLW	0
	MOVF	SYSSTRINGA, W
	ADDLW	LOW TABLEGLCDCHARCOL4
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH TABLEGLCDCHARCOL4) & 127
	BTFSC	STATUS,0
	ADDLW	1
	MOVWF	PCLATH
	MOVF	SYSSTRINGA, W
	MOVWF	PCL
GLOBAL	TABLEGLCDCHARCOL4
TABLEGLCDCHARCOL4:
	RETLW	112
	RETLW	254
	RETLW	56
	RETLW	10
	RETLW	6
	RETLW	204
	RETLW	102
	RETLW	124
	RETLW	112
	RETLW	4
	RETLW	64
	RETLW	16
	RETLW	56
	RETLW	136
	RETLW	162
	RETLW	112
	RETLW	28
	RETLW	0
	RETLW	0
	RETLW	14
	RETLW	254
	RETLW	84
	RETLW	38
	RETLW	146
	RETLW	10
	RETLW	56
	RETLW	130
	RETLW	16
	RETLW	16
	RETLW	160
	RETLW	16
	RETLW	192
	RETLW	32
	RETLW	162
	RETLW	132
	RETLW	194
	RETLW	130
	RETLW	40
	RETLW	138
	RETLW	148
	RETLW	2
	RETLW	146
	RETLW	146
	RETLW	108
	RETLW	172
	RETLW	40
	RETLW	40
	RETLW	130
	RETLW	2
	RETLW	146
	RETLW	36
	RETLW	146
	RETLW	130
	RETLW	130
	RETLW	146
	RETLW	18
	RETLW	130
	RETLW	16
	RETLW	130
	RETLW	128
	RETLW	16
	RETLW	128
	RETLW	4
	RETLW	8
	RETLW	130
	RETLW	18
	RETLW	130
	RETLW	18
	RETLW	146
	RETLW	2
	RETLW	128
	RETLW	64
	RETLW	128
	RETLW	40
	RETLW	16
	RETLW	162
	RETLW	254
	RETLW	8
	RETLW	130
	RETLW	4
	RETLW	128
	RETLW	2
	RETLW	168
	RETLW	144
	RETLW	136
	RETLW	136
	RETLW	168
	RETLW	252
	RETLW	168
	RETLW	16
	RETLW	144
	RETLW	128
	RETLW	32
	RETLW	130
	RETLW	8
	RETLW	16
	RETLW	136
	RETLW	40
	RETLW	40
	RETLW	16
	RETLW	168
	RETLW	124
	RETLW	128
	RETLW	64
	RETLW	128
	RETLW	80
	RETLW	160
	RETLW	200
	RETLW	16
	RETLW	0
	RETLW	130
	RETLW	16
	RETLW	68

;********************************************************************************

GLOBAL	GLCDCHARCOL5
GLCDCHARCOL5:
	MOVLW	113
	SUBWF	SYSSTRINGA, W
	BTFSC	STATUS,0
	RETLW	0
	MOVF	SYSSTRINGA, W
	ADDLW	LOW TABLEGLCDCHARCOL5
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH TABLEGLCDCHARCOL5) & 127
	BTFSC	STATUS,0
	ADDLW	1
	MOVWF	PCLATH
	MOVF	SYSSTRINGA, W
	MOVWF	PCL
GLOBAL	TABLEGLCDCHARCOL5
TABLEGLCDCHARCOL5:
	RETLW	112
	RETLW	124
	RETLW	124
	RETLW	0
	RETLW	0
	RETLW	238
	RETLW	238
	RETLW	124
	RETLW	168
	RETLW	254
	RETLW	254
	RETLW	84
	RETLW	84
	RETLW	148
	RETLW	148
	RETLW	124
	RETLW	124
	RETLW	0
	RETLW	158
	RETLW	0
	RETLW	40
	RETLW	254
	RETLW	16
	RETLW	170
	RETLW	6
	RETLW	68
	RETLW	68
	RETLW	124
	RETLW	124
	RETLW	96
	RETLW	16
	RETLW	192
	RETLW	16
	RETLW	146
	RETLW	254
	RETLW	162
	RETLW	138
	RETLW	36
	RETLW	138
	RETLW	146
	RETLW	226
	RETLW	146
	RETLW	146
	RETLW	108
	RETLW	108
	RETLW	68
	RETLW	40
	RETLW	68
	RETLW	162
	RETLW	242
	RETLW	34
	RETLW	146
	RETLW	130
	RETLW	130
	RETLW	146
	RETLW	18
	RETLW	146
	RETLW	16
	RETLW	254
	RETLW	130
	RETLW	40
	RETLW	128
	RETLW	24
	RETLW	16
	RETLW	130
	RETLW	18
	RETLW	162
	RETLW	50
	RETLW	146
	RETLW	254
	RETLW	128
	RETLW	128
	RETLW	112
	RETLW	16
	RETLW	224
	RETLW	146
	RETLW	130
	RETLW	16
	RETLW	130
	RETLW	2
	RETLW	128
	RETLW	4
	RETLW	168
	RETLW	136
	RETLW	136
	RETLW	136
	RETLW	168
	RETLW	18
	RETLW	168
	RETLW	8
	RETLW	250
	RETLW	136
	RETLW	80
	RETLW	254
	RETLW	240
	RETLW	8
	RETLW	136
	RETLW	40
	RETLW	40
	RETLW	8
	RETLW	168
	RETLW	144
	RETLW	128
	RETLW	128
	RETLW	96
	RETLW	32
	RETLW	160
	RETLW	168
	RETLW	108
	RETLW	254
	RETLW	108
	RETLW	16
	RETLW	66

;********************************************************************************

GLOBAL	GLCDCHARCOL6
GLCDCHARCOL6:
	MOVLW	113
	SUBWF	SYSSTRINGA, W
	BTFSC	STATUS,0
	RETLW	0
	MOVF	SYSSTRINGA, W
	ADDLW	LOW TABLEGLCDCHARCOL6
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH TABLEGLCDCHARCOL6) & 127
	BTFSC	STATUS,0
	ADDLW	1
	MOVWF	PCLATH
	MOVF	SYSSTRINGA, W
	MOVWF	PCL
GLOBAL	TABLEGLCDCHARCOL6
TABLEGLCDCHARCOL6:
	RETLW	112
	RETLW	56
	RETLW	254
	RETLW	12
	RETLW	10
	RETLW	204
	RETLW	102
	RETLW	124
	RETLW	32
	RETLW	4
	RETLW	64
	RETLW	56
	RETLW	16
	RETLW	162
	RETLW	136
	RETLW	112
	RETLW	28
	RETLW	0
	RETLW	0
	RETLW	14
	RETLW	254
	RETLW	84
	RETLW	200
	RETLW	68
	RETLW	0
	RETLW	130
	RETLW	56
	RETLW	16
	RETLW	16
	RETLW	0
	RETLW	16
	RETLW	0
	RETLW	8
	RETLW	138
	RETLW	128
	RETLW	146
	RETLW	150
	RETLW	254
	RETLW	138
	RETLW	146
	RETLW	18
	RETLW	146
	RETLW	82
	RETLW	0
	RETLW	0
	RETLW	130
	RETLW	40
	RETLW	40
	RETLW	18
	RETLW	130
	RETLW	36
	RETLW	146
	RETLW	130
	RETLW	68
	RETLW	146
	RETLW	18
	RETLW	146
	RETLW	16
	RETLW	130
	RETLW	126
	RETLW	68
	RETLW	128
	RETLW	4
	RETLW	32
	RETLW	130
	RETLW	18
	RETLW	66
	RETLW	82
	RETLW	146
	RETLW	2
	RETLW	128
	RETLW	64
	RETLW	128
	RETLW	40
	RETLW	16
	RETLW	138
	RETLW	130
	RETLW	32
	RETLW	254
	RETLW	4
	RETLW	128
	RETLW	8
	RETLW	168
	RETLW	136
	RETLW	136
	RETLW	144
	RETLW	168
	RETLW	2
	RETLW	168
	RETLW	8
	RETLW	128
	RETLW	122
	RETLW	136
	RETLW	128
	RETLW	8
	RETLW	8
	RETLW	136
	RETLW	40
	RETLW	48
	RETLW	8
	RETLW	168
	RETLW	128
	RETLW	64
	RETLW	64
	RETLW	128
	RETLW	80
	RETLW	160
	RETLW	152
	RETLW	130
	RETLW	0
	RETLW	16
	RETLW	32
	RETLW	68

;********************************************************************************

GLOBAL	GLCDCHARCOL7
GLCDCHARCOL7:
	MOVLW	113
	SUBWF	SYSSTRINGA, W
	BTFSC	STATUS,0
	RETLW	0
	MOVF	SYSSTRINGA, W
	ADDLW	LOW TABLEGLCDCHARCOL7
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH TABLEGLCDCHARCOL7) & 127
	BTFSC	STATUS,0
	ADDLW	1
	MOVWF	PCLATH
	MOVF	SYSSTRINGA, W
	MOVWF	PCL
GLOBAL	TABLEGLCDCHARCOL7
TABLEGLCDCHARCOL7:
	RETLW	112
	RETLW	16
	RETLW	0
	RETLW	10
	RETLW	6
	RETLW	136
	RETLW	34
	RETLW	56
	RETLW	62
	RETLW	8
	RETLW	32
	RETLW	16
	RETLW	16
	RETLW	128
	RETLW	128
	RETLW	64
	RETLW	4
	RETLW	0
	RETLW	0
	RETLW	0
	RETLW	40
	RETLW	36
	RETLW	196
	RETLW	160
	RETLW	0
	RETLW	0
	RETLW	0
	RETLW	40
	RETLW	16
	RETLW	0
	RETLW	16
	RETLW	0
	RETLW	4
	RETLW	124
	RETLW	0
	RETLW	140
	RETLW	98
	RETLW	32
	RETLW	114
	RETLW	96
	RETLW	14
	RETLW	108
	RETLW	60
	RETLW	0
	RETLW	0
	RETLW	0
	RETLW	40
	RETLW	16
	RETLW	12
	RETLW	124
	RETLW	248
	RETLW	108
	RETLW	68
	RETLW	56
	RETLW	130
	RETLW	2
	RETLW	244
	RETLW	254
	RETLW	0
	RETLW	2
	RETLW	130
	RETLW	128
	RETLW	254
	RETLW	254
	RETLW	124
	RETLW	12
	RETLW	188
	RETLW	140
	RETLW	100
	RETLW	2
	RETLW	126
	RETLW	62
	RETLW	126
	RETLW	198
	RETLW	14
	RETLW	134
	RETLW	0
	RETLW	64
	RETLW	0
	RETLW	8
	RETLW	128
	RETLW	0
	RETLW	240
	RETLW	112
	RETLW	64
	RETLW	254
	RETLW	48
	RETLW	4
	RETLW	120
	RETLW	240
	RETLW	0
	RETLW	0
	RETLW	0
	RETLW	0
	RETLW	240
	RETLW	240
	RETLW	112
	RETLW	16
	RETLW	248
	RETLW	16
	RETLW	64
	RETLW	64
	RETLW	248
	RETLW	56
	RETLW	120
	RETLW	136
	RETLW	120
	RETLW	136
	RETLW	0
	RETLW	0
	RETLW	0
	RETLW	16
	RETLW	120

;********************************************************************************

;SOURCE: GLCD_SSD1306.H (427)
GLOBAL	GLCDCLS_SSD1306
GLCDCLS_SSD1306:
;initialise global variable. Required variable for Circle in all DEVICE DRIVERS- DO NOT DELETE
;GLCD_yordinate = 0
	CLRF	GLCD_YORDINATE
	CLRF	GLCD_YORDINATE_H
;For SSD1306_BufferLocationCalc = 1 to GLCD_HEIGHT * GLCD_WIDTH / 8
	MOVLW	1
	BANKSEL	SSD1306_BUFFERLOCATIONCALC
	MOVWF	SSD1306_BUFFERLOCATIONCALC
	CLRF	SSD1306_BUFFERLOCATIONCALC_H
GLOBAL	SYSFORLOOP7
SYSFORLOOP7:
;SSD1306_BufferAlias(SSD1306_BufferLocationCalc) = 0
	MOVLW	LOW(SSD1306_BUFFERALIAS)
	ADDWF	SSD1306_BUFFERLOCATIONCALC,W
	MOVWF	FSR0L
	MOVLW	HIGH(SSD1306_BUFFERALIAS)
	ADDWFC	SSD1306_BUFFERLOCATIONCALC_H,W
	MOVWF	FSR0H
	CLRF	INDF0
;Next
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	SSD1306_BUFFERLOCATIONCALC,W
	SUBLW	0
	MOVWF	SYSTEMP1
	MOVLW	4
	MOVWF	SYSTEMP3
	MOVF	SSD1306_BUFFERLOCATIONCALC_H,W
	SUBWFB	SYSTEMP3,W
	MOVWF	SYSTEMP1_H
	MOVF	SYSTEMP1,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSTEMP1_H,W
	MOVWF	SYSWORDTEMPA_H
	CLRF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPEQUAL16
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF20
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	BANKSEL	SSD1306_BUFFERLOCATIONCALC
	INCF	SSD1306_BUFFERLOCATIONCALC,F
	BTFSC	STATUS,2
	INCF	SSD1306_BUFFERLOCATIONCALC_H,F
	GOTO	SYSFORLOOP7
;END IF
GLOBAL	ENDIF20
ENDIF20:
GLOBAL	SYSFORLOOPEND7
SYSFORLOOPEND7:
;1.14 changed to transaction
;For SSD1306_BufferLocationCalc = 0 to GLCD_HEIGHT-1 step 8
	BANKSEL	SSD1306_BUFFERLOCATIONCALC
	CLRF	SSD1306_BUFFERLOCATIONCALC
	CLRF	SSD1306_BUFFERLOCATIONCALC_H
GLOBAL	SYSFORLOOP8
SYSFORLOOP8:
;INIT SYSFORLOOPSTEP7 :#0
	MOVLW	8
	MOVWF	SYSFORLOOPSTEP7
	CLRF	SYSFORLOOPSTEP7_H
;Cursor_Position_SSD1306 ( 0 , SSD1306_BufferLocationCalc )
	BANKSEL	LOCX
	CLRF	LOCX
	BANKSEL	SSD1306_BUFFERLOCATIONCALC
	MOVF	SSD1306_BUFFERLOCATIONCALC,W
	BANKSEL	LOCY
	MOVWF	LOCY
	FCALL	CURSOR_POSITION_SSD1306
;Open_Transaction_SSD1306
;Macro Source: glcd_ssd1306.h (1218)
;4wire not supported, see Write_Transaction_Data_SSD1306
;HI2CStart
	FCALL	HI2CSTART
;HI2CSend GLCD_I2C_Address
	MOVLW	120
	MOVWF	I2CBYTE
	FCALL	HI2CSEND
;HI2CSend 0x40
	MOVLW	64
	MOVWF	I2CBYTE
	FCALL	HI2CSEND
;For GLCDTemp = 0 to 127
;LEGACY METHOD
	MOVLW	255
	MOVWF	GLCDTEMP
GLOBAL	SYSFORLOOP9
SYSFORLOOP9:
	INCF	GLCDTEMP,F
;Write_Transaction_Data_SSD1306(GLCDBackground)
;Macro Source: glcd_ssd1306.h (1249)
;HI2CSend SSD1306SendByte
	MOVF	GLCDBACKGROUND,W
	MOVWF	I2CBYTE
	FCALL	HI2CSEND
;Next
	MOVLW	127
	SUBWF	GLCDTEMP,W
	BTFSS	STATUS,0
	GOTO	SYSFORLOOP9
GLOBAL	SYSFORLOOPEND9
SYSFORLOOPEND9:
;Close_Transaction_SSD1306
;Macro Source: glcd_ssd1306.h (1282)
;4wire not supported, see Write_Transaction_Data_SSD1306
;HI2CStop
	FCALL	HI2CSTOP
;Next
;INTEGER NEGATIVE STEP HANDLER IN FOR-NEXT STATEMENT
	BANKSEL	SYSFORLOOPSTEP7_H
	BTFSS	SYSFORLOOPSTEP7_H,7
	GOTO	ELSE22_1
;SET SYSFORLOOPABSVALUE TO -STEPVALUE :#1 
	COMF	SYSFORLOOPSTEP7,W
	MOVWF	SYSFORLOOPABSVALUE8
	COMF	SYSFORLOOPSTEP7_H,W
	MOVWF	SYSFORLOOPABSVALUE8_H
	INCF	SYSFORLOOPABSVALUE8,F
	BTFSC	STATUS,2
	INCF	SYSFORLOOPABSVALUE8_H,F
;IF ( SSD1306_BUFFERLOCATIONCALC - 64-1) } [WORD]SYSFORLOOPABSVALUE8 THEN  :#1N 
	MOVLW	64
	SUBWF	SSD1306_BUFFERLOCATIONCALC,W
	MOVWF	SYSTEMP1
	MOVLW	0
	SUBWFB	SSD1306_BUFFERLOCATIONCALC_H,W
	MOVWF	SYSTEMP1_H
	MOVLW	1
	SUBWF	SYSTEMP1,W
	MOVWF	SYSTEMP2
	MOVLW	0
	SUBWFB	SYSTEMP1_H,W
	MOVWF	SYSTEMP2_H
	MOVF	SYSTEMP2,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSTEMP2_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVF	SYSFORLOOPABSVALUE8,W
	MOVWF	SYSWORDTEMPB
	MOVF	SYSFORLOOPABSVALUE8_H,W
	MOVWF	SYSWORDTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHAN16
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF23
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A NEGATIVE VALUE
	BANKSEL	SYSFORLOOPSTEP7
	MOVF	SYSFORLOOPSTEP7,W
	ADDWF	SSD1306_BUFFERLOCATIONCALC,F
	MOVF	SYSFORLOOPSTEP7_H,W
	ADDWFC	SSD1306_BUFFERLOCATIONCALC_H,F
	GOTO	SYSFORLOOP8
;END IF
GLOBAL	ENDIF23
ENDIF23:
	GOTO	ENDIF22
GLOBAL	ELSE22_1
ELSE22_1:
;INTEGER POSITIVE STEP HANDLER IN FOR-NEXT STATEMENT
;IF ([WORD]64-1 - [WORD]SSD1306_BUFFERLOCATIONCALC) } [WORD]SYSFORLOOPSTEP7 THEN :#1P 
	MOVF	SSD1306_BUFFERLOCATIONCALC,W
	SUBLW	63
	MOVWF	SYSTEMP1
	CLRF	SYSTEMP3
	MOVF	SSD1306_BUFFERLOCATIONCALC_H,W
	SUBWFB	SYSTEMP3,W
	MOVWF	SYSTEMP1_H
	MOVF	SYSTEMP1,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSTEMP1_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVF	SYSFORLOOPSTEP7,W
	MOVWF	SYSWORDTEMPB
	MOVF	SYSFORLOOPSTEP7_H,W
	MOVWF	SYSWORDTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHAN16
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF24
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	BANKSEL	SYSFORLOOPSTEP7
	MOVF	SYSFORLOOPSTEP7,W
	ADDWF	SSD1306_BUFFERLOCATIONCALC,F
	MOVF	SYSFORLOOPSTEP7_H,W
	ADDWFC	SSD1306_BUFFERLOCATIONCALC_H,F
	GOTO	SYSFORLOOP8
;END IF
GLOBAL	ENDIF24
ENDIF24:
;END IF
GLOBAL	ENDIF22
ENDIF22:
GLOBAL	SYSFORLOOPEND8
SYSFORLOOPEND8:
;Removed at 1.14. Retained for documentation only
;Cursor_Position_SSD1306 ( 0 , 0 )
;for SSD1306_BufferLocationCalc = 0 to GLCD_HEIGHT-1 step 8
;for GLCDTemp = 0 to 127
;Write_Data_SSD1306(GLCDBackground)
;Next
;next
;Cursor_Position_SSD1306 ( 0 , 0 )
	CLRF	LOCX
	CLRF	LOCY
	FCALL	CURSOR_POSITION_SSD1306
;PrintLocX =0
	BANKSEL	PRINTLOCX
	CLRF	PRINTLOCX
;PrintLocY =0
	CLRF	PRINTLOCY
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;OVERLOADED SIGNATURE: WORD:WORD:STRING:WORD:, SOURCE: GLCD.H (1010)
GLOBAL	GLCDPRINT12
GLCDPRINT12:
;Dim GLCDPrintLoc as word
;GLCDPrintLen = LCDPrintData(0)
	BANKSEL	SYSLCDPRINTDATAHANDLER
	MOVF	SYSLCDPRINTDATAHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSLCDPRINTDATAHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	BANKSEL	GLCDPRINTLEN
	MOVWF	GLCDPRINTLEN
;If GLCDPrintLen = 0 Then Exit Sub
	MOVF	GLCDPRINTLEN,F
	BTFSC	STATUS,2
;If GLCDPrintLen = 0 Then Exit Sub
	RETURN
;If GLCDPrintLen = 0 Then Exit Sub
;GLCDPrintLoc = PrintLocX
	BANKSEL	PRINTLOCX
	MOVF	PRINTLOCX,W
	BANKSEL	GLCDPRINTLOC
	MOVWF	GLCDPRINTLOC
	BANKSEL	PRINTLOCX_H
	MOVF	PRINTLOCX_H,W
	BANKSEL	GLCDPRINTLOC_H
	MOVWF	GLCDPRINTLOC_H
;Write Data
;For GLCDPrint_String_Counter = 1 To GLCDPrintLen
	MOVLW	1
	MOVWF	GLCDPRINT_STRING_COUNTER
GLOBAL	SYSFORLOOP4
SYSFORLOOP4:
;GLCDDrawChar GLCDPrintLoc, PrintLocY, LCDPrintData(GLCDPrint_String_Counter), LineColour
	MOVF	GLCDPRINTLOC,W
	MOVWF	CHARLOCX
	MOVF	GLCDPRINTLOC_H,W
	MOVWF	CHARLOCX_H
	BANKSEL	PRINTLOCY
	MOVF	PRINTLOCY,W
	BANKSEL	CHARLOCY
	MOVWF	CHARLOCY
	BANKSEL	PRINTLOCY_H
	MOVF	PRINTLOCY_H,W
	BANKSEL	CHARLOCY_H
	MOVWF	CHARLOCY_H
	MOVF	GLCDPRINT_STRING_COUNTER,W
	BANKSEL	SYSLCDPRINTDATAHANDLER
	ADDWF	SYSLCDPRINTDATAHANDLER,W
	MOVWF	FSR0L
	MOVLW	0
	ADDWFC	SYSLCDPRINTDATAHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	BANKSEL	CHARCODE
	MOVWF	CHARCODE
	FCALL	GLCDDRAWCHAR_SSD1306
;GLCDPrintIncrementPixelPositionMacro
;Macro Source: glcd.h (1219)
;GLCDPrintLoc = GLCDPrintLoc + ( GLCDFontWidth * GLCDfntDefaultsize )+1
	MOVF	GLCDFONTWIDTH,W
	MOVWF	SYSBYTETEMPA
	MOVF	GLCDFNTDEFAULTSIZE,W
	MOVWF	SYSBYTETEMPB
	FCALL	SYSMULTSUB
	MOVF	SYSBYTETEMPX,W
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	BANKSEL	GLCDPRINTLOC
	ADDWF	GLCDPRINTLOC,W
	BANKSEL	SYSTEMP1
	MOVWF	SYSTEMP1
	MOVLW	0
	BANKSEL	GLCDPRINTLOC_H
	ADDWFC	GLCDPRINTLOC_H,W
	BANKSEL	SYSTEMP1_H
	MOVWF	SYSTEMP1_H
	MOVLW	1
	ADDWF	SYSTEMP1,W
	BANKSEL	GLCDPRINTLOC
	MOVWF	GLCDPRINTLOC
	MOVLW	0
	BANKSEL	SYSTEMP1_H
	ADDWFC	SYSTEMP1_H,W
	BANKSEL	GLCDPRINTLOC_H
	MOVWF	GLCDPRINTLOC_H
;Next
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	GLCDPRINT_STRING_COUNTER,W
	SUBWF	GLCDPRINTLEN,W
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	MOVWF	SYSBYTETEMPA
	CLRF	SYSBYTETEMPB
	BANKSEL	STATUS
	FCALL	SYSCOMPEQUAL
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF15
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	INCF	GLCDPRINT_STRING_COUNTER,F
	GOTO	SYSFORLOOP4
;END IF
GLOBAL	ENDIF15
ENDIF15:
GLOBAL	SYSFORLOOPEND4
SYSFORLOOPEND4:
;Update the current X position for GLCDPrintString
;PrintLocX = GLCDPrintLoc
	MOVF	GLCDPRINTLOC,W
	BANKSEL	PRINTLOCX
	MOVWF	PRINTLOCX
	BANKSEL	GLCDPRINTLOC_H
	MOVF	GLCDPRINTLOC_H,W
	BANKSEL	PRINTLOCX_H
	MOVWF	PRINTLOCX_H
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: STRING.H (394)
GLOBAL	FN_MID
FN_MID:
;Empty input?
;If SysInString(0) = 0 Then
	BANKSEL	SYSSYSINSTRINGHANDLER
	MOVF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,F
	BTFSS	STATUS,2
	GOTO	ENDIF67
;Mid(0) = 0
	BANKSEL	SYSMID_0
	CLRF	SYSMID_0
;Exit Function
	BANKSEL	STATUS
	RETURN
;End If
GLOBAL	ENDIF67
ENDIF67:
;Starting position too low?
;If SysCharStart < 1 Then SysCharStart = 1
	MOVLW	1
	SUBWF	SYSCHARSTART,W
	BTFSC	STATUS,0
	GOTO	ENDIF68
;If SysCharStart < 1 Then SysCharStart = 1
	MOVLW	1
	MOVWF	SYSCHARSTART
;If SysCharStart < 1 Then SysCharStart = 1
GLOBAL	ENDIF68
ENDIF68:
;Starting position too high?
;If SysCharStart > SysInString(0) Then
	MOVF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	SYSCHARSTART,W
	SUBWF	INDF0,W
	BTFSC	STATUS,0
	GOTO	ENDIF69
;Mid(0) = 0
	BANKSEL	SYSMID_0
	CLRF	SYSMID_0
;Exit Function
	BANKSEL	STATUS
	RETURN
;End If
GLOBAL	ENDIF69
ENDIF69:
;Input length too high?
;SysCharStart -= 1
	DECF	SYSCHARSTART,F
;SysStringTemp = SysInString(0) - SysCharStart 'Max number of characters
	MOVF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	SYSCHARSTART,W
	SUBWF	INDF0,W
	MOVWF	SYSSTRINGTEMP
;If SysCharCount > SysStringTemp Then
	MOVF	SYSCHARCOUNT,W
	SUBWF	SYSSTRINGTEMP,W
	BTFSC	STATUS,0
	GOTO	ENDIF70
;SysCharCount = SysStringTemp
	MOVF	SYSSTRINGTEMP,W
	MOVWF	SYSCHARCOUNT
;End If
GLOBAL	ENDIF70
ENDIF70:
;Copy characters
;For SysStringTemp = 1 To SysCharCount
	MOVLW	1
	MOVWF	SYSSTRINGTEMP
GLOBAL	SYSFORLOOP15
SYSFORLOOP15:
;Mid(SysStringTemp) = SysInString(SysCharStart + SysStringTemp)
	MOVF	SYSSTRINGTEMP,W
	ADDWF	SYSCHARSTART,W
	MOVWF	SYSTEMP3
	ADDWF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVLW	0
	ADDWFC	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	MOVWF	SYSARRAYTEMP1
	MOVWF	SYSARRAYTEMP2
	MOVLW	LOW(MID)
	ADDWF	SYSSTRINGTEMP,W
	MOVWF	FSR0L
	CLRF	SYSTEMP3
	MOVLW	HIGH(MID)
	ADDWFC	SYSTEMP3,W
	MOVWF	FSR0H
	MOVF	SYSARRAYTEMP2,W
	MOVWF	INDF0
;Next
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	SYSSTRINGTEMP,W
	SUBWF	SYSCHARCOUNT,W
	MOVWF	SYSTEMP3
	MOVWF	SYSBYTETEMPA
	CLRF	SYSBYTETEMPB
	BANKSEL	STATUS
	FCALL	SYSCOMPEQUAL
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF71
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	BANKSEL	SYSSTRINGTEMP
	INCF	SYSSTRINGTEMP,F
	GOTO	SYSFORLOOP15
;END IF
GLOBAL	ENDIF71
ENDIF71:
GLOBAL	SYSFORLOOPEND15
SYSFORLOOPEND15:
;Mid(0) = SysCharCount
	BANKSEL	SYSCHARCOUNT
	MOVF	SYSCHARCOUNT,W
	BANKSEL	SYSMID_0
	MOVWF	SYSMID_0
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: 230_I2C_GLCD_VOLTMETER_USING_SSD1306.GCB (168)
GLOBAL	PLOTDIAL
PLOTDIAL:
;xend = 63 + radius  * sin (angle)/255
	MOVF	ANGLE,W
	BANKSEL	TRIG_ARG2
	MOVWF	TRIG_ARG2
	BANKSEL	ANGLE_H
	MOVF	ANGLE_H,W
	BANKSEL	TRIG_ARG2_H
	MOVWF	TRIG_ARG2_H
	BANKSEL	STATUS
	CALL	FN_SIN
	BANKSEL	RADIUS
	MOVF	RADIUS,W
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	MOVF	SIN,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	SIN_H,W
	MOVWF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	BANKSEL	SYSTEMP2
	MOVWF	SYSTEMP2
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	SYSTEMP2_H
	MOVF	SYSTEMP2,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	SYSTEMP2_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	255
	MOVWF	SYSINTEGERTEMPB
	CLRF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSDIVSUBINT
	MOVLW	63
	ADDWF	SYSINTEGERTEMPA,W
	BANKSEL	XEND
	MOVWF	XEND
;yend = 58 - radius  * cos (angle)/255
	BANKSEL	ANGLE
	MOVF	ANGLE,W
	BANKSEL	TRIG_ARG2
	MOVWF	TRIG_ARG2
	BANKSEL	ANGLE_H
	MOVF	ANGLE_H,W
	BANKSEL	TRIG_ARG2_H
	MOVWF	TRIG_ARG2_H
	BANKSEL	STATUS
	CALL	FN_COS
	BANKSEL	RADIUS
	MOVF	RADIUS,W
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	BANKSEL	COS
	MOVF	COS,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	COS_H,W
	MOVWF	SYSINTEGERTEMPB_H
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	BANKSEL	SYSTEMP2
	MOVWF	SYSTEMP2
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	SYSTEMP2_H
	MOVF	SYSTEMP2,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	SYSTEMP2_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	255
	MOVWF	SYSINTEGERTEMPB
	CLRF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSDIVSUBINT
	MOVF	SYSINTEGERTEMPA,W
	SUBLW	58
	BANKSEL	YEND
	MOVWF	YEND
;Pset (xend,yend,1)
	MOVF	XEND,W
	BANKSEL	GLCDX
	MOVWF	GLCDX
	BANKSEL	YEND
	MOVF	YEND,W
	BANKSEL	GLCDY
	MOVWF	GLCDY
	MOVLW	1
	MOVWF	GLCDCOLOUR
	CLRF	GLCDCOLOUR_H
	LJMP	PSET_SSD1306

;********************************************************************************

;SOURCE: GLCD_SSD1306.H (883)
GLOBAL	PSET_SSD1306
PSET_SSD1306:
;Set pixel at X, Y on LCD to State
;X is 0 to 127
;Y is 0 to 63
;Origin in top left
;anything off screen with be rejected
;if GLCDX => GLCD_WIDTH OR GLCDY => GLCD_HEIGHT Then
	MOVF	GLCDX,W
	MOVWF	SYSBYTETEMPA
	MOVLW	128
	MOVWF	SYSBYTETEMPB
	FCALL	SYSCOMPLESSTHAN
	COMF	SYSBYTETEMPX,F
	MOVF	SYSBYTETEMPX,W
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	BANKSEL	GLCDY
	MOVF	GLCDY,W
	MOVWF	SYSBYTETEMPA
	MOVLW	64
	MOVWF	SYSBYTETEMPB
	FCALL	SYSCOMPLESSTHAN
	COMF	SYSBYTETEMPX,F
	BANKSEL	SYSTEMP3
	MOVF	SYSTEMP3,W
	IORWF	SYSBYTETEMPX,W
	MOVWF	SYSTEMP1
	BTFSS	SYSTEMP1,0
	GOTO	ENDIF32
;exit sub
	BANKSEL	STATUS
	RETURN
;end if
GLOBAL	ENDIF32
ENDIF32:
;1.14 Addresses correct device horizonal page
;don't need to do these calculations for in LOWMEMORY_GLCD_MODE
;SSD1306_BufferLocationCalc = ( GLCDY / 8 )* GLCD_WIDTH
;faster than /8
;SSD1306_BufferLocationCalc = GLCDY
	BANKSEL	GLCDY
	MOVF	GLCDY,W
	BANKSEL	SSD1306_BUFFERLOCATIONCALC
	MOVWF	SSD1306_BUFFERLOCATIONCALC
	CLRF	SSD1306_BUFFERLOCATIONCALC_H
;Repeat 3
	MOVLW	3
	MOVWF	SYSREPEATTEMP1
GLOBAL	SYSREPEATLOOP1
SYSREPEATLOOP1:
;Set C Off
	BCF	STATUS,0
;Rotate SSD1306_BufferLocationCalc Right
	RRF	SSD1306_BUFFERLOCATIONCALC_H,F
	RRF	SSD1306_BUFFERLOCATIONCALC,F
;End Repeat
	DECFSZ	SYSREPEATTEMP1,F
	GOTO	SYSREPEATLOOP1
GLOBAL	SYSREPEATLOOPEND1
SYSREPEATLOOPEND1:
;faster than * 128
;Set C Off
	BCF	STATUS,0
;Repeat 7
	MOVLW	7
	MOVWF	SYSREPEATTEMP1
GLOBAL	SYSREPEATLOOP2
SYSREPEATLOOP2:
;Rotate SSD1306_BufferLocationCalc Left
	RLF	SSD1306_BUFFERLOCATIONCALC,F
	RLF	SSD1306_BUFFERLOCATIONCALC_H,F
;End Repeat
	DECFSZ	SYSREPEATTEMP1,F
	GOTO	SYSREPEATLOOP2
GLOBAL	SYSREPEATLOOPEND2
SYSREPEATLOOPEND2:
;SSD1306_BufferLocationCalc = GLCDX + SSD1306_BufferLocationCalc + 1
	MOVF	SSD1306_BUFFERLOCATIONCALC,W
	BANKSEL	GLCDX
	ADDWF	GLCDX,W
	BANKSEL	SYSTEMP1
	MOVWF	SYSTEMP1
	CLRF	SYSTEMP3
	MOVF	SSD1306_BUFFERLOCATIONCALC_H,W
	ADDWFC	SYSTEMP3,W
	MOVWF	SYSTEMP1_H
	MOVLW	1
	ADDWF	SYSTEMP1,W
	MOVWF	SSD1306_BUFFERLOCATIONCALC
	MOVLW	0
	ADDWFC	SYSTEMP1_H,W
	MOVWF	SSD1306_BUFFERLOCATIONCALC_H
;anything beyond buffer boundary?
;why? X = 127 and Y = 64 (Y is over 63!) will have passed first check....
;if SSD1306_BufferLocationCalc > GLCD_HEIGHT * GLCD_WIDTH Then
	MOVF	SSD1306_BUFFERLOCATIONCALC,W
	MOVWF	SYSWORDTEMPB
	MOVF	SSD1306_BUFFERLOCATIONCALC_H,W
	MOVWF	SYSWORDTEMPB_H
	CLRF	SYSWORDTEMPA
	MOVLW	32
	MOVWF	SYSWORDTEMPA_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHAN16
	BTFSC	SYSBYTETEMPX,0
;exit sub
	RETURN
;end if
;GLCDDataTemp = SSD1306_BufferAlias(SSD1306_BufferLocationCalc)
	MOVLW	LOW(SSD1306_BUFFERALIAS)
	BANKSEL	SSD1306_BUFFERLOCATIONCALC
	ADDWF	SSD1306_BUFFERLOCATIONCALC,W
	MOVWF	FSR0L
	MOVLW	HIGH(SSD1306_BUFFERALIAS)
	ADDWFC	SSD1306_BUFFERLOCATIONCALC_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	BANKSEL	GLCDDATATEMP
	MOVWF	GLCDDATATEMP
;Change data to set/clear pixel
;GLCDBitNo = GLCDY And 7
	MOVLW	7
	ANDWF	GLCDY,W
	MOVWF	GLCDBITNO
;If GLCDColour.0 = 0 Then
	BTFSC	GLCDCOLOUR,0
	GOTO	ELSE34_1
;GLCDChange = 254
	MOVLW	254
	MOVWF	GLCDCHANGE
;Set C On
	BSF	STATUS,0
;Else
	GOTO	ENDIF34
GLOBAL	ELSE34_1
ELSE34_1:
;GLCDChange = 1
	MOVLW	1
	MOVWF	GLCDCHANGE
;Set C Off
	BCF	STATUS,0
;End If
GLOBAL	ENDIF34
ENDIF34:
;Repeat GLCDBitNo
	MOVF	GLCDBITNO,W
	BANKSEL	SYSREPEATTEMP1
	MOVWF	SYSREPEATTEMP1
	BTFSC	STATUS,2
	GOTO	SYSREPEATLOOPEND3
GLOBAL	SYSREPEATLOOP3
SYSREPEATLOOP3:
;Rotate GLCDChange Left
	BANKSEL	GLCDCHANGE
	RLF	GLCDCHANGE,F
;End Repeat
	BANKSEL	SYSREPEATTEMP1
	DECFSZ	SYSREPEATTEMP1,F
	GOTO	SYSREPEATLOOP3
GLOBAL	SYSREPEATLOOPEND3
SYSREPEATLOOPEND3:
;If GLCDColour.0 = 0 Then
	BANKSEL	GLCDCOLOUR
	BTFSC	GLCDCOLOUR,0
	GOTO	ELSE35_1
;GLCDDataTemp = GLCDDataTemp And GLCDChange
	MOVF	GLCDDATATEMP,W
	ANDWF	GLCDCHANGE,W
	MOVWF	GLCDDATATEMP
;Else
	GOTO	ENDIF35
GLOBAL	ELSE35_1
ELSE35_1:
;GLCDDataTemp = GLCDDataTemp Or GLCDChange
	MOVF	GLCDDATATEMP,W
	IORWF	GLCDCHANGE,W
	MOVWF	GLCDDATATEMP
;End If
GLOBAL	ENDIF35
ENDIF35:
;added 1.14 to isolate from full glcd mode
;revised 1.14 to isolate from low memory mode
;if SSD1306_BufferAlias(SSD1306_BufferLocationCalc) <> GLCDDataTemp then
	MOVLW	LOW(SSD1306_BUFFERALIAS)
	BANKSEL	SSD1306_BUFFERLOCATIONCALC
	ADDWF	SSD1306_BUFFERLOCATIONCALC,W
	MOVWF	FSR0L
	MOVLW	HIGH(SSD1306_BUFFERALIAS)
	ADDWFC	SSD1306_BUFFERLOCATIONCALC_H,W
	MOVWF	FSR0H
	BANKSEL	GLCDDATATEMP
	MOVF	GLCDDATATEMP,W
	SUBWF	INDF0,W
	BTFSC	STATUS,2
	GOTO	ENDIF36
;SSD1306_BufferAlias(SSD1306_BufferLocationCalc) = GLCDDataTemp
	MOVLW	LOW(SSD1306_BUFFERALIAS)
	BANKSEL	SSD1306_BUFFERLOCATIONCALC
	ADDWF	SSD1306_BUFFERLOCATIONCALC,W
	MOVWF	FSR0L
	MOVLW	HIGH(SSD1306_BUFFERALIAS)
	ADDWFC	SSD1306_BUFFERLOCATIONCALC_H,W
	MOVWF	FSR0H
	BANKSEL	GLCDDATATEMP
	MOVF	GLCDDATATEMP,W
	MOVWF	INDF0
;Cursor_Position_SSD1306 ( GLCDX, GLCDY )
	MOVF	GLCDX,W
	MOVWF	LOCX
	MOVF	GLCDY,W
	MOVWF	LOCY
	FCALL	CURSOR_POSITION_SSD1306
;Write_Data_SSD1306 ( GLCDDataTemp )
	MOVF	GLCDDATATEMP,W
	BANKSEL	SSD1306SENDBYTE
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_DATA_SSD1306
;end if
GLOBAL	ENDIF36
ENDIF36:
	RETURN

;********************************************************************************

;OVERLOADED SIGNATURE: WORD:WORD:WORD:WORD:WORD:INTEGER:, SOURCE: STDBASIC.H (264)
GLOBAL	FN_SCALE531
FN_SCALE531:
;dim l_syscalc as word
;dim l_syscalcF as long
;l_syscalcf =  [long]( l_map - l_fromLow ) * [long](l_toHigh   - l_toLow)
	BANKSEL	L_FROMLOW
	MOVF	L_FROMLOW,W
	SUBWF	L_MAP,W
	MOVWF	SYSTEMP1
	MOVF	L_FROMLOW_H,W
	SUBWFB	L_MAP_H,W
	MOVWF	SYSTEMP1_H
	MOVF	L_TOLOW,W
	SUBWF	L_TOHIGH,W
	MOVWF	SYSTEMP2
	MOVF	L_TOLOW_H,W
	SUBWFB	L_TOHIGH_H,W
	MOVWF	SYSTEMP2_H
	MOVF	SYSTEMP1,W
	MOVWF	SYSLONGTEMPA
	MOVF	SYSTEMP1_H,W
	MOVWF	SYSLONGTEMPA_H
	CLRF	SYSLONGTEMPA_U
	CLRF	SYSLONGTEMPA_E
	MOVF	SYSTEMP2,W
	MOVWF	SYSLONGTEMPB
	MOVF	SYSTEMP2_H,W
	MOVWF	SYSLONGTEMPB_H
	CLRF	SYSLONGTEMPB_U
	CLRF	SYSLONGTEMPB_E
	BANKSEL	STATUS
	FCALL	SYSMULTSUB32
	MOVF	SYSLONGTEMPX,W
	BANKSEL	L_SYSCALCF
	MOVWF	L_SYSCALCF
	MOVF	SYSLONGTEMPX_H,W
	MOVWF	L_SYSCALCF_H
	MOVF	SYSLONGTEMPX_U,W
	MOVWF	L_SYSCALCF_U
	MOVF	SYSLONGTEMPX_E,W
	MOVWF	L_SYSCALCF_E
;l_syscalc = (  l_fromHigh - l_fromLow )
	MOVF	L_FROMLOW,W
	SUBWF	L_FROMHIGH,W
	MOVWF	L_SYSCALC
	MOVF	L_FROMLOW_H,W
	SUBWFB	L_FROMHIGH_H,W
	MOVWF	L_SYSCALC_H
;scale = (l_syscalcf / l_syscalc) + l_toLow + l_calibrate
	MOVF	L_SYSCALCF,W
	MOVWF	SYSLONGTEMPA
	MOVF	L_SYSCALCF_H,W
	MOVWF	SYSLONGTEMPA_H
	MOVF	L_SYSCALCF_U,W
	MOVWF	SYSLONGTEMPA_U
	MOVF	L_SYSCALCF_E,W
	MOVWF	SYSLONGTEMPA_E
	MOVF	L_SYSCALC,W
	MOVWF	SYSLONGTEMPB
	MOVF	L_SYSCALC_H,W
	MOVWF	SYSLONGTEMPB_H
	CLRF	SYSLONGTEMPB_U
	CLRF	SYSLONGTEMPB_E
	BANKSEL	STATUS
	FCALL	SYSDIVSUB32
	MOVF	SYSLONGTEMPA,W
	BANKSEL	SYSTEMP1
	MOVWF	SYSTEMP1
	MOVF	SYSLONGTEMPA_H,W
	MOVWF	SYSTEMP1_H
	MOVF	SYSLONGTEMPA_U,W
	MOVWF	SYSTEMP1_U
	MOVF	SYSLONGTEMPA_E,W
	MOVWF	SYSTEMP1_E
	MOVF	L_TOLOW,W
	ADDWF	SYSTEMP1,W
	MOVWF	SYSTEMP2
	MOVF	L_TOLOW_H,W
	ADDWFC	SYSTEMP1_H,W
	MOVWF	SYSTEMP2_H
	MOVF	L_CALIBRATE,W
	ADDWF	SYSTEMP2,W
	MOVWF	SCALE
	MOVF	L_CALIBRATE_H,W
	ADDWFC	SYSTEMP2_H,W
	MOVWF	SCALE_H
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: TRIG2PLACES.H (49)
GLOBAL	FN_SIN
FN_SIN:
;return sine of angle
;if trig_arg2 < 0 then               ;sine is an odd function,
	BANKSEL	TRIG_ARG2
	MOVF	TRIG_ARG2,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	TRIG_ARG2_H,W
	MOVWF	SYSINTEGERTEMPA_H
	CLRF	SYSINTEGERTEMPB
	CLRF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHANINT
	BTFSS	SYSBYTETEMPX,0
	GOTO	ELSE10_1
;trig_sign = -1                    ;so change sign of result
	MOVLW	255
	BANKSEL	TRIG_SIGN
	MOVWF	TRIG_SIGN
	MOVWF	TRIG_SIGN_H
;trig_arg2 = -1 * trig_arg2        ;and negate negative angle
	MOVF	TRIG_ARG2,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	TRIG_ARG2_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	255
	MOVWF	SYSINTEGERTEMPB
	MOVWF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	BANKSEL	TRIG_ARG2
	MOVWF	TRIG_ARG2
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	TRIG_ARG2_H
;else
	GOTO	ENDIF10
GLOBAL	ELSE10_1
ELSE10_1:
;trig_sign = 1                     ;else a positive angle
	MOVLW	1
	BANKSEL	TRIG_SIGN
	MOVWF	TRIG_SIGN
	CLRF	TRIG_SIGN_H
;end if
GLOBAL	ENDIF10
ENDIF10:
;trig_arg2 = trig_arg2 mod 360       ;reduce to 0 to 359 degrees
	MOVF	TRIG_ARG2,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	TRIG_ARG2_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	104
	MOVWF	SYSINTEGERTEMPB
	MOVLW	1
	MOVWF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSDIVSUBINT
	MOVF	SYSINTEGERTEMPX,W
	BANKSEL	TRIG_ARG2
	MOVWF	TRIG_ARG2
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	TRIG_ARG2_H
;if trig_arg2 > 180 then
	MOVF	TRIG_ARG2,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	TRIG_ARG2_H,W
	MOVWF	SYSINTEGERTEMPB_H
	MOVLW	180
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHANINT
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF11
;trig_sign = -1 * trig_sign        ;negative in III and IV
	BANKSEL	TRIG_SIGN
	MOVF	TRIG_SIGN,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	TRIG_SIGN_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVLW	255
	MOVWF	SYSINTEGERTEMPB
	MOVWF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	BANKSEL	TRIG_SIGN
	MOVWF	TRIG_SIGN
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	TRIG_SIGN_H
;end if
GLOBAL	ENDIF11
ENDIF11:
;trig_arg2 = trig_ref(trig_arg2)     ;get the reference angle
	BANKSEL	TRIG_ARG2
	MOVF	TRIG_ARG2,W
	MOVWF	TRIG_ARG1
	MOVF	TRIG_ARG2_H,W
	MOVWF	TRIG_ARG1_H
	BANKSEL	STATUS
	CALL	FN_TRIG_REF
	BANKSEL	TRIG_REF
	MOVF	TRIG_REF,W
	MOVWF	TRIG_ARG2
	MOVF	TRIG_REF_H,W
	MOVWF	TRIG_ARG2_H
;trig_i = [byte]trig_arg2+1          ;index into the table
	INCF	TRIG_ARG2,W
	BANKSEL	TRIG_I
	MOVWF	TRIG_I
;readTable sineTab, trig_i, trig_val
	MOVWF	SYSSTRINGA
	BANKSEL	STATUS
	CALL	SINETAB
	BANKSEL	TRIG_VAL
	MOVWF	TRIG_VAL
	CLRF	TRIG_VAL_H
;sin = trig_sign * [integer]trig_val ;create final result
	MOVF	TRIG_SIGN,W
	MOVWF	SYSINTEGERTEMPA
	MOVF	TRIG_SIGN_H,W
	MOVWF	SYSINTEGERTEMPA_H
	MOVF	TRIG_VAL,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	TRIG_VAL_H,W
	MOVWF	SYSINTEGERTEMPB_H
	BANKSEL	STATUS
	FCALL	SYSMULTSUBINT
	MOVF	SYSINTEGERTEMPX,W
	BANKSEL	SIN
	MOVWF	SIN
	MOVF	SYSINTEGERTEMPX_H,W
	MOVWF	SIN_H
	BANKSEL	STATUS
	RETURN

;********************************************************************************

GLOBAL	SINETAB
SINETAB:
	MOVLW	92
	SUBWF	SYSSTRINGA, W
	BTFSC	STATUS,0
	RETLW	0
	MOVF	SYSSTRINGA, W
	ADDLW	LOW TABLESINETAB
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH TABLESINETAB) & 127
	BTFSC	STATUS,0
	ADDLW	1
	MOVWF	PCLATH
	MOVF	SYSSTRINGA, W
	MOVWF	PCL
GLOBAL	TABLESINETAB
TABLESINETAB:
	RETLW	91
	RETLW	0
	RETLW	2
	RETLW	3
	RETLW	5
	RETLW	7
	RETLW	9
	RETLW	10
	RETLW	12
	RETLW	14
	RETLW	16
	RETLW	17
	RETLW	19
	RETLW	21
	RETLW	22
	RETLW	24
	RETLW	26
	RETLW	28
	RETLW	29
	RETLW	31
	RETLW	33
	RETLW	34
	RETLW	36
	RETLW	37
	RETLW	39
	RETLW	41
	RETLW	42
	RETLW	44
	RETLW	45
	RETLW	47
	RETLW	48
	RETLW	50
	RETLW	52
	RETLW	53
	RETLW	54
	RETLW	56
	RETLW	57
	RETLW	59
	RETLW	60
	RETLW	62
	RETLW	63
	RETLW	64
	RETLW	66
	RETLW	67
	RETLW	68
	RETLW	69
	RETLW	71
	RETLW	72
	RETLW	73
	RETLW	74
	RETLW	75
	RETLW	77
	RETLW	78
	RETLW	79
	RETLW	80
	RETLW	81
	RETLW	82
	RETLW	83
	RETLW	84
	RETLW	85
	RETLW	86
	RETLW	87
	RETLW	87
	RETLW	88
	RETLW	89
	RETLW	90
	RETLW	91
	RETLW	91
	RETLW	92
	RETLW	93
	RETLW	93
	RETLW	94
	RETLW	95
	RETLW	95
	RETLW	96
	RETLW	96
	RETLW	97
	RETLW	97
	RETLW	97
	RETLW	98
	RETLW	98
	RETLW	98
	RETLW	99
	RETLW	99
	RETLW	99
	RETLW	99
	RETLW	100
	RETLW	100
	RETLW	100
	RETLW	100
	RETLW	100
	RETLW	100

;********************************************************************************

;SOURCE: SYSTEM.H (2937)
GLOBAL	SYSDIVSUB32
SYSDIVSUB32:
;dim SysLongTempA as long
;dim SysLongTempB as long
;dim SysLongTempX as long
;#ifdef PIC
;dim SysLongDivMultA as long
;dim SysLongDivMultB as long
;dim SysLongDivMultX as long
;#endif
;SysLongDivMultA = SysLongTempA
	MOVF	SYSLONGTEMPA,W
	BANKSEL	SYSLONGDIVMULTA
	MOVWF	SYSLONGDIVMULTA
	MOVF	SYSLONGTEMPA_H,W
	MOVWF	SYSLONGDIVMULTA_H
	MOVF	SYSLONGTEMPA_U,W
	MOVWF	SYSLONGDIVMULTA_U
	MOVF	SYSLONGTEMPA_E,W
	MOVWF	SYSLONGDIVMULTA_E
;SysLongDivMultB = SysLongTempB
	MOVF	SYSLONGTEMPB,W
	MOVWF	SYSLONGDIVMULTB
	MOVF	SYSLONGTEMPB_H,W
	MOVWF	SYSLONGDIVMULTB_H
	MOVF	SYSLONGTEMPB_U,W
	MOVWF	SYSLONGDIVMULTB_U
	MOVF	SYSLONGTEMPB_E,W
	MOVWF	SYSLONGDIVMULTB_E
;SysLongDivMultX = 0
	CLRF	SYSLONGDIVMULTX
	CLRF	SYSLONGDIVMULTX_H
	CLRF	SYSLONGDIVMULTX_U
	CLRF	SYSLONGDIVMULTX_E
;Avoid division by zero
;if SysLongDivMultB = 0 then
	MOVF	SYSLONGDIVMULTB,W
	MOVWF	SYSLONGTEMPA
	MOVF	SYSLONGDIVMULTB_H,W
	MOVWF	SYSLONGTEMPA_H
	MOVF	SYSLONGDIVMULTB_U,W
	MOVWF	SYSLONGTEMPA_U
	MOVF	SYSLONGDIVMULTB_E,W
	MOVWF	SYSLONGTEMPA_E
	CLRF	SYSLONGTEMPB
	CLRF	SYSLONGTEMPB_H
	CLRF	SYSLONGTEMPB_U
	CLRF	SYSLONGTEMPB_E
	BANKSEL	STATUS
	FCALL	SYSCOMPEQUAL32
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF55
;SysLongTempA = 0
	CLRF	SYSLONGTEMPA
	CLRF	SYSLONGTEMPA_H
	CLRF	SYSLONGTEMPA_U
	CLRF	SYSLONGTEMPA_E
;exit sub
	RETURN
;end if
GLOBAL	ENDIF55
ENDIF55:
;Main calc routine
;SysDivLoop = 32
	MOVLW	32
	MOVWF	SYSDIVLOOP
GLOBAL	SYSDIV32START
SYSDIV32START:
;set C off
	BCF	STATUS,0
;Rotate SysLongDivMultA Left
	BANKSEL	SYSLONGDIVMULTA
	RLF	SYSLONGDIVMULTA,F
	RLF	SYSLONGDIVMULTA_H,F
	RLF	SYSLONGDIVMULTA_U,F
	RLF	SYSLONGDIVMULTA_E,F
;Rotate SysLongDivMultX Left
	RLF	SYSLONGDIVMULTX,F
	RLF	SYSLONGDIVMULTX_H,F
	RLF	SYSLONGDIVMULTX_U,F
	RLF	SYSLONGDIVMULTX_E,F
;SysLongDivMultX = SysLongDivMultX - SysLongDivMultB
	MOVF	SYSLONGDIVMULTB,W
	SUBWF	SYSLONGDIVMULTX,F
	MOVF	SYSLONGDIVMULTB_H,W
	SUBWFB	SYSLONGDIVMULTX_H,F
	MOVF	SYSLONGDIVMULTB_U,W
	SUBWFB	SYSLONGDIVMULTX_U,F
	MOVF	SYSLONGDIVMULTB_E,W
	SUBWFB	SYSLONGDIVMULTX_E,F
;Set SysLongDivMultA.0 On
	BSF	SYSLONGDIVMULTA,0
;If C Off Then
	BTFSC	STATUS,0
	GOTO	ENDIF56
;Set SysLongDivMultA.0 Off
	BCF	SYSLONGDIVMULTA,0
;SysLongDivMultX = SysLongDivMultX + SysLongDivMultB
	MOVF	SYSLONGDIVMULTB,W
	ADDWF	SYSLONGDIVMULTX,F
	MOVF	SYSLONGDIVMULTB_H,W
	ADDWFC	SYSLONGDIVMULTX_H,F
	MOVF	SYSLONGDIVMULTB_U,W
	ADDWFC	SYSLONGDIVMULTX_U,F
	MOVF	SYSLONGDIVMULTB_E,W
	ADDWFC	SYSLONGDIVMULTX_E,F
;End If
GLOBAL	ENDIF56
ENDIF56:
;decfsz SysDivLoop, F
	DECFSZ	SYSDIVLOOP, F
;goto SysDiv32Start
	GOTO	SYSDIV32START
;SysLongTempA = SysLongDivMultA
	MOVF	SYSLONGDIVMULTA,W
	MOVWF	SYSLONGTEMPA
	MOVF	SYSLONGDIVMULTA_H,W
	MOVWF	SYSLONGTEMPA_H
	MOVF	SYSLONGDIVMULTA_U,W
	MOVWF	SYSLONGTEMPA_U
	MOVF	SYSLONGDIVMULTA_E,W
	MOVWF	SYSLONGTEMPA_E
;SysLongTempX = SysLongDivMultX
	MOVF	SYSLONGDIVMULTX,W
	MOVWF	SYSLONGTEMPX
	MOVF	SYSLONGDIVMULTX_H,W
	MOVWF	SYSLONGTEMPX_H
	MOVF	SYSLONGDIVMULTX_U,W
	MOVWF	SYSLONGTEMPX_U
	MOVF	SYSLONGDIVMULTX_E,W
	MOVWF	SYSLONGTEMPX_E
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: TRIG2PLACES.H (29)
GLOBAL	FN_TRIG_REF
FN_TRIG_REF:
;create reference angle (0 to 90) for the argument
;if (trig_arg1 > 270) then           ;Quadrant IV
	BANKSEL	TRIG_ARG1
	MOVF	TRIG_ARG1,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	TRIG_ARG1_H,W
	MOVWF	SYSINTEGERTEMPB_H
	MOVLW	14
	MOVWF	SYSINTEGERTEMPA
	MOVLW	1
	MOVWF	SYSINTEGERTEMPA_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHANINT
	BTFSS	SYSBYTETEMPX,0
	GOTO	ELSE82_1
;trig_ref = 360 - trig_arg1
	BANKSEL	TRIG_ARG1
	MOVF	TRIG_ARG1,W
	SUBLW	104
	MOVWF	TRIG_REF
	MOVLW	1
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	BANKSEL	TRIG_ARG1_H
	MOVF	TRIG_ARG1_H,W
	BANKSEL	SYSTEMP3
	SUBWFB	SYSTEMP3,W
	BANKSEL	TRIG_REF_H
	MOVWF	TRIG_REF_H
;else
	GOTO	ENDIF82
GLOBAL	ELSE82_1
ELSE82_1:
;if (trig_arg1 > 180) then         ;Quadrant III
	BANKSEL	TRIG_ARG1
	MOVF	TRIG_ARG1,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	TRIG_ARG1_H,W
	MOVWF	SYSINTEGERTEMPB_H
	MOVLW	180
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHANINT
	BTFSS	SYSBYTETEMPX,0
	GOTO	ELSE83_1
;trig_ref = trig_arg1 - 180
	MOVLW	180
	BANKSEL	TRIG_ARG1
	SUBWF	TRIG_ARG1,W
	MOVWF	TRIG_REF
	MOVLW	0
	SUBWFB	TRIG_ARG1_H,W
	MOVWF	TRIG_REF_H
;else                              ;Quadrant II
	GOTO	ENDIF83
GLOBAL	ELSE83_1
ELSE83_1:
;if (trig_arg1 > 90) then
	BANKSEL	TRIG_ARG1
	MOVF	TRIG_ARG1,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	TRIG_ARG1_H,W
	MOVWF	SYSINTEGERTEMPB_H
	MOVLW	90
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHANINT
	BTFSS	SYSBYTETEMPX,0
	GOTO	ELSE84_1
;trig_ref = 180 - trig_arg1
	BANKSEL	TRIG_ARG1
	MOVF	TRIG_ARG1,W
	SUBLW	180
	MOVWF	TRIG_REF
	MOVLW	0
	BANKSEL	SYSTEMP3
	MOVWF	SYSTEMP3
	BANKSEL	TRIG_ARG1_H
	MOVF	TRIG_ARG1_H,W
	BANKSEL	SYSTEMP3
	SUBWFB	SYSTEMP3,W
	BANKSEL	TRIG_REF_H
	MOVWF	TRIG_REF_H
;else
	GOTO	ENDIF84
GLOBAL	ELSE84_1
ELSE84_1:
;trig_ref = trig_arg1          ;Quadrant I by default
	BANKSEL	TRIG_ARG1
	MOVF	TRIG_ARG1,W
	MOVWF	TRIG_REF
	MOVF	TRIG_ARG1_H,W
	MOVWF	TRIG_REF_H
;end if
GLOBAL	ENDIF84
ENDIF84:
;end if
GLOBAL	ENDIF83
ENDIF83:
;end if
GLOBAL	ENDIF82
ENDIF82:
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;START OF PROGRAM MEMORY PAGE 2
	PSECT	PROGMEM2,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	4096
;SOURCE: 230_I2C_GLCD_VOLTMETER_USING_SSD1306.GCB (184)
GLOBAL	ANGLECHECK
ANGLECHECK:
;If angle>127 Then
	MOVF	ANGLE,W
	MOVWF	SYSWORDTEMPB
	MOVF	ANGLE_H,W
	MOVWF	SYSWORDTEMPB_H
	MOVLW	127
	MOVWF	SYSWORDTEMPA
	CLRF	SYSWORDTEMPA_H
	CALL	SYSCOMPLESSTHAN16
	BTFSS	SYSBYTETEMPX,0
	GOTO	ELSE9_1
;angle =angle-127
	MOVLW	127
	SUBWF	ANGLE,F
	MOVLW	0
	SUBWFB	ANGLE_H,F
;Else
	GOTO	ENDIF9
GLOBAL	ELSE9_1
ELSE9_1:
;angle =296+angle
	MOVLW	40
	ADDWF	ANGLE,F
	MOVLW	1
	ADDWFC	ANGLE_H,F
;End If
GLOBAL	ENDIF9
ENDIF9:
	RETURN

;********************************************************************************

;SOURCE: GLCD_SSD1306.H (1040)
GLOBAL	CURSOR_POSITION_SSD1306
CURSOR_POSITION_SSD1306:
;dim  PosCharX, PosCharX as Word
;PosCharY = LocY / 8
;faster than /8
;PosCharY = LocY
	MOVF	LOCY,W
	BANKSEL	POSCHARY
	MOVWF	POSCHARY
;Repeat 3
	MOVLW	3
	MOVWF	SYSREPEATTEMP4
GLOBAL	SYSREPEATLOOP4
SYSREPEATLOOP4:
;Set C Off
	BCF	STATUS,0
;Rotate PosCharY Right
	RRF	POSCHARY,F
;End Repeat
	DECFSZ	SYSREPEATTEMP4,F
	GOTO	SYSREPEATLOOP4
GLOBAL	SYSREPEATLOOPEND4
SYSREPEATLOOPEND4:
;Write_Command_SSD1306( 0xB0 + PosCharY )   ' set page address
	MOVLW	176
	ADDWF	POSCHARY,W
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;PosCharX = ( LocX  & 0x0f )  ' lower nibble
	MOVLW	15
	ANDWF	LOCX,W
	BANKSEL	POSCHARX
	MOVWF	POSCHARX
	CLRF	POSCHARX_H
;Write_Command_SSD1306( PosCharX )
	MOVF	POSCHARX,W
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	FCALL	WRITE_COMMAND_SSD1306
;PosCharX = LocX
	MOVF	LOCX,W
	BANKSEL	POSCHARX
	MOVWF	POSCHARX
	CLRF	POSCHARX_H
;Repeat 4
	MOVLW	4
	MOVWF	SYSREPEATTEMP4
GLOBAL	SYSREPEATLOOP5
SYSREPEATLOOP5:
;Set C off
	BCF	STATUS,0
;Rotate PosCharX Right
	RRF	POSCHARX_H,F
	RRF	POSCHARX,F
;End Repeat
	DECFSZ	SYSREPEATTEMP4,F
	GOTO	SYSREPEATLOOP5
GLOBAL	SYSREPEATLOOPEND5
SYSREPEATLOOPEND5:
;PosCharX = ( PosCharX & 0x0F ) + 0x10
	MOVLW	15
	ANDWF	POSCHARX,W
	MOVWF	SYSTEMP1
	CLRF	SYSTEMP1_H
	MOVLW	16
	ADDWF	SYSTEMP1,W
	MOVWF	POSCHARX
	MOVLW	0
	ADDWFC	SYSTEMP1_H,W
	MOVWF	POSCHARX_H
;Write_Command_SSD1306 ( PosCharX )
	MOVF	POSCHARX,W
	MOVWF	SSD1306SENDBYTE
	BANKSEL	STATUS
	LJMP	WRITE_COMMAND_SSD1306

;********************************************************************************

;SOURCE: 230_I2C_GLCD_VOLTMETER_USING_SSD1306.GCB (174)
GLOBAL	DIAL
DIAL:
;For angle= 296 To 359
;LEGACY METHOD
	MOVLW	39
	MOVWF	ANGLE
	MOVLW	1
	MOVWF	ANGLE_H
GLOBAL	SYSFORLOOP2
SYSFORLOOP2:
	INCF	ANGLE,F
	BTFSC	STATUS,2
	INCF	ANGLE_H,F
;plotdial
	FCALL	PLOTDIAL
;Next angle
	MOVF	ANGLE,W
	MOVWF	SYSWORDTEMPA
	MOVF	ANGLE_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	103
	MOVWF	SYSWORDTEMPB
	MOVLW	1
	MOVWF	SYSWORDTEMPB_H
	FCALL	SYSCOMPLESSTHAN16
	BTFSC	SYSBYTETEMPX,0
	GOTO	SYSFORLOOP2
GLOBAL	SYSFORLOOPEND2
SYSFORLOOPEND2:
;
;For angle= 0 To 63
;LEGACY METHOD
	MOVLW	255
	MOVWF	ANGLE
	MOVWF	ANGLE_H
GLOBAL	SYSFORLOOP3
SYSFORLOOP3:
	INCF	ANGLE,F
	BTFSC	STATUS,2
	INCF	ANGLE_H,F
;plotdial
	FCALL	PLOTDIAL
;Next angle
	MOVF	ANGLE,W
	MOVWF	SYSWORDTEMPA
	MOVF	ANGLE_H,W
	MOVWF	SYSWORDTEMPA_H
	MOVLW	63
	MOVWF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	FCALL	SYSCOMPLESSTHAN16
	BTFSC	SYSBYTETEMPX,0
	GOTO	SYSFORLOOP3
GLOBAL	SYSFORLOOPEND3
SYSFORLOOPEND3:
	RETURN

;********************************************************************************

GLOBAL	DELAY_10US
DELAY_10US:
GLOBAL	D10US_START
D10US_START:
	MOVLW	25
	MOVWF	DELAYTEMP
GLOBAL	DELAYUS0
DELAYUS0:
	DECFSZ	DELAYTEMP,F
	GOTO	DELAYUS0
	NOP
	DECFSZ	SYSWAITTEMP10US, F
	GOTO	D10US_START
	RETURN

;********************************************************************************

GLOBAL	DELAY_MS
DELAY_MS:
	INCF	SYSWAITTEMPMS_H, F
GLOBAL	DMS_START
DMS_START:
	MOVLW	14
	MOVWF	DELAYTEMP2
GLOBAL	DMS_OUTER
DMS_OUTER:
	MOVLW	189
	MOVWF	DELAYTEMP
GLOBAL	DMS_INNER
DMS_INNER:
	DECFSZ	DELAYTEMP, F
	GOTO	DMS_INNER
	DECFSZ	DELAYTEMP2, F
	GOTO	DMS_OUTER
	DECFSZ	SYSWAITTEMPMS, F
	GOTO	DMS_START
	DECFSZ	SYSWAITTEMPMS_H, F
	GOTO	DMS_START
	RETURN

;********************************************************************************

;SOURCE: HWI2C.H (257)
GLOBAL	HI2CMODE
HI2CMODE:
;asm showdebug  This method sets the variable `HI2CCurrentMode`, and, if required, sets the SSPCON1.bits
;#ifdef var(SSPCON1) added to separate from newer i2C module which does not have an SSPCON1
;set SSPSTAT.SMP on
	BANKSEL	SSP1STAT
	BSF	SSP1STAT,7
;set SSPCON1.CKP on
	BSF	SSP1CON1,4
;set SSPCON1.WCOL Off
	BCF	SSP1CON1,7
;Select mode and clock
;If HI2CCurrentMode = Master Then
	MOVLW	12
	BANKSEL	HI2CCURRENTMODE
	SUBWF	HI2CCURRENTMODE,W
	BTFSS	STATUS,2
	GOTO	ENDIF88
;set SSPCON1.SSPM3 on
	BANKSEL	SSP1CON1
	BSF	SSP1CON1,3
;set SSPCON1.SSPM2 off
	BCF	SSP1CON1,2
;set SSPCON1.SSPM1 off
	BCF	SSP1CON1,1
;set SSPCON1.SSPM0 off
	BCF	SSP1CON1,0
;SSPADD = HI2C_BAUD_TEMP and 127
	MOVLW	19
	MOVWF	SSP1ADD
;end if
GLOBAL	ENDIF88
ENDIF88:
;if HI2CCurrentMode = Slave then
	BANKSEL	HI2CCURRENTMODE
	MOVF	HI2CCURRENTMODE,F
	BTFSS	STATUS,2
	GOTO	ENDIF89
;set SSPCON1.SSPM3 off
	BANKSEL	SSP1CON1
	BCF	SSP1CON1,3
;set SSPCON1.SSPM2 on
	BSF	SSP1CON1,2
;set SSPCON1.SSPM1 on
	BSF	SSP1CON1,1
;set SSPCON1.SSPM0 off
	BCF	SSP1CON1,0
;end if
GLOBAL	ENDIF89
ENDIF89:
;if HI2CCurrentMode = Slave10 then
	MOVLW	3
	BANKSEL	HI2CCURRENTMODE
	SUBWF	HI2CCURRENTMODE,W
	BTFSS	STATUS,2
	GOTO	ENDIF90
;set SSPCON1.SSPM3 off
	BANKSEL	SSP1CON1
	BCF	SSP1CON1,3
;set SSPCON1.SSPM2 on
	BSF	SSP1CON1,2
;set SSPCON1.SSPM1 on
	BSF	SSP1CON1,1
;set SSPCON1.SSPM0 on
	BSF	SSP1CON1,0
;end if
GLOBAL	ENDIF90
ENDIF90:
;Enable I2C
;set SSPCON1.SSPEN on
	BANKSEL	SSP1CON1
	BSF	SSP1CON1,5
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: HWI2C.H (428)
GLOBAL	HI2CSEND
HI2CSEND:
;asm showdebug  This method sets the registers and register bits to send I2C data
GLOBAL	RETRYHI2CSEND
RETRYHI2CSEND:
;Clear WCOL
;SET SSPCON1.WCOL OFF
	BANKSEL	SSP1CON1
	BCF	SSP1CON1,7
;Load data to send
;SSPBUF = I2CByte
	BANKSEL	I2CBYTE
	MOVF	I2CBYTE,W
	BANKSEL	SSP1BUF
	MOVWF	SSP1BUF
;HI2CWaitMSSP
	BANKSEL	STATUS
	CALL	HI2CWAITMSSP
;if ACKSTAT =  1 then
	BANKSEL	SSP1CON2
	BTFSS	SSP1CON2,6
	GOTO	ELSE76_1
;HI2CAckPollState = true
	MOVLW	255
	BANKSEL	HI2CACKPOLLSTATE
	MOVWF	HI2CACKPOLLSTATE
;else
	GOTO	ENDIF76
GLOBAL	ELSE76_1
ELSE76_1:
;HI2CAckPollState = false
	BANKSEL	HI2CACKPOLLSTATE
	CLRF	HI2CACKPOLLSTATE
;end if
GLOBAL	ENDIF76
ENDIF76:
;If SSPCON1.WCOL = On Then
	BANKSEL	SSP1CON1
	BTFSS	SSP1CON1,7
	GOTO	ENDIF77
;If HI2CCurrentMode <= 10 Then Goto RetryHI2CSend
	BANKSEL	HI2CCURRENTMODE
	MOVF	HI2CCURRENTMODE,W
	SUBLW	10
	BTFSC	STATUS,0
;If HI2CCurrentMode <= 10 Then Goto RetryHI2CSend
	GOTO	RETRYHI2CSEND
;If HI2CCurrentMode <= 10 Then Goto RetryHI2CSend
;End If
GLOBAL	ENDIF77
ENDIF77:
;Release clock (only needed by slave)
;If HI2CCurrentMode <= 10 Then Set SSPCON1.CKP On
	BANKSEL	HI2CCURRENTMODE
	MOVF	HI2CCURRENTMODE,W
	SUBLW	10
	BTFSS	STATUS,0
	GOTO	ENDIF78
;If HI2CCurrentMode <= 10 Then Set SSPCON1.CKP On
	BANKSEL	SSP1CON1
	BSF	SSP1CON1,4
;If HI2CCurrentMode <= 10 Then Set SSPCON1.CKP On
GLOBAL	ENDIF78
ENDIF78:
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: HWI2C.H (312)
GLOBAL	HI2CSTART
HI2CSTART:
;asm showdebug  This method sets the registers and register bits to generate the I2C  START signal
;If HI2CCurrentMode > 10 Then
	MOVF	HI2CCURRENTMODE,W
	SUBLW	10
	BTFSC	STATUS,0
	GOTO	ELSE74_1
;Master_mode operational
;Set SEN On
	BANKSEL	SSP1CON2
	BSF	SSP1CON2,0
;HI2CWaitMSSP
	BANKSEL	STATUS
	CALL	HI2CWAITMSSP
;Else
	GOTO	ENDIF74
GLOBAL	ELSE74_1
ELSE74_1:
;Slave mode operational
;Wait Until SSPSTAT.S = On
GLOBAL	SYSWAITLOOP2
SYSWAITLOOP2:
	BANKSEL	SSP1STAT
	BTFSS	SSP1STAT,3
	GOTO	SYSWAITLOOP2
;End If
GLOBAL	ENDIF74
ENDIF74:
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: HWI2C.H (362)
GLOBAL	HI2CSTOP
HI2CSTOP:
;Master_mode
;If HI2CCurrentMode > 10 Then
	MOVF	HI2CCURRENTMODE,W
	SUBLW	10
	BTFSC	STATUS,0
	GOTO	ELSE75_1
;set SSPIE OFF; disable SSP interrupt, tested by Anobium but not implemented.
;wait while R_NOT_W = 1   'wait for completion of activities
GLOBAL	SYSWAITLOOP3
SYSWAITLOOP3:
	BANKSEL	SSP1STAT
	BTFSC	SSP1STAT,2
	GOTO	SYSWAITLOOP3
;Set SSPCON2.PEN On
	BSF	SSP1CON2,2
;Set SSPCON2.PEN On
	BSF	SSP1CON2,2
;HI2CWaitMSSP
	BANKSEL	STATUS
	CALL	HI2CWAITMSSP
;Slave mode
;Else
	GOTO	ENDIF75
GLOBAL	ELSE75_1
ELSE75_1:
;Wait Until SSPSTAT.P = On
GLOBAL	SYSWAITLOOP4
SYSWAITLOOP4:
	BANKSEL	SSP1STAT
	BTFSS	SSP1STAT,4
	GOTO	SYSWAITLOOP4
;End If
GLOBAL	ENDIF75
ENDIF75:
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: HWI2C.H (515)
GLOBAL	HI2CWAITMSSP
HI2CWAITMSSP:
;HI2CWaitMSSPTimeout = 0
	CLRF	HI2CWAITMSSPTIMEOUT
GLOBAL	HI2CWAITMSSPWAIT
HI2CWAITMSSPWAIT:
;HI2CWaitMSSPTimeout++
	BANKSEL	HI2CWAITMSSPTIMEOUT
	INCF	HI2CWAITMSSPTIMEOUT,F
;if HI2CWaitMSSPTimeout < 255 then
	MOVLW	255
	SUBWF	HI2CWAITMSSPTIMEOUT,W
	BTFSC	STATUS,0
	GOTO	ENDIF80
;'Support for SSP1IF
;if SSP1IF = 0 then goto HI2CWaitMSSPWait
	BANKSEL	PIR5
	BTFSS	PIR5,2
;if SSP1IF = 0 then goto HI2CWaitMSSPWait
	GOTO	HI2CWAITMSSPWAIT
;if SSP1IF = 0 then goto HI2CWaitMSSPWait
;SSP1IF = 0
	BCF	PIR5,2
;end if
GLOBAL	ENDIF80
ENDIF80:
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3078)
GLOBAL	SYSCOMPEQUAL
SYSCOMPEQUAL:
;Dim SysByteTempA, SysByteTempB, SysByteTempX as byte
;clrf SysByteTempX
	CLRF	SYSBYTETEMPX
;movf SysByteTempA, W
	MOVF	SYSBYTETEMPA, W
;subwf SysByteTempB, W
	SUBWF	SYSBYTETEMPB, W
;btfsc STATUS, Z
	BTFSC	STATUS,2
;comf SysByteTempX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3104)
GLOBAL	SYSCOMPEQUAL16
SYSCOMPEQUAL16:
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysByteTempX as byte
;clrf SysByteTempX
	CLRF	SYSBYTETEMPX
;Test low, exit if false
;movf SysWordTempA, W
	MOVF	SYSWORDTEMPA, W
;subwf SysWordTempB, W
	SUBWF	SYSWORDTEMPB, W
;btfss STATUS, Z
	BTFSS	STATUS,2
;return
	RETURN
;Test high, exit if false
;movf SysWordTempA_H, W
	MOVF	SYSWORDTEMPA_H, W
;subwf SysWordTempB_H, W
	SUBWF	SYSWORDTEMPB_H, W
;btfss STATUS, Z
	BTFSS	STATUS,2
;return
	RETURN
;comf SysByteTempX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3158)
GLOBAL	SYSCOMPEQUAL32
SYSCOMPEQUAL32:
;dim SysLongTempA as long
;dim SysLongTempB as long
;dim SysByteTempX as byte
;clrf SysByteTempX
	CLRF	SYSBYTETEMPX
;Test low, exit if false
;movf SysLongTempA, W
	MOVF	SYSLONGTEMPA, W
;subwf SysLongTempB, W
	SUBWF	SYSLONGTEMPB, W
;btfss STATUS, Z
	BTFSS	STATUS,2
;return
	RETURN
;Test high, exit if false
;movf SysLongTempA_H, W
	MOVF	SYSLONGTEMPA_H, W
;subwf SysLongTempB_H, W
	SUBWF	SYSLONGTEMPB_H, W
;btfss STATUS, Z
	BTFSS	STATUS,2
;return
	RETURN
;Test upper, exit if false
;movf SysLongTempA_U, W
	MOVF	SYSLONGTEMPA_U, W
;subwf SysLongTempB_U, W
	SUBWF	SYSLONGTEMPB_U, W
;btfss STATUS, Z
	BTFSS	STATUS,2
;return
	RETURN
;Test exp, exit if false
;movf SysLongTempA_E, W
	MOVF	SYSLONGTEMPA_E, W
;subwf SysLongTempB_E, W
	SUBWF	SYSLONGTEMPB_E, W
;btfss STATUS, Z
	BTFSS	STATUS,2
;return
	RETURN
;comf SysByteTempX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3383)
GLOBAL	SYSCOMPLESSTHAN
SYSCOMPLESSTHAN:
;Dim SysByteTempA, SysByteTempB, SysByteTempX as byte
;clrf SysByteTempX
	CLRF	SYSBYTETEMPX
;bsf STATUS, C
	BSF	STATUS,0
;movf SysByteTempB, W
	MOVF	SYSBYTETEMPB, W
;subwf SysByteTempA, W
	SUBWF	SYSBYTETEMPA, W
;btfss STATUS, C
	BTFSS	STATUS,0
;comf SysByteTempX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3413)
GLOBAL	SYSCOMPLESSTHAN16
SYSCOMPLESSTHAN16:
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysByteTempX as byte
;clrf SysByteTempX
	CLRF	SYSBYTETEMPX
;Test High, exit if more
;movf SysWordTempA_H,W
	MOVF	SYSWORDTEMPA_H,W
;subwf SysWordTempB_H,W
	SUBWF	SYSWORDTEMPB_H,W
;btfss STATUS,C
	BTFSS	STATUS,0
;return
	RETURN
;Test high, exit true if less
;movf SysWordTempB_H,W
	MOVF	SYSWORDTEMPB_H,W
;subwf SysWordTempA_H,W
	SUBWF	SYSWORDTEMPA_H,W
;btfss STATUS,C
	BTFSS	STATUS,0
;goto SCLT16True
	GOTO	SCLT16TRUE
;Test Low, exit if more or equal
;movf SysWordTempB,W
	MOVF	SYSWORDTEMPB,W
;subwf SysWordTempA,W
	SUBWF	SYSWORDTEMPA,W
;btfsc STATUS,C
	BTFSC	STATUS,0
;return
	RETURN
GLOBAL	SCLT16TRUE
SCLT16TRUE:
;comf SysByteTempX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3471)
GLOBAL	SYSCOMPLESSTHAN32
SYSCOMPLESSTHAN32:
;dim SysLongTempA as long
;dim SysLongTempB as long
;dim SysByteTempX as byte
;clrf SysByteTempX
	CLRF	SYSBYTETEMPX
;Test Exp, exit if more
;movf SysLongTempA_E,W
	MOVF	SYSLONGTEMPA_E,W
;subwf SysLongTempB_E,W
	SUBWF	SYSLONGTEMPB_E,W
;btfss STATUS,C
	BTFSS	STATUS,0
;return
	RETURN
;If not more and not zero, is less
;btfss STATUS,Z
	BTFSS	STATUS,2
;goto SCLT32True
	GOTO	SCLT32TRUE
;Test Upper, exit if more
;movf SysLongTempA_U,W
	MOVF	SYSLONGTEMPA_U,W
;subwf SysLongTempB_U,W
	SUBWF	SYSLONGTEMPB_U,W
;btfss STATUS,C
	BTFSS	STATUS,0
;return
	RETURN
;If not more and not zero, is less
;btfss STATUS,Z
	BTFSS	STATUS,2
;goto SCLT32True
	GOTO	SCLT32TRUE
;Test High, exit if more
;movf SysLongTempA_H,W
	MOVF	SYSLONGTEMPA_H,W
;subwf SysLongTempB_H,W
	SUBWF	SYSLONGTEMPB_H,W
;btfss STATUS,C
	BTFSS	STATUS,0
;return
	RETURN
;If not more and not zero, is less
;btfss STATUS,Z
	BTFSS	STATUS,2
;goto SCLT32True
	GOTO	SCLT32TRUE
;Test Low, exit if more or equal
;movf SysLongTempB,W
	MOVF	SYSLONGTEMPB,W
;subwf SysLongTempA,W
	SUBWF	SYSLONGTEMPA,W
;btfsc STATUS,C
	BTFSC	STATUS,0
;return
	RETURN
GLOBAL	SCLT32TRUE
SCLT32TRUE:
;comf SysByteTempX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3714)
GLOBAL	SYSCOMPLESSTHANINT
SYSCOMPLESSTHANINT:
;Dim SysIntegerTempA, SysIntegerTempB, SysDivMultA as Integer
;Clear result
;SysByteTempX = 0
	CLRF	SYSBYTETEMPX
;Compare sign bits
;-A
;If SysIntegerTempA.15 = On Then
	BTFSS	SYSINTEGERTEMPA_H,7
	GOTO	ELSE57_1
;-A, +B, return true
;If SysIntegerTempB.15 = Off Then
	BTFSC	SYSINTEGERTEMPB_H,7
	GOTO	ENDIF58
;Set SysByteTempX to 255
;SysByteTempX = Not SysByteTempX
	COMF	SYSBYTETEMPX,F
;Exit Sub
	RETURN
;End If
GLOBAL	ENDIF58
ENDIF58:
;-A, -B, negate both and swap
;SysDivMultA = -SysIntegerTempA
	COMF	SYSINTEGERTEMPA,W
	MOVWF	SYSDIVMULTA
	COMF	SYSINTEGERTEMPA_H,W
	MOVWF	SYSDIVMULTA_H
	INCF	SYSDIVMULTA,F
	BTFSC	STATUS,2
	INCF	SYSDIVMULTA_H,F
;SysIntegerTempA = -SysIntegerTempB
	COMF	SYSINTEGERTEMPB,W
	MOVWF	SYSINTEGERTEMPA
	COMF	SYSINTEGERTEMPB_H,W
	MOVWF	SYSINTEGERTEMPA_H
	INCF	SYSINTEGERTEMPA,F
	BTFSC	STATUS,2
	INCF	SYSINTEGERTEMPA_H,F
;SysIntegerTempB = SysDivMultA
	MOVF	SYSDIVMULTA,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	SYSDIVMULTA_H,W
	MOVWF	SYSINTEGERTEMPB_H
;+A
;Else
	GOTO	ENDIF57
GLOBAL	ELSE57_1
ELSE57_1:
;+A, -B, return false
;If SysIntegerTempB.15 = On Then
	BTFSC	SYSINTEGERTEMPB_H,7
;Exit Sub
	RETURN
;End If
;End If
GLOBAL	ENDIF57
ENDIF57:
;Test High, exit if more
;movf SysIntegerTempA_H,W
	MOVF	SYSINTEGERTEMPA_H,W
;subwf SysIntegerTempB_H,W
	SUBWF	SYSINTEGERTEMPB_H,W
;btfss STATUS,C
	BTFSS	STATUS,0
;return
	RETURN
;Test high, exit true if less
;movf SysIntegerTempB_H,W
	MOVF	SYSINTEGERTEMPB_H,W
;subwf SysIntegerTempA_H,W
	SUBWF	SYSINTEGERTEMPA_H,W
;btfss STATUS,C
	BTFSS	STATUS,0
;goto SCLTIntTrue
	GOTO	SCLTINTTRUE
;Test Low, exit if more or equal
;movf SysIntegerTempB,W
	MOVF	SYSINTEGERTEMPB,W
;subwf SysIntegerTempA,W
	SUBWF	SYSINTEGERTEMPA,W
;btfsc STATUS,C
	BTFSC	STATUS,0
;return
	RETURN
GLOBAL	SCLTINTTRUE
SCLTINTTRUE:
;comf SysByteTempX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (1374)
GLOBAL	SYSCOPYSTRING
SYSCOPYSTRING:
;Dim SysCalcTempA As Byte
;Dim SysStringLength As Byte
;Get and copy length
;movf INDF0, W
	MOVF	INDF0, W
;movwf SysCalcTempA
	MOVWF	SYSCALCTEMPA
;movwf INDF1
	MOVWF	INDF1
;goto SysCopyStringCheck
	GOTO	SYSCOPYSTRINGCHECK
;When appending, add length to counter
GLOBAL	SYSCOPYSTRINGPART
SYSCOPYSTRINGPART:
;movf INDF0, W
	MOVF	INDF0, W
;movwf SysCalcTempA
	MOVWF	SYSCALCTEMPA
;addwf SysStringLength, F
	ADDWF	SYSSTRINGLENGTH, F
GLOBAL	SYSCOPYSTRINGCHECK
SYSCOPYSTRINGCHECK:
;Exit if length = 0
;movf SysCalcTempA,F
	MOVF	SYSCALCTEMPA,F
;btfsc STATUS,Z
	BTFSC	STATUS,2
;return
	RETURN
GLOBAL	SYSSTRINGCOPY
SYSSTRINGCOPY:
;Increment pointers
;addfsr 0, 1
	ADDFSR	0, 1
;addfsr 1, 1
	ADDFSR	1, 1
;Copy character
;movf INDF0, W
	MOVF	INDF0, W
;movwf INDF1
	MOVWF	INDF1
;decfsz SysCalcTempA, F
	DECFSZ	SYSCALCTEMPA, F
;goto SysStringCopy
	GOTO	SYSSTRINGCOPY
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (2861)
GLOBAL	SYSDIVSUB16
SYSDIVSUB16:
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysWordTempX as word
;dim SysDivMultA as word
;dim SysDivMultB as word
;dim SysDivMultX as word
;SysDivMultA = SysWordTempA
	MOVF	SYSWORDTEMPA,W
	MOVWF	SYSDIVMULTA
	MOVF	SYSWORDTEMPA_H,W
	MOVWF	SYSDIVMULTA_H
;SysDivMultB = SysWordTempB
	MOVF	SYSWORDTEMPB,W
	MOVWF	SYSDIVMULTB
	MOVF	SYSWORDTEMPB_H,W
	MOVWF	SYSDIVMULTB_H
;SysDivMultX = 0
	CLRF	SYSDIVMULTX
	CLRF	SYSDIVMULTX_H
;Avoid division by zero
;if SysDivMultB = 0 then
	MOVF	SYSDIVMULTB,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSDIVMULTB_H,W
	MOVWF	SYSWORDTEMPA_H
	CLRF	SYSWORDTEMPB
	CLRF	SYSWORDTEMPB_H
	FCALL	SYSCOMPEQUAL16
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF50
;SysWordTempA = 0
	CLRF	SYSWORDTEMPA
	CLRF	SYSWORDTEMPA_H
;exit sub
	RETURN
;end if
GLOBAL	ENDIF50
ENDIF50:
;Main calc routine
;SysDivLoop = 16
	MOVLW	16
	MOVWF	SYSDIVLOOP
GLOBAL	SYSDIV16START
SYSDIV16START:
;set C off
	BCF	STATUS,0
;Rotate SysDivMultA Left
	RLF	SYSDIVMULTA,F
	RLF	SYSDIVMULTA_H,F
;Rotate SysDivMultX Left
	RLF	SYSDIVMULTX,F
	RLF	SYSDIVMULTX_H,F
;SysDivMultX = SysDivMultX - SysDivMultB
	MOVF	SYSDIVMULTB,W
	SUBWF	SYSDIVMULTX,F
	MOVF	SYSDIVMULTB_H,W
	SUBWFB	SYSDIVMULTX_H,F
;Set SysDivMultA.0 On
	BSF	SYSDIVMULTA,0
;If C Off Then
	BTFSC	STATUS,0
	GOTO	ENDIF51
;Set SysDivMultA.0 Off
	BCF	SYSDIVMULTA,0
;SysDivMultX = SysDivMultX + SysDivMultB
	MOVF	SYSDIVMULTB,W
	ADDWF	SYSDIVMULTX,F
	MOVF	SYSDIVMULTB_H,W
	ADDWFC	SYSDIVMULTX_H,F
;End If
GLOBAL	ENDIF51
ENDIF51:
;decfsz SysDivLoop, F
	DECFSZ	SYSDIVLOOP, F
;goto SysDiv16Start
	GOTO	SYSDIV16START
;SysWordTempA = SysDivMultA
	MOVF	SYSDIVMULTA,W
	MOVWF	SYSWORDTEMPA
	MOVF	SYSDIVMULTA_H,W
	MOVWF	SYSWORDTEMPA_H
;SysWordTempX = SysDivMultX
	MOVF	SYSDIVMULTX,W
	MOVWF	SYSWORDTEMPX
	MOVF	SYSDIVMULTX_H,W
	MOVWF	SYSWORDTEMPX_H
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (2915)
GLOBAL	SYSDIVSUBINT
SYSDIVSUBINT:
;Dim SysIntegerTempA, SysIntegerTempB, SysIntegerTempX As Integer
;Dim SysSignByte As Byte
;Make both inputs positive, decide output type
;SysSignByte = SysIntegerTempA_H xor SysIntegerTempB_H
	MOVF	SYSINTEGERTEMPA_H,W
	XORWF	SYSINTEGERTEMPB_H,W
	MOVWF	SYSSIGNBYTE
;If SysIntegerTempA.15 Then SysIntegerTempA = -SysIntegerTempA
	BTFSS	SYSINTEGERTEMPA_H,7
	GOTO	ENDIF52
;If SysIntegerTempA.15 Then SysIntegerTempA = -SysIntegerTempA
	COMF	SYSINTEGERTEMPA,F
	COMF	SYSINTEGERTEMPA_H,F
	INCF	SYSINTEGERTEMPA,F
	BTFSC	STATUS,2
	INCF	SYSINTEGERTEMPA_H,F
;If SysIntegerTempA.15 Then SysIntegerTempA = -SysIntegerTempA
GLOBAL	ENDIF52
ENDIF52:
;If SysIntegerTempB.15 Then SysIntegerTempB = -SysIntegerTempB
	BTFSS	SYSINTEGERTEMPB_H,7
	GOTO	ENDIF53
;If SysIntegerTempB.15 Then SysIntegerTempB = -SysIntegerTempB
	COMF	SYSINTEGERTEMPB,F
	COMF	SYSINTEGERTEMPB_H,F
	INCF	SYSINTEGERTEMPB,F
	BTFSC	STATUS,2
	INCF	SYSINTEGERTEMPB_H,F
;If SysIntegerTempB.15 Then SysIntegerTempB = -SysIntegerTempB
GLOBAL	ENDIF53
ENDIF53:
;Call word divide routine
;SysDivSub16
	FCALL	SYSDIVSUB16
;Negate result if necessary
;If SysSignByte.7 Then
	BTFSS	SYSSIGNBYTE,7
	GOTO	ENDIF54
;SysIntegerTempA = -SysIntegerTempA
	COMF	SYSINTEGERTEMPA,F
	COMF	SYSINTEGERTEMPA_H,F
	INCF	SYSINTEGERTEMPA,F
	BTFSC	STATUS,2
	INCF	SYSINTEGERTEMPA_H,F
;SysIntegerTempX = -SysIntegerTempX
	COMF	SYSINTEGERTEMPX,F
	COMF	SYSINTEGERTEMPX_H,F
	INCF	SYSINTEGERTEMPX,F
	BTFSC	STATUS,2
	INCF	SYSINTEGERTEMPX_H,F
;End If
GLOBAL	ENDIF54
ENDIF54:
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (2518)
GLOBAL	SYSMULTSUB
SYSMULTSUB:
;dim SysByteTempA as byte
;dim SysByteTempB as byte
;dim SysByteTempX as byte
;clrf SysByteTempX
	CLRF	SYSBYTETEMPX
GLOBAL	MUL8LOOP
MUL8LOOP:
;movf SysByteTempA, W
	MOVF	SYSBYTETEMPA, W
;btfsc SysByteTempB, 0
	BTFSC	SYSBYTETEMPB, 0
;addwf SysByteTempX, F
	ADDWF	SYSBYTETEMPX, F
;bcf STATUS, C
	BCF	STATUS,0
;rrf SysByteTempB, F
	RRF	SYSBYTETEMPB, F
;bcf STATUS, C
	BCF	STATUS,0
;rlf SysByteTempA, F
	RLF	SYSBYTETEMPA, F
;movf SysByteTempB, F
	MOVF	SYSBYTETEMPB, F
;btfss STATUS, Z
	BTFSS	STATUS,2
;goto MUL8LOOP
	GOTO	MUL8LOOP
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (2565)
GLOBAL	SYSMULTSUB16
SYSMULTSUB16:
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysWordTempX as word
;dim SysDivMultA as word
;dim SysDivMultB as word
;dim SysDivMultX as word
;SysDivMultA = SysWordTempA
	MOVF	SYSWORDTEMPA,W
	MOVWF	SYSDIVMULTA
	MOVF	SYSWORDTEMPA_H,W
	MOVWF	SYSDIVMULTA_H
;SysDivMultB = SysWordTempB
	MOVF	SYSWORDTEMPB,W
	MOVWF	SYSDIVMULTB
	MOVF	SYSWORDTEMPB_H,W
	MOVWF	SYSDIVMULTB_H
;SysDivMultX = 0
	CLRF	SYSDIVMULTX
	CLRF	SYSDIVMULTX_H
GLOBAL	MUL16LOOP
MUL16LOOP:
;IF SysDivMultB.0 ON then SysDivMultX += SysDivMultA
	BTFSS	SYSDIVMULTB,0
	GOTO	ENDIF43
;IF SysDivMultB.0 ON then SysDivMultX += SysDivMultA
	MOVF	SYSDIVMULTA,W
	ADDWF	SYSDIVMULTX,F
	MOVF	SYSDIVMULTA_H,W
	ADDWFC	SYSDIVMULTX_H,F
;IF SysDivMultB.0 ON then SysDivMultX += SysDivMultA
GLOBAL	ENDIF43
ENDIF43:
;set STATUS.C OFF
	BCF	STATUS,0
;rotate SysDivMultB right
	RRF	SYSDIVMULTB_H,F
	RRF	SYSDIVMULTB,F
;set STATUS.C off
	BCF	STATUS,0
;rotate SysDivMultA left
	RLF	SYSDIVMULTA,F
	RLF	SYSDIVMULTA_H,F
;if SysDivMultB > 0 then goto MUL16LOOP
	MOVF	SYSDIVMULTB,W
	MOVWF	SYSWORDTEMPB
	MOVF	SYSDIVMULTB_H,W
	MOVWF	SYSWORDTEMPB_H
	CLRF	SYSWORDTEMPA
	CLRF	SYSWORDTEMPA_H
	FCALL	SYSCOMPLESSTHAN16
	BTFSC	SYSBYTETEMPX,0
;if SysDivMultB > 0 then goto MUL16LOOP
	GOTO	MUL16LOOP
;if SysDivMultB > 0 then goto MUL16LOOP
;SysWordTempX = SysDivMultX
	MOVF	SYSDIVMULTX,W
	MOVWF	SYSWORDTEMPX
	MOVF	SYSDIVMULTX_H,W
	MOVWF	SYSWORDTEMPX_H
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (2682)
GLOBAL	SYSMULTSUB32
SYSMULTSUB32:
;dim SysLongTempA as long
;dim SysLongTempB as long
;dim SysLongTempX as long
;Can't use normal SysDivMult variables for 32 bit, they overlap with
;SysLongTemp variables
;dim SysLongDivMultA as long
;dim SysLongDivMultB as long
;dim SysLongDivMultX as long
;SysLongDivMultA = SysLongTempA
	MOVF	SYSLONGTEMPA,W
	BANKSEL	SYSLONGDIVMULTA
	MOVWF	SYSLONGDIVMULTA
	MOVF	SYSLONGTEMPA_H,W
	MOVWF	SYSLONGDIVMULTA_H
	MOVF	SYSLONGTEMPA_U,W
	MOVWF	SYSLONGDIVMULTA_U
	MOVF	SYSLONGTEMPA_E,W
	MOVWF	SYSLONGDIVMULTA_E
;SysLongDivMultB = SysLongTempB
	MOVF	SYSLONGTEMPB,W
	MOVWF	SYSLONGDIVMULTB
	MOVF	SYSLONGTEMPB_H,W
	MOVWF	SYSLONGDIVMULTB_H
	MOVF	SYSLONGTEMPB_U,W
	MOVWF	SYSLONGDIVMULTB_U
	MOVF	SYSLONGTEMPB_E,W
	MOVWF	SYSLONGDIVMULTB_E
;SysLongDivMultX = 0
	CLRF	SYSLONGDIVMULTX
	CLRF	SYSLONGDIVMULTX_H
	CLRF	SYSLONGDIVMULTX_U
	CLRF	SYSLONGDIVMULTX_E
GLOBAL	MUL32LOOP
MUL32LOOP:
;IF SysLongDivMultB.0 ON then SysLongDivMultX += SysLongDivMultA
	BANKSEL	SYSLONGDIVMULTB
	BTFSS	SYSLONGDIVMULTB,0
	GOTO	ENDIF48
;IF SysLongDivMultB.0 ON then SysLongDivMultX += SysLongDivMultA
	MOVF	SYSLONGDIVMULTA,W
	ADDWF	SYSLONGDIVMULTX,F
	MOVF	SYSLONGDIVMULTA_H,W
	ADDWFC	SYSLONGDIVMULTX_H,F
	MOVF	SYSLONGDIVMULTA_U,W
	ADDWFC	SYSLONGDIVMULTX_U,F
	MOVF	SYSLONGDIVMULTA_E,W
	ADDWFC	SYSLONGDIVMULTX_E,F
;IF SysLongDivMultB.0 ON then SysLongDivMultX += SysLongDivMultA
GLOBAL	ENDIF48
ENDIF48:
;set STATUS.C OFF
	BCF	STATUS,0
;rotate SysLongDivMultB right
	RRF	SYSLONGDIVMULTB_E,F
	RRF	SYSLONGDIVMULTB_U,F
	RRF	SYSLONGDIVMULTB_H,F
	RRF	SYSLONGDIVMULTB,F
;set STATUS.C off
	BCF	STATUS,0
;rotate SysLongDivMultA left
	RLF	SYSLONGDIVMULTA,F
	RLF	SYSLONGDIVMULTA_H,F
	RLF	SYSLONGDIVMULTA_U,F
	RLF	SYSLONGDIVMULTA_E,F
;if SysLongDivMultB > 0 then goto MUL32LOOP
	MOVF	SYSLONGDIVMULTB,W
	MOVWF	SYSLONGTEMPB
	MOVF	SYSLONGDIVMULTB_H,W
	MOVWF	SYSLONGTEMPB_H
	MOVF	SYSLONGDIVMULTB_U,W
	MOVWF	SYSLONGTEMPB_U
	MOVF	SYSLONGDIVMULTB_E,W
	MOVWF	SYSLONGTEMPB_E
	CLRF	SYSLONGTEMPA
	CLRF	SYSLONGTEMPA_H
	CLRF	SYSLONGTEMPA_U
	CLRF	SYSLONGTEMPA_E
	BANKSEL	STATUS
	FCALL	SYSCOMPLESSTHAN32
	BTFSC	SYSBYTETEMPX,0
;if SysLongDivMultB > 0 then goto MUL32LOOP
	GOTO	MUL32LOOP
;if SysLongDivMultB > 0 then goto MUL32LOOP
;SysLongTempX = SysLongDivMultX
	BANKSEL	SYSLONGDIVMULTX
	MOVF	SYSLONGDIVMULTX,W
	MOVWF	SYSLONGTEMPX
	MOVF	SYSLONGDIVMULTX_H,W
	MOVWF	SYSLONGTEMPX_H
	MOVF	SYSLONGDIVMULTX_U,W
	MOVWF	SYSLONGTEMPX_U
	MOVF	SYSLONGDIVMULTX_E,W
	MOVWF	SYSLONGTEMPX_E
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (2663)
GLOBAL	SYSMULTSUBINT
SYSMULTSUBINT:
;Dim SysIntegerTempA, SysIntegerTempB, SysIntegerTempX As Integer
;Dim SysSignByte As Byte
;Make both inputs positive, decide output type
;SysSignByte = SysIntegerTempA_H xor SysIntegerTempB_H
	MOVF	SYSINTEGERTEMPA_H,W
	XORWF	SYSINTEGERTEMPB_H,W
	MOVWF	SYSSIGNBYTE
;if SysIntegerTempA.15 then SysIntegerTempA = -SysIntegerTempA
	BTFSS	SYSINTEGERTEMPA_H,7
	GOTO	ENDIF45
;if SysIntegerTempA.15 then SysIntegerTempA = -SysIntegerTempA
	COMF	SYSINTEGERTEMPA,F
	COMF	SYSINTEGERTEMPA_H,F
	INCF	SYSINTEGERTEMPA,F
	BTFSC	STATUS,2
	INCF	SYSINTEGERTEMPA_H,F
;if SysIntegerTempA.15 then SysIntegerTempA = -SysIntegerTempA
GLOBAL	ENDIF45
ENDIF45:
;if SysIntegerTempB.15 then SysIntegerTempB = -SysIntegerTempB
	BTFSS	SYSINTEGERTEMPB_H,7
	GOTO	ENDIF46
;if SysIntegerTempB.15 then SysIntegerTempB = -SysIntegerTempB
	COMF	SYSINTEGERTEMPB,F
	COMF	SYSINTEGERTEMPB_H,F
	INCF	SYSINTEGERTEMPB,F
	BTFSC	STATUS,2
	INCF	SYSINTEGERTEMPB_H,F
;if SysIntegerTempB.15 then SysIntegerTempB = -SysIntegerTempB
GLOBAL	ENDIF46
ENDIF46:
;Call word multiply routine
;SysMultSub16
	FCALL	SYSMULTSUB16
;Negate result if necessary
;if SysSignByte.7 then SysIntegerTempX = -SysIntegerTempX
	BTFSS	SYSSIGNBYTE,7
	GOTO	ENDIF47
;if SysSignByte.7 then SysIntegerTempX = -SysIntegerTempX
	COMF	SYSINTEGERTEMPX,F
	COMF	SYSINTEGERTEMPX_H,F
	INCF	SYSINTEGERTEMPX,F
	BTFSC	STATUS,2
	INCF	SYSINTEGERTEMPX_H,F
;if SysSignByte.7 then SysIntegerTempX = -SysIntegerTempX
GLOBAL	ENDIF47
ENDIF47:
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (1571)
GLOBAL	SYSREADSTRING
SYSREADSTRING:
;Dim SysCalcTempA As Byte
;Dim SysStringLength As Byte
;Get length
;call SysStringTables
	CALL	SYSSTRINGTABLES
;movwf SysCalcTempA
	MOVWF	SYSCALCTEMPA
;movwf INDF1
	MOVWF	INDF1
;goto SysStringReadCheck
	GOTO	SYSSTRINGREADCHECK
GLOBAL	SYSREADSTRINGPART
SYSREADSTRINGPART:
;Get length
;call SysStringTables
	CALL	SYSSTRINGTABLES
;movwf SysCalcTempA
	MOVWF	SYSCALCTEMPA
;addwf SysStringLength,F
	ADDWF	SYSSTRINGLENGTH,F
;Check length
GLOBAL	SYSSTRINGREADCHECK
SYSSTRINGREADCHECK:
;If length is 0, exit
;movf SysCalcTempA,F
	MOVF	SYSCALCTEMPA,F
;btfsc STATUS,Z
	BTFSC	STATUS,2
;return
	RETURN
;Copy
GLOBAL	SYSSTRINGREAD
SYSSTRINGREAD:
;Get char
;call SysStringTables
	CALL	SYSSTRINGTABLES
;Set char
;addfsr 1,1
	ADDFSR	1,1
;movwf INDF1
	MOVWF	INDF1
;decfsz SysCalcTempA, F
	DECFSZ	SYSCALCTEMPA, F
;goto SysStringRead
	GOTO	SYSSTRINGREAD
	RETURN

;********************************************************************************

GLOBAL	SYSSTRINGTABLES
SYSSTRINGTABLES:
	MOVF	SYSSTRINGA_H,W
	MOVWF	PCLATH
	MOVF	SYSSTRINGA,W
	INCF	SYSSTRINGA,F
	BTFSC	STATUS,2
	INCF	SYSSTRINGA_H,F
	MOVWF	PCL

GLOBAL	STRINGTABLE1
STRINGTABLE1:
	RETLW	1
	RETLW	48	;0


GLOBAL	STRINGTABLE2
STRINGTABLE2:
	RETLW	1
	RETLW	53	;5


GLOBAL	STRINGTABLE3
STRINGTABLE3:
	RETLW	3
	RETLW	48	;0
	RETLW	46	;.
	RETLW	48	;0


GLOBAL	STRINGTABLE4
STRINGTABLE4:
	RETLW	2
	RETLW	48	;0
	RETLW	46	;.


GLOBAL	STRINGTABLE5
STRINGTABLE5:
	RETLW	1
	RETLW	46	;.


;********************************************************************************

;SOURCE: GLCD_SSD1306.H (224)
GLOBAL	WRITE_COMMAND_SSD1306
WRITE_COMMAND_SSD1306:
;HI2CStart
	CALL	HI2CSTART
;HI2CSend GLCD_I2C_Address
	MOVLW	120
	MOVWF	I2CBYTE
	CALL	HI2CSEND
;HI2CSend 0x00
	CLRF	I2CBYTE
	CALL	HI2CSEND
;HI2CSend SSD1306SendByte
	BANKSEL	SSD1306SENDBYTE
	MOVF	SSD1306SENDBYTE,W
	BANKSEL	I2CBYTE
	MOVWF	I2CBYTE
	CALL	HI2CSEND
;HI2CStop
	GOTO	HI2CSTOP

;********************************************************************************

;SOURCE: GLCD_SSD1306.H (270)
GLOBAL	WRITE_DATA_SSD1306
WRITE_DATA_SSD1306:
;HI2CStart
	CALL	HI2CSTART
;HI2CSend GLCD_I2C_Address
	MOVLW	120
	MOVWF	I2CBYTE
	CALL	HI2CSEND
;HI2CSend 0x40
	MOVLW	64
	MOVWF	I2CBYTE
	CALL	HI2CSEND
;HI2CSend SSD1306SendByte
	BANKSEL	SSD1306SENDBYTE
	MOVF	SSD1306SENDBYTE,W
	BANKSEL	I2CBYTE
	MOVWF	I2CBYTE
	CALL	HI2CSEND
;HI2CStop
	GOTO	HI2CSTOP

;********************************************************************************

;START OF PROGRAM MEMORY PAGE 3
	PSECT	PROGMEM3,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	6144
;START OF PROGRAM MEMORY PAGE 4
	PSECT	PROGMEM4,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	8192
;START OF PROGRAM MEMORY PAGE 5
	PSECT	PROGMEM5,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	10240
;START OF PROGRAM MEMORY PAGE 6
	PSECT	PROGMEM6,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	12288
;START OF PROGRAM MEMORY PAGE 7
	PSECT	PROGMEM7,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	14336
;
; Declare Power-On-Reset entry point
;
 END     RESETVEC
