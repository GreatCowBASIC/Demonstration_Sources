;Program compiled by GCBASIC (1.00.00 Release Candidate 2022-11-06 (Windows 64 bit) : Build 1189) for Microchip PIC-AS
;  See the GCBASIC forums at http://sourceforge.net/projects/gcbasic/forums,
;  Check the documentation and Help at http://gcbasic.sourceforge.net/help/,
;or, email:
;   evanvennn at users dot sourceforge dot net

;********************************************************************************


;Set up the assembler options (Chip type, clock source, other bits and pieces)
;PROCESSOR   16F18126
 PAGEWIDTH   180
 RADIX       DEC
 TITLE       "d:\GreatCowBASICGits\Demonstration_Sources.git\trunk\Vendor_Boards\Microchip_Low_Pin_Count_Demo_Board\PICKit2_Board\16F18126\180_ensuring_program_matches_chip_specfiied_to_serial_terminal.s"
 SUBTITLE    "11-24-2022"

; Reverse lookup file(s)
; C:\Program Files\Microchip\xc8\v2.40\pic\include\proc\pic16f18126.inc
; C:\Program Files\Microchip\xc8\v2.40\pic\dat\cfgmap\16f18126.cfgmap
; Alternative CONFIG file is to be found at C:\Program Files\Microchip\xc8\vX.YY\pic\dat\cfgdata as per Microchip support ticket #00730936 

;********************************************************************************

;********************************************************************************
;Explicit CONFIG
 CONFIG FCMEN=ON                                 ;C1 Reverselookup FCMEN = ON
 CONFIG CLKOUTEN=OFF                             ;C1 Reverselookup CLKOUTEN = OFF
 CONFIG RSTOSC=HFINTOSC_32MHz                    ;C1 Reverselookup RSTOSC = HFINTOSC_32MHZ
 CONFIG FEXTOSC=OFF                              ;C1 Reverselookup FEXTOSC = OFF
 CONFIG MCLRE=INTMCLR                            ;C1 Reverselookup MCLRE = INTMCLR
 CONFIG WDTE=OFF                                 ;C1 Reverselookup WDTE = OFF
 CONFIG LVP=OFF                                  ;C1 Reverselookup LVP = OFF
 CONFIG WRTSAF=OFF                               ;C1 Reverselookup WRTSAF = OFF
 CONFIG WRTD=OFF                                 ;C1 Reverselookup WRTD = OFF
 CONFIG WRTB=OFF                                 ;C1 Reverselookup WRTB = OFF
 CONFIG CPD=OFF                                  ;C1 Reverselookup CPD = OFF
 CONFIG CP=OFF                                   ;C1 Reverselookup CP = OFF
;Inferred CONFIG


;********************************************************************************
; The XC8 xc.inc include file.  This MUST be placed after the CONFIG statements.

 #include <xc.inc>

;********************************************************************************

;Set aside RAM memory locations for variables. All variables are global.
GLOBAL	ASC
 ASC                              EQU 32          ; 0X20
GLOBAL	COMPORT
 COMPORT                          EQU 33          ; 0X21
GLOBAL	DELAYTEMP
 DELAYTEMP                        EQU 112          ; 0X70
GLOBAL	DELAYTEMP2
 DELAYTEMP2                       EQU 113          ; 0X71
GLOBAL	HSERPRINTCRLFCOUNT
 HSERPRINTCRLFCOUNT               EQU 34          ; 0X22
GLOBAL	LTRIM
 LTRIM                            EQU 10118          ; 0X2786
GLOBAL	MID
 MID                              EQU 10077          ; 0X275D
GLOBAL	PRINTLEN
 PRINTLEN                         EQU 35          ; 0X23
GLOBAL	RTRIM
 RTRIM                            EQU 10036          ; 0X2734
GLOBAL	SERDATA
 SERDATA                          EQU 36          ; 0X24
GLOBAL	STRINGPOINTER
 STRINGPOINTER                    EQU 37          ; 0X25
GLOBAL	SYSARRAYTEMP1
 SYSARRAYTEMP1                    EQU 38          ; 0X26
GLOBAL	SYSARRAYTEMP2
 SYSARRAYTEMP2                    EQU 39          ; 0X27
GLOBAL	SYSBYTETEMPA
 SYSBYTETEMPA                     EQU 117          ; 0X75
GLOBAL	SYSBYTETEMPB
 SYSBYTETEMPB                     EQU 121          ; 0X79
GLOBAL	SYSBYTETEMPX
 SYSBYTETEMPX                     EQU 112          ; 0X70
GLOBAL	SYSCALCTEMPA
 SYSCALCTEMPA                     EQU 117          ; 0X75
GLOBAL	SYSCHAR
 SYSCHAR                          EQU 40          ; 0X28
GLOBAL	SYSCHARCOUNT
 SYSCHARCOUNT                     EQU 41          ; 0X29
GLOBAL	SYSCHARLT
 SYSCHARLT                        EQU 42          ; 0X2A
GLOBAL	SYSCHARLTCOUNT
 SYSCHARLTCOUNT                   EQU 43          ; 0X2B
GLOBAL	SYSCHARRT
 SYSCHARRT                        EQU 44          ; 0X2C
GLOBAL	SYSCHARRTCOUNT
 SYSCHARRTCOUNT                   EQU 45          ; 0X2D
GLOBAL	SYSCHARSTART
 SYSCHARSTART                     EQU 46          ; 0X2E
GLOBAL	SYSDIVMULTA
 SYSDIVMULTA                      EQU 119          ; 0X77
GLOBAL	SYSDIVMULTA_H
 SYSDIVMULTA_H                    EQU 120          ; 0X78
GLOBAL	SYSFORLOOPSTEP4
 SYSFORLOOPSTEP4                  EQU 47          ; 0X2F
GLOBAL	SYSFORLOOPSTEP4_H
 SYSFORLOOPSTEP4_H                EQU 48          ; 0X30
GLOBAL	SYSINTEGERTEMPA
 SYSINTEGERTEMPA                  EQU 117          ; 0X75
GLOBAL	SYSINTEGERTEMPA_H
 SYSINTEGERTEMPA_H                EQU 118          ; 0X76
GLOBAL	SYSINTEGERTEMPB
 SYSINTEGERTEMPB                  EQU 121          ; 0X79
GLOBAL	SYSINTEGERTEMPB_H
 SYSINTEGERTEMPB_H                EQU 122          ; 0X7A
GLOBAL	SYSPRINTDATAHANDLER
 SYSPRINTDATAHANDLER              EQU 49          ; 0X31
GLOBAL	SYSPRINTDATAHANDLER_H
 SYSPRINTDATAHANDLER_H            EQU 50          ; 0X32
GLOBAL	SYSPRINTTEMP
 SYSPRINTTEMP                     EQU 51          ; 0X33
GLOBAL	SYSREPEATTEMP1
 SYSREPEATTEMP1                   EQU 52          ; 0X34
GLOBAL	SYSSTRDATA
 SYSSTRDATA                       EQU 53          ; 0X35
GLOBAL	SYSSTRINGA
 SYSSTRINGA                       EQU 119          ; 0X77
GLOBAL	SYSSTRINGA_H
 SYSSTRINGA_H                     EQU 120          ; 0X78
GLOBAL	SYSSTRINGLENGTH
 SYSSTRINGLENGTH                  EQU 118          ; 0X76
GLOBAL	SYSSTRINGPARAM1
 SYSSTRINGPARAM1                  EQU 10159          ; 0X27AF
GLOBAL	SYSSTRINGTEMP
 SYSSTRINGTEMP                    EQU 54          ; 0X36
GLOBAL	SYSSYSINSTRING2HANDLER
 SYSSYSINSTRING2HANDLER           EQU 55          ; 0X37
GLOBAL	SYSSYSINSTRING2HANDLER_H
 SYSSYSINSTRING2HANDLER_H         EQU 56          ; 0X38
GLOBAL	SYSSYSINSTRING3HANDLER
 SYSSYSINSTRING3HANDLER           EQU 57          ; 0X39
GLOBAL	SYSSYSINSTRING3HANDLER_H
 SYSSYSINSTRING3HANDLER_H         EQU 58          ; 0X3A
GLOBAL	SYSSYSINSTRINGAHANDLER
 SYSSYSINSTRINGAHANDLER           EQU 59          ; 0X3B
GLOBAL	SYSSYSINSTRINGAHANDLER_H
 SYSSYSINSTRINGAHANDLER_H         EQU 60          ; 0X3C
GLOBAL	SYSSYSINSTRINGHANDLER
 SYSSYSINSTRINGHANDLER            EQU 61          ; 0X3D
GLOBAL	SYSSYSINSTRINGHANDLER_H
 SYSSYSINSTRINGHANDLER_H          EQU 62          ; 0X3E
GLOBAL	SYSTEMP1
 SYSTEMP1                         EQU 63          ; 0X3F
GLOBAL	SYSTEMP2
 SYSTEMP2                         EQU 64          ; 0X40
GLOBAL	SYSTEMP2_H
 SYSTEMP2_H                       EQU 65          ; 0X41
GLOBAL	SYSTEMP3
 SYSTEMP3                         EQU 66          ; 0X42
GLOBAL	SYSTEMPARRAY
 SYSTEMPARRAY                     EQU 9995          ; 0X270B
GLOBAL	SYSTEMPLT
 SYSTEMPLT                        EQU 67          ; 0X43
GLOBAL	SYSTEMPRT
 SYSTEMPRT                        EQU 68          ; 0X44
GLOBAL	SYSWAITTEMPMS
 SYSWAITTEMPMS                    EQU 114          ; 0X72
GLOBAL	SYSWAITTEMPMS_H
 SYSWAITTEMPMS_H                  EQU 115          ; 0X73
GLOBAL	SYSWAITTEMPS
 SYSWAITTEMPS                     EQU 116          ; 0X74
GLOBAL	TRIM
 TRIM                             EQU 9954          ; 0X26E2
GLOBAL	UCASE
 UCASE                            EQU 9913          ; 0X26B9

;********************************************************************************

;ALIAS VARIABLES
GLOBAL	AFSR0
 AFSR0                            EQU 4
GLOBAL	AFSR0_H
 AFSR0_H                          EQU 5
GLOBAL	SYSMID_0
 SYSMID_0                         EQU 3021
GLOBAL	SYSUCASE_0
 SYSUCASE_0                       EQU 2761

;********************************************************************************

 PSECT   PROGMEM0,delta=2, abs
 RESETVEC:
;VECTORS
	ORG	0
	PAGESEL	BASPROGRAMSTART
	GOTO	BASPROGRAMSTART
	ORG	4
	RETFIE

;********************************************************************************

;START OF PROGRAM MEMORY PAGE 0
	ORG	5
GLOBAL	BASPROGRAMSTART
BASPROGRAMSTART:
;CALL INITIALISATION ROUTINES
	CALL	INITSYS
	CALL	INITPPS
	CALL	INITUSART

;START OF THE MAIN PROGRAM
;''
;'' This demonstration will show how you can determine the chip parameters, we show the ChipNameStr
;''
;'' This demonstration how you can check your program is intented for a specific Microcontroller
;''
;''************************************************************************
;''@author  EvanV
;''@licence GPL
;''@version 1.00
;''@date    31.11.2022
;----- Configuration
;----- Configuration
;Chip Settings.
;Template comment at the end of the config file
;' -------------------PORTA----------------
;' Bit#:  -7---6---5---4---3---2---1---0---
;' IO:   -----------------SW----------ADC--
;'-----------------------------------------
;'
;' -------------------PORTB----------------
;' Bit#:  -7---6---5---4---3---2---1---0---
;' IO:    ---------------------------------
;'-----------------------------------------
;'
;' ------------------PORTC-----------------
;' Bit#:  -7---6---5---4---3---2---1---0---
;' IO:    ------------TX-LED--LED-LED LED--
;'-----------------------------------------
;Define constants to make things easier. We can reuse these at any time.
;Dir     RC0         Out
	BCF	TRISC,0
;Dir     RC1         Out
	BCF	TRISC,1
;Dir     RC2         Out
	BCF	TRISC,2
;Dir     RC3         Out
	BCF	TRISC,3
;Dir     POTENTIOMETER In
	BSF	TRISA,0
;Dir     SWITCHIN      In
	BSF	TRISA,3
;Setup Serial port
;*****************************************************************************************************
;Main program commences here.. everything before this is setup for the board.
;Now assumes Serial Terminal is operational
;HSerPrintCRLF
	MOVLW	1
	MOVWF	HSERPRINTCRLFCOUNT
	MOVLW	1
	MOVWF	COMPORT
	CALL	HSERPRINTCRLF
;HSerPrint  ChipNameStr + " GCBASIC Demo"
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	FSR1L
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	FSR1H
	CLRF	SYSSTRINGLENGTH
	MOVLW	LOW STRINGTABLE83
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH STRINGTABLE83) & 127
	MOVWF	SYSSTRINGA_H
	CALL	SYSREADSTRINGPART
	MOVLW	LOW STRINGTABLE1
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH STRINGTABLE1) & 127
	MOVWF	SYSSTRINGA_H
	CALL	SYSREADSTRINGPART
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	FSR0L
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	FSR0H
	MOVF	SYSSTRINGLENGTH,W
	MOVWF	INDF0
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H
	MOVLW	1
	MOVWF	COMPORT
;USED SYSDEFAULTCONCATSTRING CONSTANT TO CREATE SYSSTRINGPARAM1 STRING OF LENGTH 64 TO CATER FOR CONSTANT_STRING + CONSTANT_STRING CONCATENATION
	CALL	HSERPRINT304
;HSerPrintCRLF
	MOVLW	1
	MOVWF	HSERPRINTCRLFCOUNT
	MOVLW	1
	MOVWF	COMPORT
	CALL	HSERPRINTCRLF
;Wait 1 s
	MOVLW	1
	MOVWF	SYSWAITTEMPS
	CALL	DELAY_S
;If Trim( UCase( "16f18126") )  <> ChipNameStr Then
	MOVLW	LOW STRINGTABLE2
	MOVWF	SYSSYSINSTRINGHANDLER
	MOVLW	(HIGH STRINGTABLE2) | 128
	MOVWF	SYSSYSINSTRINGHANDLER_H
	CALL	FN_UCASE
	MOVLW	LOW UCASE
	MOVWF	SYSSYSINSTRINGHANDLER
	MOVLW	HIGH UCASE
	MOVWF	SYSSYSINSTRINGHANDLER_H
	CALL	FN_TRIM
	MOVLW	LOW SYSTEMPARRAY
	MOVWF	FSR1L
	MOVLW	HIGH SYSTEMPARRAY
	MOVWF	FSR1H
	MOVLW	LOW STRINGTABLE83
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH STRINGTABLE83) & 127
	MOVWF	SYSSTRINGA_H
	CALL	SYSREADSTRING
	MOVLW	LOW TRIM
	MOVWF	FSR0L
	MOVLW	HIGH TRIM
	MOVWF	FSR0H
	MOVLW	LOW SYSTEMPARRAY
	MOVWF	FSR1L
	MOVLW	HIGH SYSTEMPARRAY
	MOVWF	FSR1H
	CALL	SYSCOMPEQUALSTRING
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ELSE1_1
;HSerPrint "Wrong Microcontroller program intended for 16f18126"
	MOVLW	LOW STRINGTABLE3
	MOVWF	SYSPRINTDATAHANDLER
	MOVLW	(HIGH STRINGTABLE3) | 128
	MOVWF	SYSPRINTDATAHANDLER_H
	MOVLW	1
	MOVWF	COMPORT
	CALL	HSERPRINT304
;HSerPrintCRLF
	MOVLW	1
	MOVWF	HSERPRINTCRLFCOUNT
	MOVLW	1
	MOVWF	COMPORT
	CALL	HSERPRINTCRLF
;HSerPrint "The Microcontroller is a " + ChipNameStr
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	FSR1L
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	FSR1H
	CLRF	SYSSTRINGLENGTH
	MOVLW	LOW STRINGTABLE4
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH STRINGTABLE4) & 127
	MOVWF	SYSSTRINGA_H
	CALL	SYSREADSTRINGPART
	MOVLW	LOW STRINGTABLE83
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH STRINGTABLE83) & 127
	MOVWF	SYSSTRINGA_H
	CALL	SYSREADSTRINGPART
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	FSR0L
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	FSR0H
	MOVF	SYSSTRINGLENGTH,W
	MOVWF	INDF0
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H
	MOVLW	1
	MOVWF	COMPORT
;USED SYSDEFAULTCONCATSTRING CONSTANT TO CREATE SYSSTRINGPARAM1 STRING OF LENGTH 64 TO CATER FOR CONSTANT_STRING + CONSTANT_STRING CONCATENATION
	CALL	HSERPRINT304
;HSerPrintCRLF
	MOVLW	1
	MOVWF	HSERPRINTCRLFCOUNT
	MOVLW	1
	MOVWF	COMPORT
	CALL	HSERPRINTCRLF
;Wait While TRUE
GLOBAL	SYSWAITLOOP1
SYSWAITLOOP1:
	GOTO	SYSWAITLOOP1
;Else
	GOTO	ENDIF1
GLOBAL	ELSE1_1
ELSE1_1:
;HSerPrint "The Microcontroller program intended for the " + ChipNameStr
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	FSR1L
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	FSR1H
	CLRF	SYSSTRINGLENGTH
	MOVLW	LOW STRINGTABLE5
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH STRINGTABLE5) & 127
	MOVWF	SYSSTRINGA_H
	CALL	SYSREADSTRINGPART
	MOVLW	LOW STRINGTABLE83
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH STRINGTABLE83) & 127
	MOVWF	SYSSTRINGA_H
	CALL	SYSREADSTRINGPART
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	FSR0L
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	FSR0H
	MOVF	SYSSTRINGLENGTH,W
	MOVWF	INDF0
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H
	MOVLW	1
	MOVWF	COMPORT
;USED SYSDEFAULTCONCATSTRING CONSTANT TO CREATE SYSSTRINGPARAM1 STRING OF LENGTH 64 TO CATER FOR CONSTANT_STRING + CONSTANT_STRING CONCATENATION
	CALL	HSERPRINT304
;HSerPrintCRLF
	MOVLW	1
	MOVWF	HSERPRINTCRLFCOUNT
	MOVLW	1
	MOVWF	COMPORT
	CALL	HSERPRINTCRLF
;Wait While TRUE
GLOBAL	SYSWAITLOOP2
SYSWAITLOOP2:
	GOTO	SYSWAITLOOP2
;End If
GLOBAL	ENDIF1
ENDIF1:
;End
	GOTO	BASPROGRAMEND
;----- Support methods.  Subroutines and Functions
GLOBAL	BASPROGRAMEND
BASPROGRAMEND:
	SLEEP
	GOTO	BASPROGRAMEND

;********************************************************************************

;SOURCE: STRING.H (524)
GLOBAL	FN_ASC
FN_ASC:
;Asc = 0
	CLRF	ASC
;Get length of string, don't try _asc ing if it's empty
;SysCharCount = SysInStringA(0)
	MOVF	SYSSYSINSTRINGAHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRINGAHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	MOVWF	SYSCHARCOUNT
;If SysCharCount = 0 Then Exit Function
	MOVF	SYSCHARCOUNT,F
	BTFSC	STATUS,2
;If SysCharCount = 0 Then Exit Function
	RETURN
;If SysCharCount = 0 Then Exit Function
;if Syschar > SysCharCount Then Exit Function
	MOVF	SYSCHAR,W
	SUBWF	SYSCHARCOUNT,W
	BTFSS	STATUS,0
;if Syschar > SysCharCount Then Exit Function
	RETURN
;if Syschar > SysCharCount Then Exit Function
;Get first char of string, only first character is of interest, Syschar if provided
;Asc = SysInStringA( Syschar )
	MOVF	SYSCHAR,W
	ADDWF	SYSSYSINSTRINGAHANDLER,W
	MOVWF	FSR0L
	MOVLW	0
	ADDWFC	SYSSYSINSTRINGAHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	MOVWF	ASC
	RETURN

;********************************************************************************

GLOBAL	DELAY_MS
DELAY_MS:
	INCF	SYSWAITTEMPMS_H, F
GLOBAL	DMS_START
DMS_START:
	MOVLW	14
	MOVWF	DELAYTEMP2
GLOBAL	DMS_OUTER
DMS_OUTER:
	MOVLW	189
	MOVWF	DELAYTEMP
GLOBAL	DMS_INNER
DMS_INNER:
	DECFSZ	DELAYTEMP, F
	GOTO	DMS_INNER
	DECFSZ	DELAYTEMP2, F
	GOTO	DMS_OUTER
	DECFSZ	SYSWAITTEMPMS, F
	GOTO	DMS_START
	DECFSZ	SYSWAITTEMPMS_H, F
	GOTO	DMS_START
	RETURN

;********************************************************************************

GLOBAL	DELAY_S
DELAY_S:
GLOBAL	DS_START
DS_START:
	MOVLW	232
	MOVWF	SYSWAITTEMPMS
	MOVLW	3
	MOVWF	SYSWAITTEMPMS_H
	CALL	DELAY_MS
	DECFSZ	SYSWAITTEMPS, F
	GOTO	DS_START
	RETURN

;********************************************************************************

;OVERLOADED SIGNATURE: STRING:BYTE:, SOURCE: USART.H (2317)
GLOBAL	HSERPRINT304
HSERPRINT304:
;PrintLen = PrintData(0)
	MOVF	SYSPRINTDATAHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSPRINTDATAHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	MOVWF	PRINTLEN
;If PrintLen <> 0 then
	MOVF	PRINTLEN,F
	BTFSC	STATUS,2
	GOTO	ENDIF12
;Write Data
;for SysPrintTemp = 1 to PrintLen
	MOVLW	1
	MOVWF	SYSPRINTTEMP
GLOBAL	SYSFORLOOP3
SYSFORLOOP3:
;HSerSend(PrintData(SysPrintTemp),comport )
	MOVF	SYSPRINTTEMP,W
	ADDWF	SYSPRINTDATAHANDLER,W
	MOVWF	FSR0L
	MOVLW	0
	ADDWFC	SYSPRINTDATAHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	MOVWF	SERDATA
	CALL	HSERSEND294
;next
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	SYSPRINTTEMP,W
	SUBWF	PRINTLEN,W
	MOVWF	SYSTEMP1
	MOVWF	SYSBYTETEMPA
	CLRF	SYSBYTETEMPB
	CALL	SYSCOMPEQUAL
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF13
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	INCF	SYSPRINTTEMP,F
	GOTO	SYSFORLOOP3
;END IF
GLOBAL	ENDIF13
ENDIF13:
GLOBAL	SYSFORLOOPEND3
SYSFORLOOPEND3:
;End If
GLOBAL	ENDIF12
ENDIF12:
;CR
;All Usarts
;--------------------------
;Specific USARTs
;------------------
	RETURN

;********************************************************************************

;SOURCE: USART.H (2525)
GLOBAL	HSERPRINTCRLF
HSERPRINTCRLF:
;repeat HSerPrintCRLFCount
	MOVF	HSERPRINTCRLFCOUNT,W
	MOVWF	SYSREPEATTEMP1
	BTFSC	STATUS,2
	GOTO	SYSREPEATLOOPEND1
GLOBAL	SYSREPEATLOOP1
SYSREPEATLOOP1:
;HSerSend(13,comport)
	MOVLW	13
	MOVWF	SERDATA
	CALL	HSERSEND294
;HSerSend(10,comport)
	MOVLW	10
	MOVWF	SERDATA
	CALL	HSERSEND294
;end Repeat
	DECFSZ	SYSREPEATTEMP1,F
	GOTO	SYSREPEATLOOP1
GLOBAL	SYSREPEATLOOPEND1
SYSREPEATLOOPEND1:
	RETURN

;********************************************************************************

;OVERLOADED SIGNATURE: BYTE:BYTE:, SOURCE: USART.H (1468)
GLOBAL	HSERSEND294
HSERSEND294:
GLOBAL	HSERSENDUSART1HANDLER
HSERSENDUSART1HANDLER:
;USART_TX_BLOCKING
;Wait While TXIF = Off
GLOBAL	SYSWAITLOOP3
SYSWAITLOOP3:
	BANKSEL	PIR4
	BTFSS	PIR4,6
	GOTO	SYSWAITLOOP3
;Wait until TRMT = 1
GLOBAL	SYSWAITLOOP4
SYSWAITLOOP4:
	BANKSEL	TX1STA
	BTFSS	TX1STA,1
	GOTO	SYSWAITLOOP4
;TXREG = SerData
	BANKSEL	SERDATA
	MOVF	SERDATA,W
	BANKSEL	TX1REG
	MOVWF	TX1REG
;Wait USART_DELAY
	MOVLW	1
	MOVWF	SYSWAITTEMPMS
	CLRF	SYSWAITTEMPMS_H
	BANKSEL	STATUS
	GOTO	DELAY_MS

;********************************************************************************

;SOURCE: 180_ENSURING_PROGRAM_MATCHES_CHIP_SPECFIIED_TO_SERIAL_TERMINAL.GCB (21)
GLOBAL	INITPPS
INITPPS:
;Module: UART pin directions
;Dir PORTC.4 Out    ' Make TX1 pin an output
	BCF	TRISC,4
;Module: UART1
;RC4PPS = 0x13          'RC4->EUSART1:TX1
	MOVLW	19
	BANKSEL	RC4PPS
	MOVWF	RC4PPS
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (159)
GLOBAL	INITSYS
INITSYS:
;asm showdebug This code block sets the internal oscillator to ChipMHz
;asm showdebug Default settings for microcontrollers with _OSCCON1_
;Default OSCCON1 typically, NOSC HFINTOSC; NDIV 1 - Common as this simply sets the HFINTOSC
;OSCCON1 = 0x60
	MOVLW	96
	BANKSEL	OSCCON1
	MOVWF	OSCCON1
;Default value typically, CSWHOLD may proceed; SOSCPWR Low power
;OSCCON3 = 0x00
	CLRF	OSCCON3
;Default value typically, MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled
;OSCEN = 0x00
	CLRF	OSCEN
;Default value
;OSCTUNE = 0x00
	CLRF	OSCTUNE
;asm showdebug The MCU is a chip family ChipFamily
;asm showdebug OSCCON type is 102
;OSCFRQ = 0b00000101
	MOVLW	5
	MOVWF	OSCFRQ
;asm showdebug _Complete_the_chip_setup_of_BSR,ADCs,ANSEL_and_other_key_setup_registers_or_register_bits
;Ensure all ports are set for digital I/O and, turn off A/D
;SET ADFM OFF
	BANKSEL	ADCON0
	BCF	ADCON0,2
;Switch off A/D Var(ADCON0)
;SET ADCON0.ADON OFF
	BCF	ADCON0,7
;ANSELA = 0
	BANKSEL	ANSELA
	CLRF	ANSELA
;ANSELC = 0
	CLRF	ANSELC
;Set comparator register bits for many MCUs with register CM2CON0
;C2EN = 0
	BANKSEL	CM2CON0
	BCF	CM2CON0,7
;C1EN = 0
	BCF	CM1CON0,7
;
;'Turn off all ports
;PORTA = 0
	BANKSEL	PORTA
	CLRF	PORTA
;PORTC = 0
	CLRF	PORTC
	RETURN

;********************************************************************************

;SOURCE: USART.H (945)
GLOBAL	INITUSART
INITUSART:
;Set the default value for USART handler - required when more than one USART
;comport = 1
	MOVLW	1
	MOVWF	COMPORT
;PIC USART 1 Init
;Set baud rate for chips with BRG16 bit
;SPBRGH = SPBRGH_TEMP
	MOVLW	3
	BANKSEL	SP1BRGH
	MOVWF	SP1BRGH
;SPBRGL = SPBRGL_TEMP
	MOVLW	64
	MOVWF	SP1BRGL
;BRG16: 16-bit Baud Rate Generator bit
;1 = bsf - 16-bit Baud Rate Generator is used
;0 = bcf - 8-bit Baud Rate Generator is used
;BRG16 = BRG16_TEMP
	BSF	BAUD1CON,3
;Set High Baud Rate Select bit
;BRGH = BRGH_TEMP
	BSF	TX1STA,2
;Enable async and TX mode
;[canskip]SYNC=0
	BCF	TX1STA,4
;[canskip]TXEN=1
	BSF	TX1STA,5
;SPEN=1
	BSF	RC1STA,7
;CREN=1
	BSF	RC1STA,4
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: STRING.H (457)
GLOBAL	FN_LTRIM
FN_LTRIM:
;Get length of string, return empty string.  If you dont do this you will return an uninitialize value... ooops
;Ltrim = ""
	MOVLW	LOW LTRIM
	MOVWF	FSR1L
	MOVLW	HIGH LTRIM
	MOVWF	FSR1H
	MOVLW	LOW STRINGTABLE37
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH STRINGTABLE37) & 127
	MOVWF	SYSSTRINGA_H
	CALL	SYSREADSTRING
;SysCharLTCount = SysInString2(0)
	MOVF	SYSSYSINSTRING2HANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRING2HANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	MOVWF	SYSCHARLTCOUNT
;If SysCharLTCount = 0 Then Exit Function
	MOVF	SYSCHARLTCOUNT,F
	BTFSC	STATUS,2
;If SysCharLTCount = 0 Then Exit Function
	RETURN
;If SysCharLTCount = 0 Then Exit Function
;find first non white space in the string
;SysCharLT = 0
	CLRF	SYSCHARLT
;For SysTempLT = 1 to SysCharLTCount
	MOVLW	1
	MOVWF	SYSTEMPLT
GLOBAL	SYSFORLOOP1
SYSFORLOOP1:
;if Asc(Mid (SysInString2, SysTempLT , 1)) <> 32 then
	MOVF	SYSSYSINSTRING2HANDLER,W
	MOVWF	SYSSYSINSTRINGHANDLER
	MOVF	SYSSYSINSTRING2HANDLER_H,W
	MOVWF	SYSSYSINSTRINGHANDLER_H
	MOVF	SYSTEMPLT,W
	MOVWF	SYSCHARSTART
	MOVLW	1
	MOVWF	SYSCHARCOUNT
	CALL	FN_MID
	MOVLW	LOW MID
	MOVWF	SYSSYSINSTRINGAHANDLER
	MOVLW	HIGH MID
	MOVWF	SYSSYSINSTRINGAHANDLER_H
	MOVLW	1
	MOVWF	SYSCHAR
	CALL	FN_ASC
	MOVLW	32
	SUBWF	ASC,W
	BTFSC	STATUS,2
	GOTO	ENDIF3
;SysCharLT = SysTempLT
	MOVF	SYSTEMPLT,W
	MOVWF	SYSCHARLT
;goto FoundNonSpaceChar1
	GOTO	FOUNDNONSPACECHAR1
;end if
GLOBAL	ENDIF3
ENDIF3:
;Next
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	SYSTEMPLT,W
	SUBWF	SYSCHARLTCOUNT,W
	MOVWF	SYSTEMP1
	MOVWF	SYSBYTETEMPA
	CLRF	SYSBYTETEMPB
	CALL	SYSCOMPEQUAL
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF4
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	INCF	SYSTEMPLT,F
	GOTO	SYSFORLOOP1
;END IF
GLOBAL	ENDIF4
ENDIF4:
GLOBAL	SYSFORLOOPEND1
SYSFORLOOPEND1:
GLOBAL	FOUNDNONSPACECHAR1
FOUNDNONSPACECHAR1:
;if SysCharLT <> 0 then
	MOVF	SYSCHARLT,F
	BTFSC	STATUS,2
	GOTO	ENDIF5
;Ltrim = Mid (SysInString2, SysCharLT )
	MOVF	SYSSYSINSTRING2HANDLER,W
	MOVWF	SYSSYSINSTRINGHANDLER
	MOVF	SYSSYSINSTRING2HANDLER_H,W
	MOVWF	SYSSYSINSTRINGHANDLER_H
	MOVF	SYSCHARLT,W
	MOVWF	SYSCHARSTART
	MOVLW	255
	MOVWF	SYSCHARCOUNT
	CALL	FN_MID
	MOVLW	LOW LTRIM
	MOVWF	FSR1L
	MOVLW	HIGH LTRIM
	MOVWF	FSR1H
	MOVLW	LOW MID
	MOVWF	FSR0L
	MOVLW	HIGH MID
	MOVWF	FSR0H
	CALL	SYSCOPYSTRING
;Exit Function
	RETURN
;end if
GLOBAL	ENDIF5
ENDIF5:
	RETURN

;********************************************************************************

;SOURCE: STRING.H (394)
GLOBAL	FN_MID
FN_MID:
;Empty input?
;If SysInString(0) = 0 Then
	MOVF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,F
	BTFSS	STATUS,2
	GOTO	ENDIF14
;Mid(0) = 0
	BANKSEL	SYSMID_0
	CLRF	SYSMID_0
;Exit Function
	BANKSEL	STATUS
	RETURN
;End If
GLOBAL	ENDIF14
ENDIF14:
;Starting position too low?
;If SysCharStart < 1 Then SysCharStart = 1
	MOVLW	1
	SUBWF	SYSCHARSTART,W
	BTFSC	STATUS,0
	GOTO	ENDIF15
;If SysCharStart < 1 Then SysCharStart = 1
	MOVLW	1
	MOVWF	SYSCHARSTART
;If SysCharStart < 1 Then SysCharStart = 1
GLOBAL	ENDIF15
ENDIF15:
;Starting position too high?
;If SysCharStart > SysInString(0) Then
	MOVF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	SYSCHARSTART,W
	SUBWF	INDF0,W
	BTFSC	STATUS,0
	GOTO	ENDIF16
;Mid(0) = 0
	BANKSEL	SYSMID_0
	CLRF	SYSMID_0
;Exit Function
	BANKSEL	STATUS
	RETURN
;End If
GLOBAL	ENDIF16
ENDIF16:
;Input length too high?
;SysCharStart -= 1
	DECF	SYSCHARSTART,F
;SysStringTemp = SysInString(0) - SysCharStart 'Max number of characters
	MOVF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	SYSCHARSTART,W
	SUBWF	INDF0,W
	MOVWF	SYSSTRINGTEMP
;If SysCharCount > SysStringTemp Then
	MOVF	SYSCHARCOUNT,W
	SUBWF	SYSSTRINGTEMP,W
	BTFSC	STATUS,0
	GOTO	ENDIF17
;SysCharCount = SysStringTemp
	MOVF	SYSSTRINGTEMP,W
	MOVWF	SYSCHARCOUNT
;End If
GLOBAL	ENDIF17
ENDIF17:
;Copy characters
;For SysStringTemp = 1 To SysCharCount
	MOVLW	1
	MOVWF	SYSSTRINGTEMP
GLOBAL	SYSFORLOOP4
SYSFORLOOP4:
;Mid(SysStringTemp) = SysInString(SysCharStart + SysStringTemp)
	MOVF	SYSSTRINGTEMP,W
	ADDWF	SYSCHARSTART,W
	MOVWF	SYSTEMP1
	ADDWF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVLW	0
	ADDWFC	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	MOVWF	SYSARRAYTEMP1
	MOVWF	SYSARRAYTEMP2
	MOVLW	LOW(MID)
	ADDWF	SYSSTRINGTEMP,W
	MOVWF	FSR0L
	CLRF	SYSTEMP1
	MOVLW	HIGH(MID)
	ADDWFC	SYSTEMP1,W
	MOVWF	FSR0H
	MOVF	SYSARRAYTEMP2,W
	MOVWF	INDF0
;Next
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	SYSSTRINGTEMP,W
	SUBWF	SYSCHARCOUNT,W
	MOVWF	SYSTEMP1
	MOVWF	SYSBYTETEMPA
	CLRF	SYSBYTETEMPB
	CALL	SYSCOMPEQUAL
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF18
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	INCF	SYSSTRINGTEMP,F
	GOTO	SYSFORLOOP4
;END IF
GLOBAL	ENDIF18
ENDIF18:
GLOBAL	SYSFORLOOPEND4
SYSFORLOOPEND4:
;Mid(0) = SysCharCount
	MOVF	SYSCHARCOUNT,W
	BANKSEL	SYSMID_0
	MOVWF	SYSMID_0
	BANKSEL	STATUS
	RETURN

;********************************************************************************

;SOURCE: STRING.H (426)
GLOBAL	FN_RTRIM
FN_RTRIM:
;Get length of string, return empty string.  If you dont do this you will return an uninitialize value... ooops
;RTrim = ""
	MOVLW	LOW RTRIM
	MOVWF	FSR1L
	MOVLW	HIGH RTRIM
	MOVWF	FSR1H
	MOVLW	LOW STRINGTABLE37
	MOVWF	SYSSTRINGA
	MOVLW	(HIGH STRINGTABLE37) & 127
	MOVWF	SYSSTRINGA_H
	CALL	SYSREADSTRING
;SysCharRTCount = SysInString3(0)
	MOVF	SYSSYSINSTRING3HANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRING3HANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	MOVWF	SYSCHARRTCOUNT
;If SysCharRTCount = 0 Then Exit Function
	MOVF	SYSCHARRTCOUNT,F
	BTFSC	STATUS,2
;If SysCharRTCount = 0 Then Exit Function
	RETURN
;If SysCharRTCount = 0 Then Exit Function
;find first non white space in the string from the Right
;SysCharRT = 0
	CLRF	SYSCHARRT
;For SysTempRT = SysCharRTCount to 1 step -1
	MOVF	SYSCHARRTCOUNT,W
	MOVWF	SYSTEMPRT
GLOBAL	SYSFORLOOP5
SYSFORLOOP5:
;INIT SYSFORLOOPSTEP4 :#0
	MOVLW	255
	MOVWF	SYSFORLOOPSTEP4
	MOVWF	SYSFORLOOPSTEP4_H
;was Asc(Mid (SysInString3, SysTempRT , 1))
;if SysInString3(SysTempRT) <> 32 then
	MOVF	SYSTEMPRT,W
	ADDWF	SYSSYSINSTRING3HANDLER,W
	MOVWF	FSR0L
	MOVLW	0
	ADDWFC	SYSSYSINSTRING3HANDLER_H,W
	MOVWF	FSR0H
	MOVLW	32
	SUBWF	INDF0,W
	BTFSC	STATUS,2
	GOTO	ENDIF20
;SysCharRT = SysTempRT
	MOVF	SYSTEMPRT,W
	MOVWF	SYSCHARRT
;goto FoundNonSpaceChar2
	GOTO	FOUNDNONSPACECHAR2
;end if
GLOBAL	ENDIF20
ENDIF20:
;Next
;INTEGER NEGATIVE STEP HANDLER IN FOR-NEXT STATEMENT
	BTFSS	SYSFORLOOPSTEP4_H,7
	GOTO	ELSE21_1
;IF ( SYSTEMPRT - 1) } -SYSFORLOOPSTEP4 THEN :#3N
	DECF	SYSTEMPRT,W
	MOVWF	SYSTEMP1
	COMF	SYSFORLOOPSTEP4,W
	MOVWF	SYSTEMP2
	COMF	SYSFORLOOPSTEP4_H,W
	MOVWF	SYSTEMP2_H
	INCF	SYSTEMP2,F
	BTFSC	STATUS,2
	INCF	SYSTEMP2_H,F
	MOVF	SYSTEMP1,W
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	MOVF	SYSTEMP2,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	SYSTEMP2_H,W
	MOVWF	SYSINTEGERTEMPB_H
	CALL	SYSCOMPLESSTHANINT
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF23
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A NEGATIVE VALUE
	MOVF	SYSFORLOOPSTEP4,W
	ADDWF	SYSTEMPRT,F
	GOTO	SYSFORLOOP5
;END IF
GLOBAL	ENDIF23
ENDIF23:
	GOTO	ENDIF21
GLOBAL	ELSE21_1
ELSE21_1:
;INTEGER POSITIVE STEP HANDLER IN FOR-NEXT STATEMENT
;IF (1 - SYSTEMPRT) } SYSFORLOOPSTEP4 THEN :#3P
	MOVF	SYSTEMPRT,W
	SUBLW	1
	MOVWF	SYSTEMP1
	MOVWF	SYSINTEGERTEMPA
	CLRF	SYSINTEGERTEMPA_H
	MOVF	SYSFORLOOPSTEP4,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	SYSFORLOOPSTEP4_H,W
	MOVWF	SYSINTEGERTEMPB_H
	CALL	SYSCOMPLESSTHANINT
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF24
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	MOVF	SYSFORLOOPSTEP4,W
	ADDWF	SYSTEMPRT,F
	GOTO	SYSFORLOOP5
;END IF
GLOBAL	ENDIF24
ENDIF24:
;END IF
GLOBAL	ENDIF21
ENDIF21:
GLOBAL	SYSFORLOOPEND5
SYSFORLOOPEND5:
GLOBAL	FOUNDNONSPACECHAR2
FOUNDNONSPACECHAR2:
;if SysCharRT <> 0 then
	MOVF	SYSCHARRT,F
	BTFSC	STATUS,2
	GOTO	ENDIF22
;Rtrim = Mid (SysInString3, 1, SysCharRT )
	MOVF	SYSSYSINSTRING3HANDLER,W
	MOVWF	SYSSYSINSTRINGHANDLER
	MOVF	SYSSYSINSTRING3HANDLER_H,W
	MOVWF	SYSSYSINSTRINGHANDLER_H
	MOVLW	1
	MOVWF	SYSCHARSTART
	MOVF	SYSCHARRT,W
	MOVWF	SYSCHARCOUNT
	CALL	FN_MID
	MOVLW	LOW RTRIM
	MOVWF	FSR1L
	MOVLW	HIGH RTRIM
	MOVWF	FSR1H
	MOVLW	LOW MID
	MOVWF	FSR0L
	MOVLW	HIGH MID
	MOVWF	FSR0H
	CALL	SYSCOPYSTRING
;Exit Function
	RETURN
;end if
GLOBAL	ENDIF22
ENDIF22:
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3078)
GLOBAL	SYSCOMPEQUAL
SYSCOMPEQUAL:
;Dim SysByteTempA, SysByteTempB, SysByteTempX as byte
;clrf SysByteTempX
	CLRF	SYSBYTETEMPX
;movf SysByteTempA, W
	MOVF	SYSBYTETEMPA, W
;subwf SysByteTempB, W
	SUBWF	SYSBYTETEMPB, W
;btfsc STATUS, Z
	BTFSC	STATUS,2
;comf SysByteTempX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (1772)
GLOBAL	SYSCOMPEQUALSTRING
SYSCOMPEQUALSTRING:
;Dim SysByteTempA As Byte
;Dim SysByteTempX As Byte
;SysByteTempX = 0
	CLRF	SYSBYTETEMPX
;Check length matches
;movf INDF0, W
	MOVF	INDF0, W
;movwf SysByteTempA
	MOVWF	SYSBYTETEMPA
;subwf INDF1, W
	SUBWF	INDF1, W
;btfss STATUS, Z
	BTFSS	STATUS,2
;return
	RETURN
;Check if empty
;movf SysByteTempA, F
	MOVF	SYSBYTETEMPA, F
;btfsc STATUS, Z
	BTFSC	STATUS,2
;goto SCEStrTrue
	GOTO	SCESTRTRUE
;Check each char, exit if not equal
GLOBAL	SYSSTRINGCOMP
SYSSTRINGCOMP:
;Move to next char
;addfsr 0, 1
	ADDFSR	0, 1
;addfsr 1, 1
	ADDFSR	1, 1
;Compare, exit if <>
;movf INDF0, W
	MOVF	INDF0, W
;subwf INDF1, W
	SUBWF	INDF1, W
;btfss STATUS, Z
	BTFSS	STATUS,2
;return
	RETURN
;decfsz SysByteTempA, F
	DECFSZ	SYSBYTETEMPA, F
;goto SysStringComp
	GOTO	SYSSTRINGCOMP
GLOBAL	SCESTRTRUE
SCESTRTRUE:
;comf SysByteTempX, F
	COMF	SYSBYTETEMPX, F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3714)
GLOBAL	SYSCOMPLESSTHANINT
SYSCOMPLESSTHANINT:
;Dim SysIntegerTempA, SysIntegerTempB, SysDivMultA as Integer
;Clear result
;SysByteTempX = 0
	CLRF	SYSBYTETEMPX
;Compare sign bits
;-A
;If SysIntegerTempA.15 = On Then
	BTFSS	SYSINTEGERTEMPA_H,7
	GOTO	ELSE25_1
;-A, +B, return true
;If SysIntegerTempB.15 = Off Then
	BTFSC	SYSINTEGERTEMPB_H,7
	GOTO	ENDIF26
;Set SysByteTempX to 255
;SysByteTempX = Not SysByteTempX
	COMF	SYSBYTETEMPX,F
;Exit Sub
	RETURN
;End If
GLOBAL	ENDIF26
ENDIF26:
;-A, -B, negate both and swap
;SysDivMultA = -SysIntegerTempA
	COMF	SYSINTEGERTEMPA,W
	MOVWF	SYSDIVMULTA
	COMF	SYSINTEGERTEMPA_H,W
	MOVWF	SYSDIVMULTA_H
	INCF	SYSDIVMULTA,F
	BTFSC	STATUS,2
	INCF	SYSDIVMULTA_H,F
;SysIntegerTempA = -SysIntegerTempB
	COMF	SYSINTEGERTEMPB,W
	MOVWF	SYSINTEGERTEMPA
	COMF	SYSINTEGERTEMPB_H,W
	MOVWF	SYSINTEGERTEMPA_H
	INCF	SYSINTEGERTEMPA,F
	BTFSC	STATUS,2
	INCF	SYSINTEGERTEMPA_H,F
;SysIntegerTempB = SysDivMultA
	MOVF	SYSDIVMULTA,W
	MOVWF	SYSINTEGERTEMPB
	MOVF	SYSDIVMULTA_H,W
	MOVWF	SYSINTEGERTEMPB_H
;+A
;Else
	GOTO	ENDIF25
GLOBAL	ELSE25_1
ELSE25_1:
;+A, -B, return false
;If SysIntegerTempB.15 = On Then
	BTFSC	SYSINTEGERTEMPB_H,7
;Exit Sub
	RETURN
;End If
;End If
GLOBAL	ENDIF25
ENDIF25:
;Test High, exit if more
;movf SysIntegerTempA_H,W
	MOVF	SYSINTEGERTEMPA_H,W
;subwf SysIntegerTempB_H,W
	SUBWF	SYSINTEGERTEMPB_H,W
;btfss STATUS,C
	BTFSS	STATUS,0
;return
	RETURN
;Test high, exit true if less
;movf SysIntegerTempB_H,W
	MOVF	SYSINTEGERTEMPB_H,W
;subwf SysIntegerTempA_H,W
	SUBWF	SYSINTEGERTEMPA_H,W
;btfss STATUS,C
	BTFSS	STATUS,0
;goto SCLTIntTrue
	GOTO	SCLTINTTRUE
;Test Low, exit if more or equal
;movf SysIntegerTempB,W
	MOVF	SYSINTEGERTEMPB,W
;subwf SysIntegerTempA,W
	SUBWF	SYSINTEGERTEMPA,W
;btfsc STATUS,C
	BTFSC	STATUS,0
;return
	RETURN
GLOBAL	SCLTINTTRUE
SCLTINTTRUE:
;comf SysByteTempX,F
	COMF	SYSBYTETEMPX,F
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (1374)
GLOBAL	SYSCOPYSTRING
SYSCOPYSTRING:
;Dim SysCalcTempA As Byte
;Dim SysStringLength As Byte
;Get and copy length
;movf INDF0, W
	MOVF	INDF0, W
;movwf SysCalcTempA
	MOVWF	SYSCALCTEMPA
;movwf INDF1
	MOVWF	INDF1
;goto SysCopyStringCheck
	GOTO	SYSCOPYSTRINGCHECK
;When appending, add length to counter
GLOBAL	SYSCOPYSTRINGPART
SYSCOPYSTRINGPART:
;movf INDF0, W
	MOVF	INDF0, W
;movwf SysCalcTempA
	MOVWF	SYSCALCTEMPA
;addwf SysStringLength, F
	ADDWF	SYSSTRINGLENGTH, F
GLOBAL	SYSCOPYSTRINGCHECK
SYSCOPYSTRINGCHECK:
;Exit if length = 0
;movf SysCalcTempA,F
	MOVF	SYSCALCTEMPA,F
;btfsc STATUS,Z
	BTFSC	STATUS,2
;return
	RETURN
GLOBAL	SYSSTRINGCOPY
SYSSTRINGCOPY:
;Increment pointers
;addfsr 0, 1
	ADDFSR	0, 1
;addfsr 1, 1
	ADDFSR	1, 1
;Copy character
;movf INDF0, W
	MOVF	INDF0, W
;movwf INDF1
	MOVWF	INDF1
;decfsz SysCalcTempA, F
	DECFSZ	SYSCALCTEMPA, F
;goto SysStringCopy
	GOTO	SYSSTRINGCOPY
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (1571)
GLOBAL	SYSREADSTRING
SYSREADSTRING:
;Dim SysCalcTempA As Byte
;Dim SysStringLength As Byte
;Get length
;call SysStringTables
	CALL	SYSSTRINGTABLES
;movwf SysCalcTempA
	MOVWF	SYSCALCTEMPA
;movwf INDF1
	MOVWF	INDF1
;goto SysStringReadCheck
	GOTO	SYSSTRINGREADCHECK
GLOBAL	SYSREADSTRINGPART
SYSREADSTRINGPART:
;Get length
;call SysStringTables
	CALL	SYSSTRINGTABLES
;movwf SysCalcTempA
	MOVWF	SYSCALCTEMPA
;addwf SysStringLength,F
	ADDWF	SYSSTRINGLENGTH,F
;Check length
GLOBAL	SYSSTRINGREADCHECK
SYSSTRINGREADCHECK:
;If length is 0, exit
;movf SysCalcTempA,F
	MOVF	SYSCALCTEMPA,F
;btfsc STATUS,Z
	BTFSC	STATUS,2
;return
	RETURN
;Copy
GLOBAL	SYSSTRINGREAD
SYSSTRINGREAD:
;Get char
;call SysStringTables
	CALL	SYSSTRINGTABLES
;Set char
;addfsr 1,1
	ADDFSR	1,1
;movwf INDF1
	MOVWF	INDF1
;decfsz SysCalcTempA, F
	DECFSZ	SYSCALCTEMPA, F
;goto SysStringRead
	GOTO	SYSSTRINGREAD
	RETURN

;********************************************************************************

GLOBAL	SYSSTRINGTABLES
SYSSTRINGTABLES:
	MOVF	SYSSTRINGA_H,W
	MOVWF	PCLATH
	MOVF	SYSSTRINGA,W
	INCF	SYSSTRINGA,F
	BTFSC	STATUS,2
	INCF	SYSSTRINGA_H,F
	MOVWF	PCL

GLOBAL	STRINGTABLE1
STRINGTABLE1:
	RETLW	21
	RETLW	32	; 
	RETLW	71	;G
	RETLW	114	;R
	RETLW	101	;E
	RETLW	97	;A
	RETLW	116	;T
	RETLW	32	; 
	RETLW	67	;C
	RETLW	111	;O
	RETLW	119	;W
	RETLW	32	; 
	RETLW	66	;B
	RETLW	65	;A
	RETLW	83	;S
	RETLW	73	;I
	RETLW	67	;C
	RETLW	32	; 
	RETLW	68	;D
	RETLW	101	;E
	RETLW	109	;M
	RETLW	111	;O


GLOBAL	STRINGTABLE2
STRINGTABLE2:
	RETLW	8
	RETLW	49	;1
	RETLW	54	;6
	RETLW	102	;F
	RETLW	49	;1
	RETLW	56	;8
	RETLW	49	;1
	RETLW	50	;2
	RETLW	54	;6


GLOBAL	STRINGTABLE3
STRINGTABLE3:
	RETLW	51
	RETLW	87	;W
	RETLW	114	;R
	RETLW	111	;O
	RETLW	110	;N
	RETLW	103	;G
	RETLW	32	; 
	RETLW	77	;M
	RETLW	105	;I
	RETLW	99	;C
	RETLW	114	;R
	RETLW	111	;O
	RETLW	99	;C
	RETLW	111	;O
	RETLW	110	;N
	RETLW	116	;T
	RETLW	114	;R
	RETLW	111	;O
	RETLW	108	;L
	RETLW	108	;L
	RETLW	101	;E
	RETLW	114	;R
	RETLW	32	; 
	RETLW	112	;P
	RETLW	114	;R
	RETLW	111	;O
	RETLW	103	;G
	RETLW	114	;R
	RETLW	97	;A
	RETLW	109	;M
	RETLW	32	; 
	RETLW	105	;I
	RETLW	110	;N
	RETLW	116	;T
	RETLW	101	;E
	RETLW	110	;N
	RETLW	100	;D
	RETLW	101	;E
	RETLW	100	;D
	RETLW	32	; 
	RETLW	102	;F
	RETLW	111	;O
	RETLW	114	;R
	RETLW	32	; 
	RETLW	49	;1
	RETLW	54	;6
	RETLW	102	;F
	RETLW	49	;1
	RETLW	56	;8
	RETLW	49	;1
	RETLW	50	;2
	RETLW	54	;6


GLOBAL	STRINGTABLE4
STRINGTABLE4:
	RETLW	25
	RETLW	84	;T
	RETLW	104	;H
	RETLW	101	;E
	RETLW	32	; 
	RETLW	77	;M
	RETLW	105	;I
	RETLW	99	;C
	RETLW	114	;R
	RETLW	111	;O
	RETLW	99	;C
	RETLW	111	;O
	RETLW	110	;N
	RETLW	116	;T
	RETLW	114	;R
	RETLW	111	;O
	RETLW	108	;L
	RETLW	108	;L
	RETLW	101	;E
	RETLW	114	;R
	RETLW	32	; 
	RETLW	105	;I
	RETLW	115	;S
	RETLW	32	; 
	RETLW	97	;A
	RETLW	32	; 


GLOBAL	STRINGTABLE5
STRINGTABLE5:
	RETLW	45
	RETLW	84	;T
	RETLW	104	;H
	RETLW	101	;E
	RETLW	32	; 
	RETLW	77	;M
	RETLW	105	;I
	RETLW	99	;C
	RETLW	114	;R
	RETLW	111	;O
	RETLW	99	;C
	RETLW	111	;O
	RETLW	110	;N
	RETLW	116	;T
	RETLW	114	;R
	RETLW	111	;O
	RETLW	108	;L
	RETLW	108	;L
	RETLW	101	;E
	RETLW	114	;R
	RETLW	32	; 
	RETLW	112	;P
	RETLW	114	;R
	RETLW	111	;O
	RETLW	103	;G
	RETLW	114	;R
	RETLW	97	;A
	RETLW	109	;M
	RETLW	32	; 
	RETLW	105	;I
	RETLW	110	;N
	RETLW	116	;T
	RETLW	101	;E
	RETLW	110	;N
	RETLW	100	;D
	RETLW	101	;E
	RETLW	100	;D
	RETLW	32	; 
	RETLW	102	;F
	RETLW	111	;O
	RETLW	114	;R
	RETLW	32	; 
	RETLW	116	;T
	RETLW	104	;H
	RETLW	101	;E
	RETLW	32	; 


GLOBAL	STRINGTABLE37
STRINGTABLE37:
	RETLW	0


GLOBAL	STRINGTABLE83
STRINGTABLE83:
	RETLW	8
	RETLW	49	;1
	RETLW	54	;6
	RETLW	70	;F
	RETLW	49	;1
	RETLW	56	;8
	RETLW	49	;1
	RETLW	50	;2
	RETLW	54	;6


;********************************************************************************

;SOURCE: STRING.H (453)
GLOBAL	FN_TRIM
FN_TRIM:
;trim = rtrim(ltrim(SysInString))
	MOVF	SYSSYSINSTRINGHANDLER,W
	MOVWF	SYSSYSINSTRING2HANDLER
	MOVF	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	SYSSYSINSTRING2HANDLER_H
	CALL	FN_LTRIM
	MOVLW	LOW LTRIM
	MOVWF	SYSSYSINSTRING3HANDLER
	MOVLW	HIGH LTRIM
	MOVWF	SYSSYSINSTRING3HANDLER_H
	CALL	FN_RTRIM
	MOVLW	LOW TRIM
	MOVWF	FSR1L
	MOVLW	HIGH TRIM
	MOVWF	FSR1H
	MOVLW	LOW RTRIM
	MOVWF	FSR0L
	MOVLW	HIGH RTRIM
	MOVWF	FSR0H
	GOTO	SYSCOPYSTRING

;********************************************************************************

;SOURCE: STRING.H (488)
GLOBAL	FN_UCASE
FN_UCASE:
;Get length of string, don't try copying if it's empty
;SysCharCount = SysInString(0)
	MOVF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVF	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	MOVWF	SYSCHARCOUNT
;UCase(0) = SysCharCount
	BANKSEL	SYSUCASE_0
	MOVWF	SYSUCASE_0
;If SysCharCount = 0 Then Exit Function
	BANKSEL	SYSCHARCOUNT
	MOVF	SYSCHARCOUNT,F
	BTFSC	STATUS,2
;If SysCharCount = 0 Then Exit Function
	RETURN
;If SysCharCount = 0 Then Exit Function
;Search string for lowercase letters, change to uppercase
;For SysStringTemp = 1 to SysCharCount
	MOVLW	1
	MOVWF	SYSSTRINGTEMP
GLOBAL	SYSFORLOOP2
SYSFORLOOP2:
;SysStrData = SysInString(SysStringTemp)
	MOVF	SYSSTRINGTEMP,W
	ADDWF	SYSSYSINSTRINGHANDLER,W
	MOVWF	FSR0L
	MOVLW	0
	ADDWFC	SYSSYSINSTRINGHANDLER_H,W
	MOVWF	FSR0H
	MOVF	INDF0,W
	MOVWF	SYSSTRDATA
;If SysStrData >= 97 Then
	MOVLW	97
	SUBWF	SYSSTRDATA,W
	BTFSS	STATUS,0
	GOTO	ENDIF7
;If SysStrData <= 122 Then SysStrData -= 32
	MOVF	SYSSTRDATA,W
	SUBLW	122
	BTFSS	STATUS,0
	GOTO	ENDIF9
;If SysStrData <= 122 Then SysStrData -= 32
	MOVLW	32
	SUBWF	SYSSTRDATA,F
;If SysStrData <= 122 Then SysStrData -= 32
GLOBAL	ENDIF9
ENDIF9:
;End If
GLOBAL	ENDIF7
ENDIF7:
;UCase(SysStringTemp) = SysStrData
	MOVLW	LOW(UCASE)
	ADDWF	SYSSTRINGTEMP,W
	MOVWF	FSR0L
	CLRF	SYSTEMP1
	MOVLW	HIGH(UCASE)
	ADDWFC	SYSTEMP1,W
	MOVWF	FSR0H
	MOVF	SYSSTRDATA,W
	MOVWF	INDF0
;Next
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	SYSSTRINGTEMP,W
	SUBWF	SYSCHARCOUNT,W
	MOVWF	SYSTEMP1
	MOVWF	SYSBYTETEMPA
	CLRF	SYSBYTETEMPB
	CALL	SYSCOMPEQUAL
	COMF	SYSBYTETEMPX,F
	BTFSS	SYSBYTETEMPX,0
	GOTO	ENDIF8
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	INCF	SYSSTRINGTEMP,F
	GOTO	SYSFORLOOP2
;END IF
GLOBAL	ENDIF8
ENDIF8:
GLOBAL	SYSFORLOOPEND2
SYSFORLOOPEND2:
	RETURN

;********************************************************************************

;START OF PROGRAM MEMORY PAGE 1
	PSECT	PROGMEM1,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	2048
;START OF PROGRAM MEMORY PAGE 2
	PSECT	PROGMEM2,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	4096
;START OF PROGRAM MEMORY PAGE 3
	PSECT	PROGMEM3,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	6144
;START OF PROGRAM MEMORY PAGE 4
	PSECT	PROGMEM4,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	8192
;START OF PROGRAM MEMORY PAGE 5
	PSECT	PROGMEM5,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	10240
;START OF PROGRAM MEMORY PAGE 6
	PSECT	PROGMEM6,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	12288
;START OF PROGRAM MEMORY PAGE 7
	PSECT	PROGMEM7,CLASS=CODE,SPACE=SPACE_CODE,DELTA=2, ABS, OVRLD 
	ORG	14336
;
; Declare Power-On-Reset entry point
;
 END     RESETVEC
