/*

CARDS
 card   C8 4E 1F 39
 button 0A 14 6D D9

*/

#chip mega328p, 16
#option Explicit

    'Generated by PIC PPS Tool for Great Cow Basic
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

        //         SSP1DATPPS = 0x0C;   //RB4->MSSP1:SDI1;
        //         RB5PPS = 0x15;       //RB5->MSSP1:SDO1;
        //         RB3PPS = 0x14;       //RB3->MSSP1:SCK1;

        // 'RC0->EUSART:TX;
        // RC0PPS = 0x0010
        // 'RC1->EUSART:RX;
        // RXPPS  = 0x0011

    End Sub
    'Template comment at the end of the config file


    #chip USART_BAUD_RATE 9600
    #chip USART_TX_BLOCKING



#include <softserial.h>

; ----- Config Serial UART (we use the onboard USB-serial converter):
#chip SER1_BAUD 256000   ; baudrate must be defined
#chip SER1_DATABITS 8    ; databits optional (default = 8)
#chip SER1_STOPBITS 1    ; stopbits optional (default = 1)
#chip SER1_INVERT Off    ; inverted polarity optional (default = Off)
; Config I/O ports for transmitting:
#chip SER1_TXPORT PORTD  ; I/O port (without .bit) must be defined
#chip SER1_TXPIN 7       ; portbit  must be defined

    

    'Pin mappings for SPI - this driver supports Hardware SPI and Software SPI
    
    // #chip RC522_CS       Portb.2           ' Chip select line
    // #chip RC522_RESET    portb.1           ' Reset line
    // #chip RC522_IRQ      portc.2           ' IRQ line

    // #chip RC522_DI       portb.4           ' Data in | MISO
    // #chip RC522_DO       portb.5           ' Data out | MOSI
    // #chip RC522_SCK      portb.3           ' Clock Line

    // #chip RC522_CS       Portb.2           ' Chip select line
    // #chip RC522_RESET    portb.1           ' Reset line
    // #chip RC522_IRQ      portc.2           ' IRQ line

    // #chip RC522_DI       portb.3           ' Data in | MISO
    // #chip RC522_DO       portb.4           ' Data out | MOSI
    // #chip RC522_SCK      portb.5           ' Clock Line

    #chip RC522_HARDWARESPI    ' remove/comment out if you want to use software SPI.
    #chip HWSPIMode MASTERFAST

    // Declare the array that will be used to hold the Card ID.
    dim rfid_id(4) as byte
    // Define the ports to be used
    #chip RC522_SCK   PortB.5
    #chip RC522_DI    PortB.4
    #chip RC522_DO    PortB.3
    #chip RC522_CS    PortB.2 
    #chip RC522_RESET PortB.1
    #chip RC522_IRQ   PortD.2



    HserPrintCRLF 2
    RC522_Init



    // On Interrupt ExtInt0 Call ISR
    // EICRA = 0x0A
    // Dim IRQ
    // IRQ = 0
Start:

    dim debug as Byte
    debug = 0
    Ser1Print "Started "
    Ser1Send  13               'new line in Terminal
    Ser1Send  10               '

    Do

        Ser1Send "."
        wait 1 s
        Dim IRQ
        If IRQ = 1 Then
            Ser1Send "+"
            IRQ =0 
        End If

        // If rc522_checkCard then
        rc522_checkCard
            Ser1Print " "+hex( rfid_id(4) )
            Ser1Print " "+hex( rfid_id(3) )
            Ser1Print " "+hex( rfid_id(2) )
            Ser1Print " "+hex( rfid_id(1) )
            Ser1Send  13               'new line in Terminal
            Ser1Send  10               '           
            // wait 1 s
        // End if

        RC522_Init
    Loop
End

Sub ISR
    IRQ = 1
    // write 0x00 into ComIrqReg and DivIrqReg inorder to clear interrupts.
    rc522_regWrite8( MFRC522_REG_COMM_IRQ, 0x00 ) //clear the interrupt
End Sub

Sub RC522_Init

    Dir RC522_CS        Out
    Dir RC522_RESET     Out
    Dir RC522_DI        In 
    Dir RC522_DO        Out
    Dir RC522_SCK       Out  
    Dir RC522_IRQ       In

    RC522_RESET = On
    repeat 2
        RC522_RESET = Off
        wait 10 ms 
        RC522_RESET = On
        wait 10 ms
    end Repeat  

    // Set Input port to Tristate
    RC522_IRQ = 1
    // Set ChipSelect to low
    RC522_CS = 0

    #ifdef RC522_HARDWARESPI
        ' harware SPI mode - script within the HWSPI ensures SPI is setup correctly, so, use the HWSPIMODESCRIPT constant
        asm showdebug SPI constant used equates to HWSPIMODESCRIPT
        SPIMode HWSPIMODESCRIPT, 0
    #endif

    // Inital configuration of the card reader chip
    rc522_regWrite8(MFRC522_REG_T_MODE,         0x80)
    rc522_regWrite8(MFRC522_REG_T_PRESCALER,    0xA9)
    rc522_regWrite8(MFRC522_REG_T_RELOAD_L,     0xE8)
    rc522_regWrite8(MFRC522_REG_T_RELOAD_H,     0x03)
    rc522_regWrite8(MFRC522_REG_TX_AUTO,        0x40)
    rc522_regWrite8(MFRC522_REG_MODE,           0x3D)

    // Setup the interrupts
    rc522_regWrite8( MFRC522_REG_COMM_IRQ,      0x80 ) //clear the interrupt
    rc522_regWrite8( MFRC522_REG_COMM_IE_N ,    0x7F ) //set the interrupt
    rc522_regWrite8( MFRC522_REG_DIV1_EN ,      0x94 ) // propogate to IRQ pin using CRC

    // Open the antenna
    rc522_antennaON()   

End Sub

'''Send a command to the RC522 
'''@param RC522SendByte Command to send
'''@hide
sub  SendCommand_RC522( IN RC522SendByte as byte )

    set RC522_CS OFF;
    set RC522_DC OFF;

    #ifdef RC522_HARDWARESPI
    'Hardware SPI ****************************************
        SPITransfer  RC522SendByte,  RC522TempOut
        set RC522_CS ON;
        exit sub
    #endif

    #ifndef RC522_HARDWARESPI
    'Software SPI ****************************************
    repeat 8

    if RC522SendByte.7 = ON  then
        set RC522_DO ON;
    else
        set RC522_DO OFF;
    end if
    SET GLCD_SCK On;
    rotate RC522SendByte left
    set GLCD_SCK Off;

    end repeat
    set RC522_CS ON;
    #endif

end Sub

'''Send a data byte to the RC522 GLCD
'''@param RC522SendByte Byte to send
'''@hide
sub  SendData_RC522( IN RC522SendByte as byte )


    set RC522_CS OFF;
    set RC522_DC ON;

    #ifdef RC522_HARDWARESPI
    'Hardware SPI ****************************************
        SPITransfer  RC522SendByte,  RC522TempOut
        set RC522_CS ON;
        exit sub
    #endif

    #ifndef RC522_HARDWARESPI
    'Software SPI ****************************************
    repeat 8

    if RC522SendByte.7 = ON then
        set RC522_DO ON;
    else
        set RC522_DO OFF;
    end if
    SET GLCD_SCK On;
    rotate RC522SendByte left
    set GLCD_SCK Off;

    end Repeat
    set RC522_CS ON;
    #endif
 
end Sub

Sub rc522_regWrite8 (  in __RC522Reg, In __RC522Data )

If ( debug & 2 ) = 2 then
    HserPrintCRLF
    HserPrint "HW regWrite8: Reg="
    HserPrint "0x"
    HserPrint hex(__RC522Reg)
    HserPrint ", Data=0x"
    HserPrint hex(__RC522Data)
    HserPrintCRLF 
end if
    Dim __RC522TempReg, __RC522TempOut  as Byte

    __RC522TempReg = ( __RC522Reg * 2 ) AND 0x7E
    
    set RC522_CS OFF

    #ifdef RC522_HARDWARESPI
    'Hardware SPI ****************************************

If ( debug & 2 ) = 2 then
    HserPrint "            Trans=0x"
    HserPrint hex(__RC522TempReg)
    HserPrint ", Data=0x"
    HserPrint hex(__RC522Data)
    HserPrintCRLF 
end if
        SPITransfer  __RC522TempReg,  __RC522TempOut
        SPITransfer  __RC522Data   ,  __RC522TempOut
        set RC522_CS ON
        exit sub
    #endif

    #ifndef RC522_HARDWARESPI
// ! this is not tested
    'Software SPI ****************************************
    // repeat 8

    //     if RC522Reg.7 = ON then
    //         set RC522_DO ON;
    //     else
    //         set RC522_DO OFF;
    //     end if
    //     SET RC522_SCK On;
    //     rotate RC522Reg left
    //     set RC522_SCK Off;

    // end Repeat

    // repeat 8
    //     if RC522Data.7 = ON then
    //         set RC522_DO ON;
    //     else
    //         set RC522_DO OFF;
    //     end if
    //     SET RC522_SCK On;
    //     rotate RC522Data left
    //     set RC522_SCK Off;

    // end Repeat

    // set RC522_CS ON;
    #endif    

End Sub

Function rc522_regRead8 (  in __RC522Reg  )

Dim __RC522TempReg, __RC522TempOut  as Byte
__RC522TempReg = __RC522Reg

If ( debug & 2 ) = 2 then
    HserPrintCRLF
    HserPrint "HW regRead8: Reg="
    HserPrint "0x"
    HserPrint hex(__RC522TempReg)
    HserPrintCRLF 
end if
    __RC522TempReg = ( __RC522Reg * 2) AND 0x7E
    __RC522TempReg = __RC522TempReg or 0x80
    
    rc522_regRead8 = 0x55

    set RC522_CS OFF

    #ifdef RC522_HARDWARESPI
    'Hardware SPI ****************************************


        SPITransfer  __RC522TempReg,  rc522_regRead8
        set RC522_CS ON

If ( debug & 2 ) = 2 then
    HserPrint "             Trans=0x"
    HserPrint hex(__RC522TempReg)
    HserPrint ", Data=0x"
    HserPrint hex(rc522_regRead8)
    HserPrintCRLF 
end if
        exit sub
    #endif

    #ifndef RC522_HARDWARESPI
// ! this is not tested
    'Software SPI ****************************************

    #endif    

End Function


Sub rc522_antennaOn
    Dim _rc522_checkCard_status

    // Read the TX control register
    _rc522_checkCard_status = rc522_regRead8( MFRC522_REG_TX_CONTROL )

    If ( _rc522_checkCard_status & 0x03 ) = 0 Then
        rc522_setBit( MFRC522_REG_TX_CONTROL , 0x03)   
    End If



End Sub

Sub rc522_clearBit( in __RC522reg, in  __RC522mask)

  Dim _RC522tempreg as Byte
  _RC522tempreg = __RC522reg
  rc522_regWrite8( _RC522tempreg, rc522_regRead8( __RC522reg ) & NOT __RC522mask )

    // rc522_regWrite8(reg, rc522_regRead8(reg)&(~mask))


End Sub


Sub rc522_setBit( in __RC522reg, in  __RC522mask)

  Dim _RC522tempreg as Byte
  _RC522tempreg = __RC522reg
  rc522_regWrite8( _RC522tempreg, rc522_regRead8( __RC522reg ) OR __RC522mask )

End Sub


/* MFRC522 Commands */
#chip PCD_IDLE                0x00   //NO action; Cancel the current command
#chip PCD_AUTHENT             0x0E   //Authentication Key
#chip PCD_RECEIVE             0x08   //Receive Data
#chip PCD_TRANSMIT            0x04   //Transmit data
#chip PCD_TRANSCEIVE          0x0C   //Transmit and receive data,
#chip PCD_RESETPHASE          0x0F   //Reset
#chip PCD_CALCCRC             0x03   //CRC Calculate

/* Mifare_One card command word */
#chip PICC_REQIDL             0x26   // find the antenna area does not enter hibernation
#chip PICC_REQALL             0x52   // find all the cards antenna area
#chip PICC_ANTICOLL           0x93   // anti-collision
#chip PICC_SElECTTAG          0x93   // election card
#chip PICC_AUTHENT1A          0x60   // authentication key A
#chip PICC_AUTHENT1B          0x61   // authentication key B
#chip PICC_READ               0x30   // Read Block
#chip PICC_WRITE              0xA0   // write block
#chip PICC_DECREMENT          0xC0   // debit
#chip PICC_INCREMENT          0xC1   // recharge
#chip PICC_RESTORE            0xC2   // transfer block data to the buffer
#chip PICC_TRANSFER           0xB0   // save the data in the buffer
#chip PICC_HALT               0x50   // Sleep

/* MFRC522 Registers */
//Page 0: Command and Status
#chip MFRC522_REG_RESERVED00  0x00
#chip MFRC522_REG_COMMAND     0x01
#chip MFRC522_REG_COMM_IE_N   0x02
#chip MFRC522_REG_DIV1_EN     0x03
#chip MFRC522_REG_COMM_IRQ    0x04
#chip MFRC522_REG_DIV_IRQ     0x05
#chip MFRC522_REG_ERROR       0x06
#chip MFRC522_REG_STATUS1     0x07
#chip MFRC522_REG_STATUS2     0x08
#chip MFRC522_REG_FIFO_DATA   0x09
#chip MFRC522_REG_FIFO_LEVEL  0x0A
#chip MFRC522_REG_WATER_LEVEL 0x0B
#chip MFRC522_REG_CONTROL     0x0C
#chip MFRC522_REG_BIT_FRAMING 0x0D
#chip MFRC522_REG_COLL        0x0E
#chip MFRC522_REG_RESERVED01  0x0F
//Page 1: Command
#chip MFRC522_REG_RESERVED10 0x10
#chip MFRC522_REG_MODE       0x11
#chip MFRC522_REG_TX_MODE    0x12
#chip MFRC522_REG_RX_MODE    0x13
#chip MFRC522_REG_TX_CONTROL 0x14
#chip MFRC522_REG_TX_AUTO    0x15
#chip MFRC522_REG_TX_SELL    0x16
#chip MFRC522_REG_RX_SELL    0x17
#chip MFRC522_REG_RX_THRESHOLD    0x18
#chip MFRC522_REG_DEMOD      0x19
#chip MFRC522_REG_RESERVED11 0x1A
#chip MFRC522_REG_RESERVED12 0x1B
#chip MFRC522_REG_MIFARE     0x1C
#chip MFRC522_REG_RESERVED13 0x1D
#chip MFRC522_REG_RESERVED14 0x1E
#chip MFRC522_REG_SERIALSPEED     0x1F
//Page 2: CFG
#chip MFRC522_REG_RESERVED20 0x20
#chip MFRC522_REG_CRC_RESULT_M    0x21
#chip MFRC522_REG_CRC_RESULT_L    0x22
#chip MFRC522_REG_RESERVED21 0x23
#chip MFRC522_REG_MOD_WIDTH  0x24
#chip MFRC522_REG_RESERVED22 0x25
#chip MFRC522_REG_RF_CFG     0x26
#chip MFRC522_REG_GS_N       0x27
#chip MFRC522_REG_CWGS_PREG  0x28
#chip MFRC522_REG__MODGS_PREG     0x29
#chip MFRC522_REG_T_MODE     0x2A
#chip MFRC522_REG_T_PRESCALER     0x2B
#chip MFRC522_REG_T_RELOAD_H 0x2C
#chip MFRC522_REG_T_RELOAD_L 0x2D
#chip MFRC522_REG_T_COUNTER_VALUE_H 0x2E
#chip MFRC522_REG_T_COUNTER_VALUE_L 0x2F
//Page 3:TestRegister
#chip MFRC522_REG_RESERVED30 0x30
#chip MFRC522_REG_TEST_SEL1  0x31
#chip MFRC522_REG_TEST_SEL2  0x32
#chip MFRC522_REG_TEST_PIN_EN         0x33
#chip MFRC522_REG_TEST_PIN_VALUE      0x34
#chip MFRC522_REG_TEST_BUS   0x35
#chip MFRC522_REG_AUTO_TEST  0x36
#chip MFRC522_REG_VERSION    0x37
#chip MFRC522_REG_ANALOG_TEST         0x38
#chip MFRC522_REG_TEST_ADC1  0x39
#chip MFRC522_REG_TEST_ADC2  0x3A
#chip MFRC522_REG_TEST_ADC0  0x3B
#chip MFRC522_REG_RESERVED31 0x3C
#chip MFRC522_REG_RESERVED32 0x3D
#chip MFRC522_REG_RESERVED33 0x3E
#chip MFRC522_REG_RESERVED34 0x3F

//Dummy byte
#chip MFRC522_DUMMY         0x00
//Max length
#chip MFRC522_MAX_LEN         16


/*
 * @brief Check card
*/
Function rc522_checkCard as Bit

    // Declare variables
    Dim __rc522_checkCard_status

    // Set return array to zeros
    rfid_id = 0,0,0,0

    // Set function to false
    rc522_checkCard = false
debug = 1
    //Find cards, return card type
    __rc522_checkCard_status = rc522_request( PICC_REQIDL, rfid_id )
debug = 0
    // Check return status was true
    if ( __rc522_checkCard_status = true) Then
        //Card detected
        //Anti-collision, return card serial number 4 bytes
        rc522_checkCard = rc522_antiColl( rfid_id )
    end if

    //Command card into hibernation
    rc522_halt()      

End Function

/**
 * @brief Request function
 */
Function rc522_request( __reqMode,  rfid_id ) as BIT

    rc522_request = true
    Dim __backBits as Byte
    Dim _RC522_request_status as Byte

    rc522_regWrite8( MFRC522_REG_BIT_FRAMING, 0x07)   //! HW regWrite8: Reg=0x0D, Data=0x07
    rfid_id(1) = __reqMode
    _RC522_request_status = rc522_toCard( PCD_TRANSCEIVE, rfid_id, 1, rfid_id, __backBits )

    if (( _RC522_request_status <> true) | ( __backBits <> 0x10) ) Then
        HSerPrintStringCRLF " rc522_request failure/error"
        rc522_request = false
    end if

End Function

Function rc522_antiColl
    rc522_antiColl = true
    //   bool status;
    //   uint8_t i;
    //   uint8_t serNumCheck = 0;
    //   uint16_t unLen;
    //   //for (i = 0; i < 4; i++)
    // //    printf("Anticoll In %d: 0x%02x\r\n", i, serNum[i]);


    //   rc522_regWrite8(MFRC522_REG_BIT_FRAMING, 0x00);    //TxLastBists = BitFramingReg[2..0]

    //   serNum[0] = PICC_ANTICOLL;
    //   serNum[1] = 0x20;
    //   status = rc522_toCard(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen);

    //   //for (i = 0; i < 4; i++)
    // //      printf("Anticoll ToCard %d: 0x%02x\r\n", i, serNum[i]);

    //   if (status == true) {
    //     //Check card serial number
    //     for (i = 0; i < 4; i++) {
    //       serNumCheck ^= serNum[i];
    //     }
    //     if (serNumCheck != serNum[i]) {
    //       status = false;
    //     }
    //   }
    //   return status;


End Function

Sub rc522_halt
    Dim _unlen
    Dim _commandBuffer(3)
    _commandBuffer = PICC_HALT, 0, 0, 0

    rc522_calculateCRC( _commandBuffer, 2, _commandBuffer(2) )

    rc522_toCard( PCD_TRANSCEIVE, _commandBuffer, 4, _commandBuffer, _unLen )

End Sub

Sub rc522_calculateCRC

End Sub

    // uint8_t command,
    // uint8_t* sendData,
    // uint8_t sendLen,
    // uint8_t* backData,
    // uint16_t* backLen


Function rc522_toCard( __command, in rfid_id(), __rfid_sendlength, in rfid_id() , __backlengthbits )

        //     uint8_t command,
        //     uint8_t* sendData,
        //     uint8_t sendLen,
        //     uint8_t* backData,
        //     uint16_t* backLen)
        // {
        Dim rc522_toCard_status as Byte :rc522_toCard_status = false
        Dim rc522_irqEn as Byte         :rc522_irqEn = 0
        Dim rc522_waitIRq as Byte       :rc522_waitIRq = 0
        Dim rc522_lastBits as Byte      :rc522_lastBits = 0
        Dim rc522_backlen as Byte 
        Dim __rc522loop as Byte


        Select Case __command

            Case PCD_AUTHENT
                rc522_irqEn     = 0x12
                rc522_waitIRq   = 0x10

            Case PCD_TRANSCEIVE
                rc522_irqEn     = 0x77
                rc522_waitIRq   = 0x30

        End Select
// HserPrint "@phase 1"
        rc522_regWrite8(MFRC522_REG_COMM_IE_N, rc522_irqEn | 0x80)  //!HW regWrite8: Reg=0x02, Data=0xF7
// HserPrint "@phase 2"
        rc522_clearBit(MFRC522_REG_COMM_IRQ, 0x80)                  //!HW regRead8: Reg=0x04
// HserPrint "@phase 3"
        rc522_setBit(MFRC522_REG_FIFO_LEVEL, 0x80)                  //!Flush the FIFO buffer
// HserPrint "@phase 4"
        rc522_regWrite8(MFRC522_REG_COMMAND, PCD_IDLE)
// HserPrint "@phase 5"
      //Writing data to the FIFO
    //   HSerPrintStringCRLF "Writing data to the FIFO"

        // Write the array to the device from element 1 to required size
        for __rc522loop = 1 to __rfid_sendlength
            rc522_regWrite8(MFRC522_REG_FIFO_DATA,  rfid_id ( __rc522loop ))
        next
// HserPrint "@phase 6"
      //Execute the command
    //   HSerPrintStringCRLF "Execute the command"
        rc522_regWrite8(MFRC522_REG_COMMAND, __command)
// HserPrintCRLF
// HSerSend 9
// HserPrint "1 rc522_regRead8(MFRC522_REG_ERROR) = 0x"
// temp = rc522_regRead8(MFRC522_REG_ERROR)
// HserPrint hex(temp)
// HSerSend 9
// HserPrint hex( temp & 0x1B)
// HSerSend 9
// HserPrintByteCRLF  ( temp & 0x1B ) = 0x1B        
 
        if ( __command = PCD_TRANSCEIVE ) Then
            rc522_setBit(MFRC522_REG_BIT_FRAMING, 0x80)   //StartSend=1,transmission of data starts
        end if
HserPrint "@phase 7":HserPrintCRLF
          //Waiting to receive data to complete
        __rc522loop = 100;  //according to the clock frequency adjustment, the operator M1 card maximum waiting time 25ms???
        do 
            rc522_toCard_status = rc522_regRead8(MFRC522_REG_COMM_IRQ)

            __rc522loop--
if debug=1 then
// HserPrint "__rc522loop =" +str(__rc522loop): HserPrintCRLF
HserPrint "1. rc522_toCard_status =0x"+hex(rc522_toCard_status): HserPrintCRLF

// HserPrint "! rc522_toCard_status &01 = "+str(! ( (rc522_toCard_status & 0x01) = 0x01 )): HserPrintCRLF

// HserPrint "rc522_waitIRq = "+Str(rc522_waitIRq): HSerPrintCRLF
// HserPrint "! rc522_toCard_status & rc522_waitIRq = "+str(NOT (( rc522_toCard_status & rc522_waitIRq ) = rc522_waitIRq) ): HserPrintCRLF
// HserPrint "loop " + str( ( __rc522loop > 0) & NOT ( ( rc522_toCard_status & 0x01 ) = 0x01 ) & NOT (( rc522_toCard_status & rc522_waitIRq ) = rc522_waitIRq) )
end if

// while ((i!=0) && !(n&0x01) && !(n&waitIRq));

        loop while ( ( __rc522loop > 0) & NOT ( ( rc522_toCard_status & 0x01 ) ) & NOT (( rc522_toCard_status & rc522_waitIRq ) ) )

HserPrint "__rc522loop =" +str(__rc522loop): HserPrintCRLF

// HserPrint "@phase 8"
HSerPrintCRLF

        //StartSend=0
        rc522_clearBit(MFRC522_REG_BIT_FRAMING, 0x80)     

HserPrint "@phase 9":HSerPrintCRLF
HserPrint "2. rc522_toCard_status = 0x"+hex(rc522_toCard_status)
HSerPrintCRLF
        dim temp
// HserPrint "rc522_toCard_status ="
// HserPrintByteCRLF rc522_toCard_status
        if ( __rc522loop <> 0 )  Then
// HSerSend 9
// HserPrint "2 rc522_regRead8(MFRC522_REG_ERROR) = 0x"
// temp = rc522_regRead8(MFRC522_REG_ERROR)
// HserPrint hex(temp)
// HSerSend 9
// HserPrint hex( temp & 0x1B)
// HSerSend 9
// HserPrintByteCRLF  ( temp & 0x1B ) = 0x1B

            if !(( rc522_regRead8(MFRC522_REG_ERROR) & 0x1B) = 0x00 ) Then
                rc522_toCard_status = true
                if ( rc522_toCard_status & rc522_irqEn & 0x01 ) = 0x00 Then
HserPrint "@phase 10 = False and Exit":HSerPrintCRLF
                    rc522_toCard_status = false
                    Exit Sub
                End if

                if __command = PCD_TRANSCEIVE Then
HserPrint "@phase 11":HSerPrintCRLF
                    Dim rc522_toCard_fifo_value as byte
                    rc522_toCard_fifo_value = rc522_regRead8(MFRC522_REG_FIFO_LEVEL)

HserPrint  "rc522_toCard_fifo_value=0x"+hex(rc522_toCard_fifo_value) :HSerPrintCRLF  

//         n = rc522_regRead8(MFRC522_REG_FIFO_LEVEL);
//         uint8_t l = n;
//         lastBits = rc522_regRead8(MFRC522_REG_CONTROL) & 0x07;
//         if (lastBits) {
//           *backLen = (n - 1) * 8 + lastBits;
//         } else {
//           *backLen = n * 8;
//         }

//         if (n == 0) {
//           n = 1;
//         }
//         if (n > MFRC522_MAX_LEN) {
//           n = MFRC522_MAX_LEN;
//         }


                    rc522_lastBits = rc522_regRead8(MFRC522_REG_CONTROL) & 0x07
HserPrint  "rc522_lastBits=0x"+hex(rc522_lastBits) :HSerPrintCRLF                 
                    if ( rc522_lastBits <> 0 ) Then
                        rc522_backlen = ( (rc522_toCard_fifo_value - 1) * 8 ) + rc522_lastBits
                    else 
                        rc522_backlen = rc522_toCard_fifo_value * 8
                    End if

                    if rc522_toCard_fifo_value = 0 Then
                        rc522_toCard_fifo_value = 1
                    End if
                    if rc522_toCard_fifo_value > MFRC522_MAX_LEN Then
                        rc522_toCard_fifo_value = MFRC522_MAX_LEN
                    End if
HserPrint  "rc522_toCard_fifo_value=0x"+hex(rc522_toCard_fifo_value) :HSerPrintCRLF  
            
                    //Reading the received data in FIFO

//         for (i = 0; i < n; i++) {
//           uint8_t d = rc522_regRead8(MFRC522_REG_FIFO_DATA);
//           if (l == 4)
//             printf("%02x ", d);
//           backData[i] = d;
//         }

                    dim result as Byte
                    for __rc522loop = 1 to 4 //rc522_toCard_fifo_value
                        result = rc522_regRead8( MFRC522_REG_FIFO_DATA )
                        hserPrint fill(32, " ")
                        HserPrint "Read FIFO ("+str(__rc522loop)+")"
                        HSerPrintStringCRLF " " + hex( result )
                        rfid_id(__rc522loop) = result

                    //   if (l == 4)
                        // printf("%02x ", d);
                    //   backData[i] = d;
                    next
                    // if (l==4)
                    //   printf("\r\n");
                    // return status;
                
                Else 
                        HSerPrintStringCRLF "error"
                        rc522_toCard_status = false
                End if
            Else
                HserPrint "@phase 99" :HSerPrintCRLF 2
            End if
        else
            HserPrint "@phase 999" :HSerPrintCRLF 2
        End if
        rc522_toCard = rc522_toCard_status
End Function


// /**
//  * @brief Check card
//  */
//* PORTED bool rc522_checkCard(uint8_t *id)
// {
//   bool status=false;
//   //Find cards, return card type
//     status = rc522_request(PICC_REQIDL, id);
//     if (status == true) {
//       //Card detected
//       //Anti-collision, return card serial number 4 bytes
//       status = rc522_antiColl(id);
//     }
//     rc522_halt();      //Command card into hibernation

//     return status;
// }

// /**
//  * @brief Request function
//  */
//*PORTED bool rc522_request(uint8_t reqMode, uint8_t *tagType)
// {
//   bool status=false;
//   uint16_t backBits;
//   rc522_regWrite8(MFRC522_REG_BIT_FRAMING, 0x07);
//   tagType[0] = reqMode;
//   status = rc522_toCard(PCD_TRANSCEIVE, tagType, 1, tagType, &backBits);
//   if ((status != true) || (backBits != 0x10)) {
//     status = false;
//   }
//   return status;
// }

// /**
//  * @brief to Card
//  */
// bool rc522_toCard(
//     uint8_t command,
//     uint8_t* sendData,
//     uint8_t sendLen,
//     uint8_t* backData,
//     uint16_t* backLen)
// {
//   bool status = false;
//   uint8_t irqEn = 0x00;
//   uint8_t waitIRq = 0x00;
//   uint8_t lastBits;
//   uint8_t n;
//   uint16_t i;

//   switch (command) {
//     case PCD_AUTHENT: {
//       irqEn = 0x12;
//       waitIRq = 0x10;
//       break;
//     }
//     case PCD_TRANSCEIVE: {
//       irqEn = 0x77;
//       waitIRq = 0x30;
//       break;
//     }
//     default:
//       break;
//   }

//   rc522_regWrite8(MFRC522_REG_COMM_IE_N, irqEn | 0x80);
//   rc522_clearBit(MFRC522_REG_COMM_IRQ, 0x80);
//   rc522_setBit(MFRC522_REG_FIFO_LEVEL, 0x80);

//   rc522_regWrite8(MFRC522_REG_COMMAND, PCD_IDLE);

//   //Writing data to the FIFO
//   for (i = 0; i < sendLen; i++) {
//     rc522_regWrite8(MFRC522_REG_FIFO_DATA, sendData[i]);
//   }

//   //Execute the command
//   rc522_regWrite8(MFRC522_REG_COMMAND, command);
//   if (command == PCD_TRANSCEIVE) {
//     rc522_setBit(MFRC522_REG_BIT_FRAMING, 0x80);   //StartSend=1,transmission of data starts
//   }

//   //Waiting to receive data to complete
//   i = 100;  //i according to the clock frequency adjustment, the operator M1 card maximum waiting time 25ms???
//   do {
//     //CommIrqReg[7..0]
//     //Set1 TxIRq RxIRq IdleIRq HiAlerIRq LoAlertIRq ErrIRq TimerIRq
//     n = rc522_regRead8(MFRC522_REG_COMM_IRQ);
//     i--;
//   } while ((i!=0) && !(n&0x01) && !(n&waitIRq));

//   rc522_clearBit(MFRC522_REG_BIT_FRAMING, 0x80);     //StartSend=0

//   if (i != 0)  {
//     if (!(rc522_regRead8(MFRC522_REG_ERROR) & 0x1B)) {
//       status = true;
//       if (n & irqEn & 0x01) {
//         status = false;
//       }

//       if (command == PCD_TRANSCEIVE) {
//         n = rc522_regRead8(MFRC522_REG_FIFO_LEVEL);
//         uint8_t l = n;
//         lastBits = rc522_regRead8(MFRC522_REG_CONTROL) & 0x07;
//         if (lastBits) {
//           *backLen = (n - 1) * 8 + lastBits;
//         } else {
//           *backLen = n * 8;
//         }

//         if (n == 0) {
//           n = 1;
//         }
//         if (n > MFRC522_MAX_LEN) {
//           n = MFRC522_MAX_LEN;
//         }

//         //Reading the received data in FIFO
//         for (i = 0; i < n; i++) {
//           uint8_t d = rc522_regRead8(MFRC522_REG_FIFO_DATA);
//           if (l == 4)
//             printf("%02x ", d);
//           backData[i] = d;
//         }
//         if (l==4)
//           printf("\r\n");
//         return status;
//       }
//     } else {
//       printf("error\r\n");
//       status = false;
//     }
//   }

//   return status;
// }

// bool rc522_antiColl(uint8_t* serNum)
// {
//   bool status;
//   uint8_t i;
//   uint8_t serNumCheck = 0;
//   uint16_t unLen;
//   //for (i = 0; i < 4; i++)
// //    printf("Anticoll In %d: 0x%02x\r\n", i, serNum[i]);


//   rc522_regWrite8(MFRC522_REG_BIT_FRAMING, 0x00);    //TxLastBists = BitFramingReg[2..0]

//   serNum[0] = PICC_ANTICOLL;
//   serNum[1] = 0x20;
//   status = rc522_toCard(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen);

//   //for (i = 0; i < 4; i++)
// //      printf("Anticoll ToCard %d: 0x%02x\r\n", i, serNum[i]);

//   if (status == true) {
//     //Check card serial number
//     for (i = 0; i < 4; i++) {
//       serNumCheck ^= serNum[i];
//     }
//     if (serNumCheck != serNum[i]) {
//       status = false;
//     }
//   }
//   return status;
// }

// void rc522_halt(void)
// {
//   uint16_t unLen;
//   uint8_t buff[4];

//   buff[0] = PICC_HALT;
//   buff[1] = 0;
//   rc522_calculateCRC(buff, 2, &buff[2]);

//   rc522_toCard(PCD_TRANSCEIVE, buff, 4, buff, &unLen);
// }

// void rc522_calculateCRC(uint8_t*  pIndata, uint8_t len, uint8_t* pOutData)
// {
//   uint8_t i, n;

//   rc522_clearBit(MFRC522_REG_DIV_IRQ, 0x04);     //CRCIrq = 0
//   rc522_setBit(MFRC522_REG_FIFO_LEVEL, 0x80);      //Clear the FIFO pointer
//   //Write_MFRC522(CommandReg, PCD_IDLE);

//   //Writing data to the FIFO
//   for (i = 0; i < len; i++) {
//     rc522_regWrite8(MFRC522_REG_FIFO_DATA, *(pIndata+i));
//   }
//   rc522_regWrite8(MFRC522_REG_COMMAND, PCD_CALCCRC);

//   //Wait CRC calculation is complete
//   i = 0xFF;
//   do {
//     n = rc522_regRead8(MFRC522_REG_DIV_IRQ);
//     i--;
//   } while ((i!=0) && !(n&0x04));      //CRCIrq = 1

//   //Read CRC calculation result
//   pOutData[0] = rc522_regRead8(MFRC522_REG_CRC_RESULT_L);
//   pOutData[1] = rc522_regRead8(MFRC522_REG_CRC_RESULT_M);
// }

// /**
//  * @brief compare IDs
//  */
// bool rc522_compareIds(uint8_t *idCurrent, uint8_t *idReference)
// {
//   uint8_t i;
//   for(i=0; i<4;i++)
//   {
//     if(idCurrent[i] != idReference[i])
//     {
//       return false;
//     }
//   }
//   return true;
// }

