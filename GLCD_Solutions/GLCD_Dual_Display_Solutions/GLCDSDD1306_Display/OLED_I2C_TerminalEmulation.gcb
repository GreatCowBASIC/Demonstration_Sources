'''A program  for GCGB and GCB.
'''--------------------------------------------------------------------------------------------------------------------------------
'''This program shows how to emulate a serial terminal on two SSD1306 GLCD displays.
'''
'''For cursor control and display management, the programs responds to commands using a command set.
'''All commands all start with a 0xFE followed by one or more bytes.
'''The command set also controls the state of two General Purpose Output pins, and enables or disables a splash screen that can appear at power on, with version and baud rate information.
'''
'''Display command        0xFE  - Must proceed all commands
'''Clear Screen           0x58
'''Cursor Home            0x48
'''Cursor Back            0x4C
'''Cursor Forward         0x4D
'''Display On             0x46    Default is On
'''Display Off            0x42
'''Set Large Font         0x30    Default is Large font
'''Set Small Font         0x31
'''Enable New Line Clear  0x32    Default is Enabled
'''Disable New Line Clear 0x33
'''Enable Splash Screen   0x71    Default is settable
'''Disable Splash Screen  0x70
'''Set Cursor Position    0x47 XX YY  2 Bytes, X position and Y position
'''Set Brightness         0x99 BB   0 = Dim, other=Bright (Bright = default)
'''Set Display Invert     0x50 XX   0 = Normal, other=Inverted (Normal = default)
'''Set X Char Spacing     0x60 XX   Large font default is 9 pixels, Small font is 6
'''Set Y Line Spacing     0x61 YY Large font default is 16 pixels, Small font is 8
'''GPO Off                0x56 NN   GPO Number 1 or 2
'''GPO On                 0x57 NN   GPO Number 1 or 2
'''LED Control            0x59 XX 0 = Off, 1 = On  (LED1 on backpack board)
'''
'''Any characters between 32 and 127 is shown as the ASCII character.
'''
'''@author     Evan R. Venn
'''@licence    GPL
'''@version    1.00
'''@date       23/02/2020
'''********************************************************************************
#CHIP 16f18326
#INCLUDE <glcd.h>
#CONFIG mclre==On
#OPTION Explicit



'Generated by PIC PPS Tool for GCBASIC
'PPS Tool version: 0.0.6.1
'PinManager data: v1.79.0
'Generated for 16f18326
'
'Template comment at the start of the config file
'
#STARTUP InitPPS, 85
#DEFINE PPSToolPart 16f18326

Sub InitPPS

    'Module: EUSART
    'RC5 > RX
    RXPPS = 0x0015
    'Module: MSSP1
    'SCL1 > RA0
    RA0PPS = 0x0018
    'RA0 > SCL1 (bi-directional)
    SSP1CLKPPS = 0x0000
    'SDA1 > RA1
    RA1PPS = 0x0019
    'RA1 > SDA1 (bi-directional)
    SSP1DATPPS = 0x0001

End Sub
'Template comment at the end of the config file



' define the hardware I2C port pins
#DEFINE HI2C_DATA  PORTA.0
#DEFINE HI2C_CLOCK PORTA.1
' Pins must be set as inputs for using the MSSP Hardware I2C
Dir HI2C_DATA In
Dir HI2C_CLOCK In

#DEFINE HI2C_BAUD_RATE 400        ' define HI2C_BAUD_RATE 400 is the default

#DEFINE GLCD_OLED_FONT            ' This font set has 2 sizes
#DEFINE GLCD_TYPE GLCD_TYPE_SSD1306_TWIN
#DEFINE  DEFAULT_GLCDBACKGROUND TFT_BLACK

'USART settings
#DEFINE USART_BAUD_RATE 19200
#DEFINE USART_BLOCKING


'---- Main

#DEFINE SSD1306_TOP 0x7A
#DEFINE SSD1306_BOT 0x78


#DEFINE GPO_1 portc.1
#DEFINE GPO_2 portc.2
#DEFINE LED_1 porta.2
#DEFINE USART_SELECT porta.5
#DEFINE SPLASH_DISABLE_SELECT porta.4


#DEFINE CLEAR_SCREEN            0X58
#DEFINE CURSOR_HOME             0X48
#DEFINE CURSOR_BACK             0X4C
#DEFINE CURSOR_FORWARD          0X4D
#DEFINE DISPLAY_ON              0X46    'DEFAULT IS ON
#DEFINE DISPLAY_OFF_            0X42
#DEFINE SET_LARGE_FONT          0X30    'DEFAULT IS LARGE FONT
#DEFINE SET_SMALL_FONT          0X31
#DEFINE ENABLE_NEW_LINE_CLEAR   0X32    'DEFAULT IS ENABLED
#DEFINE DISABLE_NEW_LINE_CLEAR  0X33
#DEFINE ENABLE_SPLASH_SCREEN    0X71    'DEFAULT IS SETTABLE
#DEFINE DISABLE_SPLASH_SCREEN   0X70
#DEFINE SET_CURSOR_POSITION     0X47    'XX YY 2 BYTES, X POSITION AND Y POSITION
#DEFINE SET_BRIGHTNESS          0X99    'BB  0 = DIM, OTHER=BRIGHT (BRIGHT = DEFAULT)
#DEFINE SET_DISPLAY_INVERT      0X50    'XX  0 = NORMAL, OTHER=INVERTED (NORMAL = DEFAULT)
#DEFINE SET_X_CHAR_SPACING      0X60    'XX  LARGE FONT DEFAULT IS 9 PIXELS, SMALL FONT IS 6
#DEFINE SET_Y_LINE_SPACING      0X61    'YY  LARGE FONT DEFAULT IS 16 PIXELS, SMALL FONT IS 8
#DEFINE GPO_OFF                 0X56    'NN  GPO NUMBER 1 OR 2
#DEFINE GPO_ON                  0X57    'NN  GPO NUMBER 1 OR 2
#DEFINE LED_CONTROL             0X59    'XX

#DEFINE EEPROMSPLASH 0

' Constants etc required for Serial Buffer Ring.
#DEFINE BUFFER_SIZE 256
#DEFINE bkbhit (next_in <> next_out)
#DEFINE USART_DELAY Off

' Constants etc required for Backspace Buffer Ring
#DEFINE BACKSPACE_BUFFER_SIZE 128
#DEFINE backspacenotempty ( BackSpacenext_in <> BackSpacenext_in )

'Fix an issue in the libraries when printing single characters
#DEFINE  GLCDPrintIncrementPixelPositionMacro  localGLCDPrintIncrementPixelPositionMacro

Dir LED_1 Out
Dir GPO_1 Out
Dir GPO_2 Out
Dir USART_SELECT In
Dir SPLASH_DISABLE_SELECT In

'we will use element 0 in the array as part of out buffer
Dim backspacebuffer( BACKSPACE_BUFFER_SIZE - 1 )
'supporting backspace variables
Dim BackSpacenext_in As Byte
Dim BackSpacenext_out As Byte

'Create supporting variables
Dim next_in As Byte
Dim next_out As Byte
Dim syncbyte As Byte



'Buffer
'we will use element 0 in the array as part of out buffer
Dim buffer( BUFFER_SIZE - 1 )
Dim incominginstruction, lastcharacterwidth, GLCD_I2C_Device_Address As Byte
Dim eepromsplashdisabled, initialscreenpulse As Byte
Dim glcdstate As Byte
Dim displaycommand, firstcharincoming,NewLineCleared As BIT
'PrintLocX and PrintLocY are globals of the XY position
Dim  PrintLocX, PrintLocY As Byte
Dim selectedBaudRate As BIT


InitProgram


' Update Splash Screen, or, not.....
EPRead EEPROMSPLASH, eepromsplashdisabled
If eepromsplashdisabled = 0xFF AND SPLASH_DISABLE_SELECT = 1 Then
    GLCDfntDefaultSize = 2
    GLCDFontWidth = 10
    GLCDPrint 20,0, "WELCOME"

    If selectedBaudRate = 1 Then
        GLCDPrint 0,24,  "19200 bps"
    Else
        GLCDPrint 0,24,  "9600 bps"
    End If

    GLCDPrint 0,48,  GLCD_HEIGHT
    GLCDPrint 90,48, GLCD_WIDTH

    GLCDfntDefaultSize = 1
    GLCDPrint 50,48+64, "BOTTOM GLCD"
    GLCDPrint 0,24+64,  GLCD_HEIGHT
    GLCDPrint 90,24+64, GLCD_WIDTH

End If


initialscreenpulse = 1
Do While !bkbhit

    'Just pulses the screen waiting for data

    For GLCD_I2C_Device_Address  = 0x78 To 0x7A Step 2
        Literal_Cursor_Position_TwinSSD1306 ( 0 , 0 )
        Write_Data_TwinSSD1306 ( initialscreenpulse )
    Next
    Wait 250 ms

    For GLCD_I2C_Device_Address  = 0x78 To 0x7A Step 2
        Literal_Cursor_Position_TwinSSD1306 ( 0 , 0 )
        Write_Data_TwinSSD1306 ( 0x00 )
    Next
    Wait 250 ms

    initialscreenpulse = initialscreenpulse * 2
    If initialscreenpulse = 0 Then
        initialscreenpulse = 1
    End If
Loop

GLCDfntDefaultSize = 1

'Enable clearing of screen when first char arrives
firstcharincoming = TRUE
NewLineCleared = TRUE

'Loop Forever
Do Forever

    ' Do we have data in the serial buffer, so process
    Do While bkbhit

        If firstcharincoming Then
            For GLCD_I2C_Device_Address  = 0x78 To 0x7A Step 2
                GLCDCLS_TwinSSD1306 ( GLCDBackground )
            Next
            firstcharincoming = FALSE
        End If

        incominginstruction = bgetc

        If displaycommand Then

            Select Case incominginstruction

            Case CLEAR_SCREEN
                For GLCD_I2C_Device_Address  = 0x78 To 0x7A Step 2
                    GLCDCLS_TwinSSD1306 ( GLCDBackground )
                Next
                'Set the backspace buffer to the first address
                BackSpacenext_in = 0
                BackSpacenext_out = 0

            Case CURSOR_BACK
                'Get last character width
                lastcharacterwidth = PullChar

                'bit 7 is font 2.....
                If lastcharacterwidth.7 = 0 Then
                    If PrintLocX => lastcharacterwidth Then
                        PrintLocX = PrintLocX - lastcharacterwidth
                    Else
                        PrintLocX = 0
                    End If
                Else
                    lastcharacterwidth = lastcharacterwidth  AND 127
                    If PrintLocX => lastcharacterwidth Then
                        PrintLocX = PrintLocX - lastcharacterwidth
                    Else
                        PrintLocX = 0
                    End If
                End If

            Case DISABLE_SPLASH_SCREEN
                EPWrite EEPROMSPLASH, 0x01

            Case ENABLE_SPLASH_SCREEN
                EPWrite EEPROMSPLASH, 0xFF

            Case SET_DISPLAY_INVERT
                If GLCDBackground = TFT_BLACK Then
                    GLCDBackground = TFT_WHITE
                    GLCDForeground = TFT_BLACK
                Else
                    GLCDBackground = TFT_BLACK
                    GLCDForeground = TFT_WHITE
                End If

            Case SET_LARGE_FONT
                GLCDfntDefaultSize = 2
                GLCDFontWidth = 10

            Case SET_SMALL_FONT
                GLCDfntDefaultSize = 1
                'This is not needed as these are variable width fonts
                GLCDFontWidth = 5

            Case DISPLAY_OFF_
                For GLCD_I2C_Device_Address  = 0x78 To 0x7A Step 2
                    Write_Command_TwinSSD1306(SSD1306_DISPLAYOFF)
                Next

            Case DISPLAY_ON
                For GLCD_I2C_Device_Address  = 0x78 To 0x7A Step 2
                    Write_Command_TwinSSD1306(SSD1306_DISPLAYON)
                Next

            Case CURSOR_HOME
                Cursor_Position_TwinSSD1306 ( 0, 0 )
                PrintLocX = 0
                PrintLocY = 0

            Case DISABLE_NEW_LINE_CLEAR
                NewLineCleared = FALSE

            Case ENABLE_NEW_LINE_CLEAR
                NewLineCleared = TRUE

            Case SET_BRIGHTNESS
                'We need another parameter, so go get one...
                incominginstruction = bgetc
                For GLCD_I2C_Device_Address  = 0x78 To 0x7A Step 2
                    Write_Command_TwinSSD1306(SSD1306_SETCONTRAST)
                    Write_Command_TwinSSD1306(incominginstruction)
                Next

            Case CURSOR_FORWARD
                GLCDPrintString " "

            Case SET_CURSOR_POSITION
                'We need another parameter, so go get one...
                PrintLocX = bgetc
                'We need another parameter, so go get one...
                PrintLocY = bgetc


            Case GPO_OFF
                'We need another parameter, so go get one...
                incominginstruction = bgetc
                If incominginstruction = 1 Then
                    GPO_1 = Off
                Else
                    GPO_2 = Off
                End If

            Case GPO_ON
                'We need another parameter, so go get one...
                incominginstruction = bgetc
                If incominginstruction = 1 Then
                    GPO_1 = On
                Else
                    GPO_2 = On
                End If

            Case LED_CONTROL
                'We need another parameter, so go get one...
                incominginstruction = bgetc
                LED_1 = incominginstruction.0

            End Select

        Else

            'Protect again odd characters
            If incominginstruction > 31 AND incominginstruction < 128 Then

                GLCDPrintString CHR(incominginstruction)

            End If

        End If

        'this is a displaycommand
        If incominginstruction = 0xFE Then
            displaycommand = TRUE

        Else
            displaycommand = FALSE

            'End of a line or a CHR(13)
            If PrintLocX > 127 OR incominginstruction = 13 Then
                PrintLocY = ( PrintLocY +  ( 8  * GLCDfntDefaultSize ) ) MOD GLCD_HEIGHT
                If NewLineCleared = TRUE Then
                    PrintLocX = 0
                    If GLCDfntDefaultSize = 1 Then
                        Repeat 128
                            GLCDPrintString (" ")
                        End Repeat
                    Else
                        Repeat 15
                            GLCDPrintString (" ")
                        End Repeat
                    End If
                End If
                PrintLocX = 0
            End If

            'Only handles small font.  Needs to checked for large font
            If PrintLocY > 127 Then
                PrintLocY = 0
                PrintLocX = 0
            End If

        End If

    Loop

Loop



End



'Support backspace delete buffer

Sub PushChar ( In LastCharOut As Byte )

    Dim PushChartemppnt As Byte
    backspacebuffer(BackSpacenext_in) = LastCharOut
    PushChartemppnt = BackSpacenext_in
    BackSpacenext_in = ( BackSpacenext_in + 1 ) % BACKSPACE_BUFFER_SIZE
    If ( BackSpacenext_in = BackSpacenext_out ) Then
        ' buffer is full!!
        BackSpacenext_in = PushChartemppnt
    End If
End Sub

Function PullChar
    If  !backspacenotempty Then
        PullChar = backspacebuffer(BackSpacenext_out)
        BackSpacenext_out=(BackSpacenext_out+1) % BACKSPACE_BUFFER_SIZE
    Else
        PullChar = 0
    End If
End Function

Sub InitProgram

    'Set the buffer to the first address
    BackSpacenext_in = 0
    BackSpacenext_out = 0

    'Set the buffer ring to the first address
    next_in = 0
    next_out = 0

    'Hard code RS232 here
    Wait 10 ms
    selectedBaudRate = USART_SELECT
    If selectedBaudRate = 0 Then
        ' 9600
        SPBRGH = 3
        SPBRGL = 64

    Else
        '19200
        SPBRGH = 1
        SPBRGL = 159
    End If

    'Interrupt Handler - some have RCIE and some have U1RXIE, so handle
    #IFDEF BIT( RCIE )
        On Interrupt UsartRX1Ready Call readUSART
    #ENDIF
    #IFDEF BIT( U1RXIE )
        On Interrupt UART1ReceiveInterrupt Call readUSART
    #ENDIF

End Sub

'Serial buffer

Sub readUSART
    Dim temppnt As Byte
    buffer(next_in) = HSerReceive
    temppnt = next_in
    next_in = ( next_in + 1 ) % BUFFER_SIZE
    If ( next_in = next_out ) Then
        ' buffer is full!!
        next_in = temppnt
    End If
End Sub

Function bgetc
    Wait While !(bkbhit)
    bgetc = buffer(next_out)
    next_out=(next_out + 1) % BUFFER_SIZE
End Function


Macro localGLCDPrintIncrementPixelPositionMacro

      GLCDPrintLoc = GLCDPrintLoc + GLCDFontWidth

End Macro
